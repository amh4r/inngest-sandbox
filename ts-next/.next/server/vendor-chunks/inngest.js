/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/inngest";
exports.ids = ["vendor-chunks/inngest"];
exports.modules = {

/***/ "(rsc)/./node_modules/inngest/api/api.js":
/*!*****************************************!*\
  !*** ./node_modules/inngest/api/api.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestApi = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst net_js_1 = __webpack_require__(/*! ../helpers/net.js */ \"(rsc)/./node_modules/inngest/helpers/net.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst schema_js_1 = __webpack_require__(/*! ./schema.js */ \"(rsc)/./node_modules/inngest/api/schema.js\");\nconst realtimeSubscriptionTokenSchema = zod_1.z.object({\n    jwt: zod_1.z.string(),\n});\nconst sendSignalSuccessResponseSchema = zod_1.z.object({\n    data: zod_1.z.object({\n        run_id: zod_1.z.string().min(1),\n    }),\n});\nclass InngestApi {\n    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode, }) {\n        this.apiBaseUrl = baseUrl;\n        this.signingKey = signingKey;\n        this.signingKeyFallback = signingKeyFallback;\n        this.fetch = fetch;\n        this.mode = mode;\n    }\n    get hashedKey() {\n        return (0, strings_js_1.hashSigningKey)(this.signingKey);\n    }\n    get hashedFallbackKey() {\n        if (!this.signingKeyFallback) {\n            return;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);\n    }\n    // set the signing key in case it was not instantiated previously\n    setSigningKey(key) {\n        if (typeof key === \"string\" && this.signingKey === \"\") {\n            this.signingKey = key;\n        }\n    }\n    setSigningKeyFallback(key) {\n        if (typeof key === \"string\" && !this.signingKeyFallback) {\n            this.signingKeyFallback = key;\n        }\n    }\n    async getTargetUrl(path) {\n        if (this.apiBaseUrl) {\n            return new URL(path, this.apiBaseUrl);\n        }\n        let url = new URL(path, consts_js_1.defaultInngestApiBaseUrl);\n        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {\n            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);\n            if (devAvailable) {\n                url = new URL(path, consts_js_1.defaultDevServerHost);\n            }\n        }\n        return url;\n    }\n    async getRunSteps(runId, version) {\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url: await this.getTargetUrl(`/v0/runs/${runId}/actions`),\n        })\n            .then(async (resp) => {\n            const data = await resp.json();\n            if (resp.ok) {\n                return (0, types_js_1.ok)(schema_js_1.stepsSchemas[version].parse(data));\n            }\n            else {\n                return (0, types_js_1.err)(schema_js_1.errorSchema.parse(data));\n            }\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error retrieving step data\"),\n                status: 500,\n            });\n        });\n    }\n    async getRunBatch(runId) {\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url: await this.getTargetUrl(`/v0/runs/${runId}/batch`),\n        })\n            .then(async (resp) => {\n            const data = await resp.json();\n            if (resp.ok) {\n                return (0, types_js_1.ok)(schema_js_1.batchSchema.parse(data));\n            }\n            else {\n                return (0, types_js_1.err)(schema_js_1.errorSchema.parse(data));\n            }\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error retrieving event batch\"),\n                status: 500,\n            });\n        });\n    }\n    async publish(publishOptions, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data) {\n        // todo it may not be a \"text/stream\"\n        const isStream = data instanceof ReadableStream;\n        const url = await this.getTargetUrl(\"/v1/realtime/publish\");\n        url.searchParams.set(\"channel\", publishOptions.channel || \"\");\n        if (publishOptions.runId) {\n            url.searchParams.set(\"run_id\", publishOptions.runId);\n        }\n        publishOptions.topics.forEach((topic) => {\n            url.searchParams.append(\"topic\", topic);\n        });\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: Object.assign({ method: \"POST\", body: isStream\n                    ? data\n                    : typeof data === \"string\"\n                        ? data\n                        : JSON.stringify(data), headers: {\n                    \"Content-Type\": isStream ? \"text/stream\" : \"application/json\",\n                } }, (isStream ? { duplex: \"half\" } : {})),\n        })\n            .then((res) => {\n            if (!res.ok) {\n                throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);\n            }\n            return (0, types_js_1.ok)(undefined);\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error publishing event\"),\n                status: 500,\n            });\n        });\n    }\n    async sendSignal(signalOptions, options) {\n        const url = await this.getTargetUrl(\"/v1/signals\");\n        const body = {\n            signal: signalOptions.signal,\n            data: signalOptions.data,\n        };\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: Object.assign({ \"Content-Type\": \"application/json\" }, options === null || options === void 0 ? void 0 : options.headers),\n            },\n        })\n            .then(async (res) => {\n            // A 404 is valid if the signal was not found.\n            if (res.status === 404) {\n                return (0, types_js_1.ok)({\n                    runId: undefined,\n                });\n            }\n            // Save a clone of the response we can use to get the text of if we fail\n            // to parse the JSON.\n            const resClone = res.clone();\n            // JSON!\n            let json;\n            try {\n                json = await res.json();\n            }\n            catch (error) {\n                // res.json() failed so not a valid JSON response\n                return (0, types_js_1.err)({\n                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await resClone.text()}`,\n                    status: res.status,\n                });\n            }\n            // If we're not 2xx, something went wrong.\n            if (!res.ok) {\n                try {\n                    return (0, types_js_1.err)(schema_js_1.errorSchema.parse(json));\n                }\n                catch (_a) {\n                    // schema parse failed\n                    return (0, types_js_1.err)({\n                        error: `Failed to send signal: ${res.status} ${res.statusText} - ${await res.text()}`,\n                        status: res.status,\n                    });\n                }\n            }\n            // If we are 2xx, we should have a run_id.\n            const parseRes = sendSignalSuccessResponseSchema.safeParse(json);\n            if (!parseRes.success) {\n                return (0, types_js_1.err)({\n                    error: `Successfully sent signal, but response parsing failed: ${res.status} ${res.statusText} - ${await resClone.text()}`,\n                    status: res.status,\n                });\n            }\n            return (0, types_js_1.ok)({\n                runId: parseRes.data.data.run_id,\n            });\n        })\n            .catch((error) => {\n            // Catch-all if various things go wrong\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error sending signal\"),\n                status: 500,\n            });\n        });\n    }\n    async getSubscriptionToken(channel, topics) {\n        const url = await this.getTargetUrl(\"/v1/realtime/token\");\n        const body = topics.map((topic) => ({\n            channel,\n            name: topic,\n            kind: \"run\",\n        }));\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n            },\n        })\n            .then(async (res) => {\n            if (!res.ok) {\n                throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);\n            }\n            const data = realtimeSubscriptionTokenSchema.parse(await res.json());\n            return data.jwt;\n        })\n            .catch((error) => {\n            throw new Error((0, errors_js_1.getErrorMessage)(error, \"Unknown error getting subscription token\"));\n        });\n    }\n}\nexports.InngestApi = InngestApi;\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLGtGQUF5QjtBQUN4RCxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQW1CO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQywwREFBYTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQywrREFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsdURBQXVEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsaUJBQWlCLElBQUk7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQSw0REFBNEQsWUFBWSxFQUFFLGVBQWU7QUFDekY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9DQUFvQztBQUM3RSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxzQkFBc0I7QUFDN0c7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxpQkFBaUI7QUFDNUc7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxzQkFBc0I7QUFDN0k7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWSxFQUFFLGdCQUFnQixJQUFJLGlCQUFpQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2FwaS9hcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklubmdlc3RBcGkgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbmNvbnN0IGRldnNlcnZlcl9qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZGV2c2VydmVyLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lcnJvcnMuanNcIik7XG5jb25zdCBuZXRfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25ldC5qc1wiKTtcbmNvbnN0IHN0cmluZ3NfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0cmluZ3MuanNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uL3R5cGVzLmpzXCIpO1xuY29uc3Qgc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWEuanNcIik7XG5jb25zdCByZWFsdGltZVN1YnNjcmlwdGlvblRva2VuU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGp3dDogem9kXzEuei5zdHJpbmcoKSxcbn0pO1xuY29uc3Qgc2VuZFNpZ25hbFN1Y2Nlc3NSZXNwb25zZVNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBkYXRhOiB6b2RfMS56Lm9iamVjdCh7XG4gICAgICAgIHJ1bl9pZDogem9kXzEuei5zdHJpbmcoKS5taW4oMSksXG4gICAgfSksXG59KTtcbmNsYXNzIElubmdlc3RBcGkge1xuICAgIGNvbnN0cnVjdG9yKHsgYmFzZVVybCwgc2lnbmluZ0tleSwgc2lnbmluZ0tleUZhbGxiYWNrLCBmZXRjaCwgbW9kZSwgfSkge1xuICAgICAgICB0aGlzLmFwaUJhc2VVcmwgPSBiYXNlVXJsO1xuICAgICAgICB0aGlzLnNpZ25pbmdLZXkgPSBzaWduaW5nS2V5O1xuICAgICAgICB0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IHNpZ25pbmdLZXlGYWxsYmFjaztcbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIH1cbiAgICBnZXQgaGFzaGVkS2V5KCkge1xuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfanNfMS5oYXNoU2lnbmluZ0tleSkodGhpcy5zaWduaW5nS2V5KTtcbiAgICB9XG4gICAgZ2V0IGhhc2hlZEZhbGxiYWNrS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluZ0tleUZhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBzdHJpbmdzX2pzXzEuaGFzaFNpZ25pbmdLZXkpKHRoaXMuc2lnbmluZ0tleUZhbGxiYWNrKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBzaWduaW5nIGtleSBpbiBjYXNlIGl0IHdhcyBub3QgaW5zdGFudGlhdGVkIHByZXZpb3VzbHlcbiAgICBzZXRTaWduaW5nS2V5KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLnNpZ25pbmdLZXkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbmluZ0tleSA9IGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTaWduaW5nS2V5RmFsbGJhY2soa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmICF0aGlzLnNpZ25pbmdLZXlGYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5zaWduaW5nS2V5RmFsbGJhY2sgPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VGFyZ2V0VXJsKHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpQmFzZVVybCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwocGF0aCwgdGhpcy5hcGlCYXNlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChwYXRoLCBjb25zdHNfanNfMS5kZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwpO1xuICAgICAgICBpZiAodGhpcy5tb2RlLmlzRGV2ICYmIHRoaXMubW9kZS5pc0luZmVycmVkICYmICF0aGlzLmFwaUJhc2VVcmwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRldkF2YWlsYWJsZSA9IGF3YWl0ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJBdmFpbGFibGUpKGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0LCB0aGlzLmZldGNoKTtcbiAgICAgICAgICAgIGlmIChkZXZBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBhc3luYyBnZXRSdW5TdGVwcyhydW5JZCwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gKDAsIG5ldF9qc18xLmZldGNoV2l0aEF1dGhGYWxsYmFjaykoe1xuICAgICAgICAgICAgYXV0aFRva2VuOiB0aGlzLmhhc2hlZEtleSxcbiAgICAgICAgICAgIGF1dGhUb2tlbkZhbGxiYWNrOiB0aGlzLmhhc2hlZEZhbGxiYWNrS2V5LFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICB1cmw6IGF3YWl0IHRoaXMuZ2V0VGFyZ2V0VXJsKGAvdjAvcnVucy8ke3J1bklkfS9hY3Rpb25zYCksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3Aub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEub2spKHNjaGVtYV9qc18xLnN0ZXBzU2NoZW1hc1t2ZXJzaW9uXS5wYXJzZShkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKShzY2hlbWFfanNfMS5lcnJvclNjaGVtYS5wYXJzZShkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yLCBcIlVua25vd24gZXJyb3IgcmV0cmlldmluZyBzdGVwIGRhdGFcIiksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1bkJhdGNoKHJ1bklkKSB7XG4gICAgICAgIHJldHVybiAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHVybDogYXdhaXQgdGhpcy5nZXRUYXJnZXRVcmwoYC92MC9ydW5zLyR7cnVuSWR9L2JhdGNoYCksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3Aub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEub2spKHNjaGVtYV9qc18xLmJhdGNoU2NoZW1hLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHNjaGVtYV9qc18xLmVycm9yU2NoZW1hLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yc19qc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IsIFwiVW5rbm93biBlcnJvciByZXRyaWV2aW5nIGV2ZW50IGJhdGNoXCIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwdWJsaXNoKHB1Ymxpc2hPcHRpb25zLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRhdGEpIHtcbiAgICAgICAgLy8gdG9kbyBpdCBtYXkgbm90IGJlIGEgXCJ0ZXh0L3N0cmVhbVwiXG4gICAgICAgIGNvbnN0IGlzU3RyZWFtID0gZGF0YSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFRhcmdldFVybChcIi92MS9yZWFsdGltZS9wdWJsaXNoXCIpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImNoYW5uZWxcIiwgcHVibGlzaE9wdGlvbnMuY2hhbm5lbCB8fCBcIlwiKTtcbiAgICAgICAgaWYgKHB1Ymxpc2hPcHRpb25zLnJ1bklkKSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInJ1bl9pZFwiLCBwdWJsaXNoT3B0aW9ucy5ydW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgcHVibGlzaE9wdGlvbnMudG9waWNzLmZvckVhY2goKHRvcGljKSA9PiB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInRvcGljXCIsIHRvcGljKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IFwiUE9TVFwiLCBib2R5OiBpc1N0cmVhbVxuICAgICAgICAgICAgICAgICAgICA/IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGRhdGEpLCBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGlzU3RyZWFtID8gXCJ0ZXh0L3N0cmVhbVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSB9LCAoaXNTdHJlYW0gPyB7IGR1cGxleDogXCJoYWxmXCIgfSA6IHt9KSksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQ6ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykodW5kZWZpbmVkKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yc19qc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IsIFwiVW5rbm93biBlcnJvciBwdWJsaXNoaW5nIGV2ZW50XCIpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzZW5kU2lnbmFsKHNpZ25hbE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRUYXJnZXRVcmwoXCIvdjEvc2lnbmFsc1wiKTtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsT3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICBkYXRhOiBzaWduYWxPcHRpb25zLmRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgLy8gQSA0MDQgaXMgdmFsaWQgaWYgdGhlIHNpZ25hbCB3YXMgbm90IGZvdW5kLlxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykoe1xuICAgICAgICAgICAgICAgICAgICBydW5JZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2F2ZSBhIGNsb25lIG9mIHRoZSByZXNwb25zZSB3ZSBjYW4gdXNlIHRvIGdldCB0aGUgdGV4dCBvZiBpZiB3ZSBmYWlsXG4gICAgICAgICAgICAvLyB0byBwYXJzZSB0aGUgSlNPTi5cbiAgICAgICAgICAgIGNvbnN0IHJlc0Nsb25lID0gcmVzLmNsb25lKCk7XG4gICAgICAgICAgICAvLyBKU09OIVxuICAgICAgICAgICAgbGV0IGpzb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzLmpzb24oKSBmYWlsZWQgc28gbm90IGEgdmFsaWQgSlNPTiByZXNwb25zZVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gc2VuZCBzaWduYWw6ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2F3YWl0IHJlc0Nsb25lLnRleHQoKX1gLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgMnh4LCBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoc2NoZW1hX2pzXzEuZXJyb3JTY2hlbWEucGFyc2UoanNvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NoZW1hIHBhcnNlIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBzZW5kIHNpZ25hbDogJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAtICR7YXdhaXQgcmVzLnRleHQoKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgMnh4LCB3ZSBzaG91bGQgaGF2ZSBhIHJ1bl9pZC5cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzID0gc2VuZFNpZ25hbFN1Y2Nlc3NSZXNwb25zZVNjaGVtYS5zYWZlUGFyc2UoanNvbik7XG4gICAgICAgICAgICBpZiAoIXBhcnNlUmVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgU3VjY2Vzc2Z1bGx5IHNlbnQgc2lnbmFsLCBidXQgcmVzcG9uc2UgcGFyc2luZyBmYWlsZWQ6ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2F3YWl0IHJlc0Nsb25lLnRleHQoKX1gLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEub2spKHtcbiAgICAgICAgICAgICAgICBydW5JZDogcGFyc2VSZXMuZGF0YS5kYXRhLnJ1bl9pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gQ2F0Y2gtYWxsIGlmIHZhcmlvdXMgdGhpbmdzIGdvIHdyb25nXG4gICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yLCBcIlVua25vd24gZXJyb3Igc2VuZGluZyBzaWduYWxcIiksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN1YnNjcmlwdGlvblRva2VuKGNoYW5uZWwsIHRvcGljcykge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFRhcmdldFVybChcIi92MS9yZWFsdGltZS90b2tlblwiKTtcbiAgICAgICAgY29uc3QgYm9keSA9IHRvcGljcy5tYXAoKHRvcGljKSA9PiAoe1xuICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgIG5hbWU6IHRvcGljLFxuICAgICAgICAgICAga2luZDogXCJydW5cIixcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gKDAsIG5ldF9qc18xLmZldGNoV2l0aEF1dGhGYWxsYmFjaykoe1xuICAgICAgICAgICAgYXV0aFRva2VuOiB0aGlzLmhhc2hlZEtleSxcbiAgICAgICAgICAgIGF1dGhUb2tlbkZhbGxiYWNrOiB0aGlzLmhhc2hlZEZhbGxiYWNrS2V5LFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgc3Vic2NyaXB0aW9uIHRva2VuOiAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9IC0gJHthd2FpdCByZXMudGV4dCgpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWx0aW1lU3Vic2NyaXB0aW9uVG9rZW5TY2hlbWEucGFyc2UoYXdhaXQgcmVzLmpzb24oKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5qd3Q7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKDAsIGVycm9yc19qc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IsIFwiVW5rbm93biBlcnJvciBnZXR0aW5nIHN1YnNjcmlwdGlvbiB0b2tlblwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdEFwaSA9IElubmdlc3RBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/api/api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/api/schema.js":
/*!********************************************!*\
  !*** ./node_modules/inngest/api/schema.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.batchSchema = exports.stepsSchemas = exports.errorSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ../components/execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nexports.errorSchema = zod_1.z.object({\n    error: zod_1.z.string(),\n    status: zod_1.z.number(),\n});\nconst v0StepSchema = zod_1.z\n    .record(zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n    message: \"Values in steps must be defined\",\n}))\n    .optional()\n    .nullable();\nconst v1StepSchema = zod_1.z\n    .record(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"data\").optional().default(\"data\"),\n    data: zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n        message: \"Data in steps must be defined\",\n    }),\n})\n    .strict()\n    .or(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"error\").optional().default(\"error\"),\n    error: types_js_1.jsonErrorSchema,\n})\n    .strict())\n    .or(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"input\").optional().default(\"input\"),\n    input: zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n        message: \"If input is present it must not be `undefined`\",\n    }),\n})\n    .strict())\n    /**\n     * If the result isn't a distcint `data` or `error` object, then it's\n     * likely that the executor has set this directly to a value, for example\n     * in the case of `sleep` or `waitForEvent`.\n     *\n     * In this case, pull the entire value through as data.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    .or(zod_1.z.any().transform((v) => ({ type: \"data\", data: v }))))\n    .default({});\nconst v2StepSchema = v1StepSchema;\nexports.stepsSchemas = {\n    [InngestExecution_js_1.ExecutionVersion.V0]: v0StepSchema,\n    [InngestExecution_js_1.ExecutionVersion.V1]: v1StepSchema,\n    [InngestExecution_js_1.ExecutionVersion.V2]: v2StepSchema,\n};\nexports.batchSchema = zod_1.z.array(zod_1.z.record(zod_1.z.any()).transform((v) => v));\n//# sourceMappingURL=schema.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQjtBQUNoRSxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IsOEJBQThCLG1CQUFPLENBQUMsMEhBQTZDO0FBQ25GLG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRSxlQUFlO0FBQ2Y7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvYXBpL3NjaGVtYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmF0Y2hTY2hlbWEgPSBleHBvcnRzLnN0ZXBzU2NoZW1hcyA9IGV4cG9ydHMuZXJyb3JTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5leHBvcnRzLmVycm9yU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGVycm9yOiB6b2RfMS56LnN0cmluZygpLFxuICAgIHN0YXR1czogem9kXzEuei5udW1iZXIoKSxcbn0pO1xuY29uc3QgdjBTdGVwU2NoZW1hID0gem9kXzEuelxuICAgIC5yZWNvcmQoem9kXzEuei5hbnkoKS5yZWZpbmUoKHYpID0+IHR5cGVvZiB2ICE9PSBcInVuZGVmaW5lZFwiLCB7XG4gICAgbWVzc2FnZTogXCJWYWx1ZXMgaW4gc3RlcHMgbXVzdCBiZSBkZWZpbmVkXCIsXG59KSlcbiAgICAub3B0aW9uYWwoKVxuICAgIC5udWxsYWJsZSgpO1xuY29uc3QgdjFTdGVwU2NoZW1hID0gem9kXzEuelxuICAgIC5yZWNvcmQoem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbChcImRhdGFcIikub3B0aW9uYWwoKS5kZWZhdWx0KFwiZGF0YVwiKSxcbiAgICBkYXRhOiB6b2RfMS56LmFueSgpLnJlZmluZSgodikgPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCIsIHtcbiAgICAgICAgbWVzc2FnZTogXCJEYXRhIGluIHN0ZXBzIG11c3QgYmUgZGVmaW5lZFwiLFxuICAgIH0pLFxufSlcbiAgICAuc3RyaWN0KClcbiAgICAub3Ioem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHR5cGU6IHpvZF8xLnoubGl0ZXJhbChcImVycm9yXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcImVycm9yXCIpLFxuICAgIGVycm9yOiB0eXBlc19qc18xLmpzb25FcnJvclNjaGVtYSxcbn0pXG4gICAgLnN0cmljdCgpKVxuICAgIC5vcih6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKFwiaW5wdXRcIikub3B0aW9uYWwoKS5kZWZhdWx0KFwiaW5wdXRcIiksXG4gICAgaW5wdXQ6IHpvZF8xLnouYW55KCkucmVmaW5lKCh2KSA9PiB0eXBlb2YgdiAhPT0gXCJ1bmRlZmluZWRcIiwge1xuICAgICAgICBtZXNzYWdlOiBcIklmIGlucHV0IGlzIHByZXNlbnQgaXQgbXVzdCBub3QgYmUgYHVuZGVmaW5lZGBcIixcbiAgICB9KSxcbn0pXG4gICAgLnN0cmljdCgpKVxuICAgIC8qKlxuICAgICAqIElmIHRoZSByZXN1bHQgaXNuJ3QgYSBkaXN0Y2ludCBgZGF0YWAgb3IgYGVycm9yYCBvYmplY3QsIHRoZW4gaXQnc1xuICAgICAqIGxpa2VseSB0aGF0IHRoZSBleGVjdXRvciBoYXMgc2V0IHRoaXMgZGlyZWN0bHkgdG8gYSB2YWx1ZSwgZm9yIGV4YW1wbGVcbiAgICAgKiBpbiB0aGUgY2FzZSBvZiBgc2xlZXBgIG9yIGB3YWl0Rm9yRXZlbnRgLlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCBwdWxsIHRoZSBlbnRpcmUgdmFsdWUgdGhyb3VnaCBhcyBkYXRhLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAub3Ioem9kXzEuei5hbnkoKS50cmFuc2Zvcm0oKHYpID0+ICh7IHR5cGU6IFwiZGF0YVwiLCBkYXRhOiB2IH0pKSkpXG4gICAgLmRlZmF1bHQoe30pO1xuY29uc3QgdjJTdGVwU2NoZW1hID0gdjFTdGVwU2NoZW1hO1xuZXhwb3J0cy5zdGVwc1NjaGVtYXMgPSB7XG4gICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYwXTogdjBTdGVwU2NoZW1hLFxuICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMV06IHYxU3RlcFNjaGVtYSxcbiAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjJdOiB2MlN0ZXBTY2hlbWEsXG59O1xuZXhwb3J0cy5iYXRjaFNjaGVtYSA9IHpvZF8xLnouYXJyYXkoem9kXzEuei5yZWNvcmQoem9kXzEuei5hbnkoKSkudHJhbnNmb3JtKCh2KSA9PiB2KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlbWEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/api/schema.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/EventSchemas.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/EventSchemas.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventSchemas = void 0;\n/**\n * Provide an `EventSchemas` class to type events, providing type safety when\n * sending events and running functions via Inngest.\n *\n * You can provide generated Inngest types, custom types, types using Zod, or\n * a combination of the above. See {@link EventSchemas} for more information.\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromZod({\n *     \"app/user.created\": {\n *       data: z.object({\n *         id: z.string(),\n *         name: z.string(),\n *       }),\n *     },\n *   }),\n * });\n * ```\n *\n * @public\n */\nclass EventSchemas {\n    constructor() {\n        this.runtimeSchemas = {};\n    }\n    addRuntimeSchemas(schemas) {\n        this.runtimeSchemas = Object.assign(Object.assign({}, this.runtimeSchemas), schemas);\n    }\n    /**\n     * Use generated Inngest types to type events.\n     */\n    fromGenerated() {\n        return this;\n    }\n    /**\n     * Use a `Record<>` type to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"app/user.created\": {\n     *       data: {\n     *         id: string;\n     *         name: string;\n     *       };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    fromRecord(..._args) {\n        return this;\n    }\n    /**\n     * Use a union type to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * type AccountCreated = {\n     *   name: \"app/account.created\";\n     *   data: { org: string };\n     *   user: { id: string };\n     * };\n     *\n     * type AccountDeleted = {\n     *   name: \"app/account.deleted\";\n     *   data: { org: string };\n     *   user: { id: string };\n     * };\n     *\n     * type Events = AccountCreated | AccountDeleted;\n     *\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromUnion<Events>(),\n     * });\n     * ```\n     */\n    fromUnion() {\n        return this;\n    }\n    /**\n     * Use Zod to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromZod({\n     *     \"app/user.created\": {\n     *       data: z.object({\n     *         id: z.string(),\n     *         name: z.string(),\n     *       }),\n     *     },\n     *   }),\n     * });\n     * ```\n     */\n    fromZod(schemas) {\n        let runtimeSchemas;\n        if (Array.isArray(schemas)) {\n            runtimeSchemas = schemas.reduce((acc, schema) => {\n                const _a = schema.shape, { name: { value: name } } = _a, rest = __rest(_a, [\"name\"]);\n                return Object.assign(Object.assign({}, acc), { [name]: rest });\n            }, {});\n        }\n        else {\n            runtimeSchemas = schemas;\n        }\n        this.addRuntimeSchemas(runtimeSchemas);\n        return this;\n    }\n}\nexports.EventSchemas = EventSchemas;\n//# sourceMappingURL=EventSchemas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0V2ZW50U2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsZ0JBQWdCO0FBQ25FLHFEQUFxRCxVQUFVLGNBQWM7QUFDN0UsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9FdmVudFNjaGVtYXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50U2NoZW1hcyA9IHZvaWQgMDtcbi8qKlxuICogUHJvdmlkZSBhbiBgRXZlbnRTY2hlbWFzYCBjbGFzcyB0byB0eXBlIGV2ZW50cywgcHJvdmlkaW5nIHR5cGUgc2FmZXR5IHdoZW5cbiAqIHNlbmRpbmcgZXZlbnRzIGFuZCBydW5uaW5nIGZ1bmN0aW9ucyB2aWEgSW5uZ2VzdC5cbiAqXG4gKiBZb3UgY2FuIHByb3ZpZGUgZ2VuZXJhdGVkIElubmdlc3QgdHlwZXMsIGN1c3RvbSB0eXBlcywgdHlwZXMgdXNpbmcgWm9kLCBvclxuICogYSBjb21iaW5hdGlvbiBvZiB0aGUgYWJvdmUuIFNlZSB7QGxpbmsgRXZlbnRTY2hlbWFzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBleHBvcnQgY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAqICAgaWQ6IFwibXktYXBwXCIsXG4gKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tWm9kKHtcbiAqICAgICBcImFwcC91c2VyLmNyZWF0ZWRcIjoge1xuICogICAgICAgZGF0YTogei5vYmplY3Qoe1xuICogICAgICAgICBpZDogei5zdHJpbmcoKSxcbiAqICAgICAgICAgbmFtZTogei5zdHJpbmcoKSxcbiAqICAgICAgIH0pLFxuICogICAgIH0sXG4gKiAgIH0pLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEV2ZW50U2NoZW1hcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucnVudGltZVNjaGVtYXMgPSB7fTtcbiAgICB9XG4gICAgYWRkUnVudGltZVNjaGVtYXMoc2NoZW1hcykge1xuICAgICAgICB0aGlzLnJ1bnRpbWVTY2hlbWFzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJ1bnRpbWVTY2hlbWFzKSwgc2NoZW1hcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBnZW5lcmF0ZWQgSW5uZ2VzdCB0eXBlcyB0byB0eXBlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBmcm9tR2VuZXJhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIGEgYFJlY29yZDw+YCB0eXBlIHRvIHR5cGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogZXhwb3J0IGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gICAgICogICBpZDogXCJteS1hcHBcIixcbiAgICAgKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tUmVjb3JkPHtcbiAgICAgKiAgICAgXCJhcHAvdXNlci5jcmVhdGVkXCI6IHtcbiAgICAgKiAgICAgICBkYXRhOiB7XG4gICAgICogICAgICAgICBpZDogc3RyaW5nO1xuICAgICAqICAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAqICAgICAgIH07XG4gICAgICogICAgIH07XG4gICAgICogICB9PigpLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZyb21SZWNvcmQoLi4uX2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBhIHVuaW9uIHR5cGUgdG8gdHlwZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB0eXBlIEFjY291bnRDcmVhdGVkID0ge1xuICAgICAqICAgbmFtZTogXCJhcHAvYWNjb3VudC5jcmVhdGVkXCI7XG4gICAgICogICBkYXRhOiB7IG9yZzogc3RyaW5nIH07XG4gICAgICogICB1c2VyOiB7IGlkOiBzdHJpbmcgfTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdHlwZSBBY2NvdW50RGVsZXRlZCA9IHtcbiAgICAgKiAgIG5hbWU6IFwiYXBwL2FjY291bnQuZGVsZXRlZFwiO1xuICAgICAqICAgZGF0YTogeyBvcmc6IHN0cmluZyB9O1xuICAgICAqICAgdXNlcjogeyBpZDogc3RyaW5nIH07XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHR5cGUgRXZlbnRzID0gQWNjb3VudENyZWF0ZWQgfCBBY2NvdW50RGVsZXRlZDtcbiAgICAgKlxuICAgICAqIGV4cG9ydCBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3Qoe1xuICAgICAqICAgaWQ6IFwibXktYXBwXCIsXG4gICAgICogICBzY2hlbWFzOiBuZXcgRXZlbnRTY2hlbWFzKCkuZnJvbVVuaW9uPEV2ZW50cz4oKSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmcm9tVW5pb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgWm9kIHRvIHR5cGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogZXhwb3J0IGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gICAgICogICBpZDogXCJteS1hcHBcIixcbiAgICAgKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tWm9kKHtcbiAgICAgKiAgICAgXCJhcHAvdXNlci5jcmVhdGVkXCI6IHtcbiAgICAgKiAgICAgICBkYXRhOiB6Lm9iamVjdCh7XG4gICAgICogICAgICAgICBpZDogei5zdHJpbmcoKSxcbiAgICAgKiAgICAgICAgIG5hbWU6IHouc3RyaW5nKCksXG4gICAgICogICAgICAgfSksXG4gICAgICogICAgIH0sXG4gICAgICogICB9KSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmcm9tWm9kKHNjaGVtYXMpIHtcbiAgICAgICAgbGV0IHJ1bnRpbWVTY2hlbWFzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFzKSkge1xuICAgICAgICAgICAgcnVudGltZVNjaGVtYXMgPSBzY2hlbWFzLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfYSA9IHNjaGVtYS5zaGFwZSwgeyBuYW1lOiB7IHZhbHVlOiBuYW1lIH0gfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJuYW1lXCJdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtuYW1lXTogcmVzdCB9KTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bnRpbWVTY2hlbWFzID0gc2NoZW1hcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFJ1bnRpbWVTY2hlbWFzKHJ1bnRpbWVTY2hlbWFzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5FdmVudFNjaGVtYXMgPSBFdmVudFNjaGVtYXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFNjaGVtYXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/EventSchemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/Fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/components/Fetch.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetch = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/inngest/node_modules/debug/src/index.js\"));\nconst als_js_1 = __webpack_require__(/*! ./execution/als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ./InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst globalFetch = globalThis.fetch;\nconst debug = (0, debug_1.default)(\"inngest:fetch\");\nconst createFetchShim = () => {\n    // eslint-disable-next-line prefer-const\n    let stepFetch;\n    const fetch = async (input, init) => {\n        const ctx = await (0, als_js_1.getAsyncCtx)();\n        if (!ctx) {\n            // Not in a function run\n            if (!stepFetch.fallback) {\n                // TODO Tell the user how to solve\n                throw new Error(\"step.fetch() called outside of a function and had no fallback set\");\n            }\n            debug(\"step.fetch() called outside of a function; falling back to global fetch\");\n            return stepFetch.fallback(input, init);\n        }\n        // In a function run\n        if (ctx.executingStep) {\n            // Inside a step\n            if (!stepFetch.fallback) {\n                // TODO Tell the user how to solve\n                throw new Error(`step.fetch() called inside step \"${ctx.executingStep.id}\" and had no fallback set`);\n            }\n            debug(`step.fetch() called inside step \"${ctx.executingStep.id}\"; falling back to global fetch`);\n            return stepFetch.fallback(input, init);\n        }\n        const targetUrl = new URL(input instanceof Request ? input.url : input.toString());\n        debug(\"step.fetch() shimming request to\", targetUrl.hostname);\n        // Purposefully do not try/cacth this; if it throws then we treat that as a\n        // regular `fetch()` throw, which also would not return a `Response`.\n        const jsonRes = await ctx.ctx.step[InngestStepTools_js_1.gatewaySymbol](`step.fetch: ${targetUrl.hostname}`, input, init);\n        return new Response(jsonRes.body, {\n            headers: jsonRes.headers,\n            status: jsonRes.status,\n        });\n    };\n    const optionsRef = {\n        fallback: globalFetch,\n    };\n    const extras = Object.assign({ config: (options) => {\n            Object.assign(optionsRef, options);\n            Object.assign(stepFetch, optionsRef);\n            return stepFetch;\n        } }, optionsRef);\n    stepFetch = Object.assign(fetch, extras);\n    return stepFetch;\n};\n/**\n * `fetch` is a Fetch API-compatible function that can be used to make any HTTP\n * code durable if it's called within an Inngest function.\n *\n * It will gracefully fall back to the global `fetch` if called outside of this\n * context, and a custom fallback can be set using the `config` method.\n *\n * @example Basic usage\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({ fetch });\n * ```\n *\n * @example Setting a custom fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: myCustomFetch }),\n * });\n * ```\n *\n * @example Do not allow fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: undefined }),\n * });\n * ```\n */\nexports.fetch = createFetchShim();\n//# sourceMappingURL=Fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0ZldGNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGdDQUFnQyxtQkFBTyxDQUFDLDJFQUFPO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFvQjtBQUM3Qyw4QkFBOEIsbUJBQU8sQ0FBQywwRkFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UscUJBQXFCO0FBQ3pGO0FBQ0Esc0RBQXNELHFCQUFxQixHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsK0ZBQStGLG1CQUFtQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RCxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0ZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaCA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGFsc19qc18xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uL2Fscy5qc1wiKTtcbmNvbnN0IElubmdlc3RTdGVwVG9vbHNfanNfMSA9IHJlcXVpcmUoXCIuL0lubmdlc3RTdGVwVG9vbHMuanNcIik7XG5jb25zdCBnbG9iYWxGZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2g7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiaW5uZ2VzdDpmZXRjaFwiKTtcbmNvbnN0IGNyZWF0ZUZldGNoU2hpbSA9ICgpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHN0ZXBGZXRjaDtcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuICAgICAgICBjb25zdCBjdHggPSBhd2FpdCAoMCwgYWxzX2pzXzEuZ2V0QXN5bmNDdHgpKCk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICAvLyBOb3QgaW4gYSBmdW5jdGlvbiBydW5cbiAgICAgICAgICAgIGlmICghc3RlcEZldGNoLmZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBUZWxsIHRoZSB1c2VyIGhvdyB0byBzb2x2ZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0ZXAuZmV0Y2goKSBjYWxsZWQgb3V0c2lkZSBvZiBhIGZ1bmN0aW9uIGFuZCBoYWQgbm8gZmFsbGJhY2sgc2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVidWcoXCJzdGVwLmZldGNoKCkgY2FsbGVkIG91dHNpZGUgb2YgYSBmdW5jdGlvbjsgZmFsbGluZyBiYWNrIHRvIGdsb2JhbCBmZXRjaFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdGVwRmV0Y2guZmFsbGJhY2soaW5wdXQsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGEgZnVuY3Rpb24gcnVuXG4gICAgICAgIGlmIChjdHguZXhlY3V0aW5nU3RlcCkge1xuICAgICAgICAgICAgLy8gSW5zaWRlIGEgc3RlcFxuICAgICAgICAgICAgaWYgKCFzdGVwRmV0Y2guZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFRlbGwgdGhlIHVzZXIgaG93IHRvIHNvbHZlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdGVwLmZldGNoKCkgY2FsbGVkIGluc2lkZSBzdGVwIFwiJHtjdHguZXhlY3V0aW5nU3RlcC5pZH1cIiBhbmQgaGFkIG5vIGZhbGxiYWNrIHNldGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVidWcoYHN0ZXAuZmV0Y2goKSBjYWxsZWQgaW5zaWRlIHN0ZXAgXCIke2N0eC5leGVjdXRpbmdTdGVwLmlkfVwiOyBmYWxsaW5nIGJhY2sgdG8gZ2xvYmFsIGZldGNoYCk7XG4gICAgICAgICAgICByZXR1cm4gc3RlcEZldGNoLmZhbGxiYWNrKGlucHV0LCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRVcmwgPSBuZXcgVVJMKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0LnVybCA6IGlucHV0LnRvU3RyaW5nKCkpO1xuICAgICAgICBkZWJ1ZyhcInN0ZXAuZmV0Y2goKSBzaGltbWluZyByZXF1ZXN0IHRvXCIsIHRhcmdldFVybC5ob3N0bmFtZSk7XG4gICAgICAgIC8vIFB1cnBvc2VmdWxseSBkbyBub3QgdHJ5L2NhY3RoIHRoaXM7IGlmIGl0IHRocm93cyB0aGVuIHdlIHRyZWF0IHRoYXQgYXMgYVxuICAgICAgICAvLyByZWd1bGFyIGBmZXRjaCgpYCB0aHJvdywgd2hpY2ggYWxzbyB3b3VsZCBub3QgcmV0dXJuIGEgYFJlc3BvbnNlYC5cbiAgICAgICAgY29uc3QganNvblJlcyA9IGF3YWl0IGN0eC5jdHguc3RlcFtJbm5nZXN0U3RlcFRvb2xzX2pzXzEuZ2F0ZXdheVN5bWJvbF0oYHN0ZXAuZmV0Y2g6ICR7dGFyZ2V0VXJsLmhvc3RuYW1lfWAsIGlucHV0LCBpbml0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShqc29uUmVzLmJvZHksIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IGpzb25SZXMuaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czoganNvblJlcy5zdGF0dXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb3B0aW9uc1JlZiA9IHtcbiAgICAgICAgZmFsbGJhY2s6IGdsb2JhbEZldGNoLFxuICAgIH07XG4gICAgY29uc3QgZXh0cmFzID0gT2JqZWN0LmFzc2lnbih7IGNvbmZpZzogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc1JlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0ZXBGZXRjaCwgb3B0aW9uc1JlZik7XG4gICAgICAgICAgICByZXR1cm4gc3RlcEZldGNoO1xuICAgICAgICB9IH0sIG9wdGlvbnNSZWYpO1xuICAgIHN0ZXBGZXRjaCA9IE9iamVjdC5hc3NpZ24oZmV0Y2gsIGV4dHJhcyk7XG4gICAgcmV0dXJuIHN0ZXBGZXRjaDtcbn07XG4vKipcbiAqIGBmZXRjaGAgaXMgYSBGZXRjaCBBUEktY29tcGF0aWJsZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYW55IEhUVFBcbiAqIGNvZGUgZHVyYWJsZSBpZiBpdCdzIGNhbGxlZCB3aXRoaW4gYW4gSW5uZ2VzdCBmdW5jdGlvbi5cbiAqXG4gKiBJdCB3aWxsIGdyYWNlZnVsbHkgZmFsbCBiYWNrIHRvIHRoZSBnbG9iYWwgYGZldGNoYCBpZiBjYWxsZWQgb3V0c2lkZSBvZiB0aGlzXG4gKiBjb250ZXh0LCBhbmQgYSBjdXN0b20gZmFsbGJhY2sgY2FuIGJlIHNldCB1c2luZyB0aGUgYGNvbmZpZ2AgbWV0aG9kLlxuICpcbiAqIEBleGFtcGxlIEJhc2ljIHVzYWdlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwiaW5uZ2VzdFwiO1xuICpcbiAqIGNvbnN0IGFwaSA9IG5ldyBNeVByb2R1Y3RBcGkoeyBmZXRjaCB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIFNldHRpbmcgYSBjdXN0b20gZmFsbGJhY2tcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJpbm5nZXN0XCI7XG4gKlxuICogY29uc3QgYXBpID0gbmV3IE15UHJvZHVjdEFwaSh7XG4gKiAgICAgICAgICAgIGZldGNoOiBmZXRjaC5jb25maWcoeyBmYWxsYmFjazogbXlDdXN0b21GZXRjaCB9KSxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGUgRG8gbm90IGFsbG93IGZhbGxiYWNrXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwiaW5uZ2VzdFwiO1xuICpcbiAqIGNvbnN0IGFwaSA9IG5ldyBNeVByb2R1Y3RBcGkoe1xuICogICAgICAgICAgICBmZXRjaDogZmV0Y2guY29uZmlnKHsgZmFsbGJhY2s6IHVuZGVmaW5lZCB9KSxcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuZmV0Y2ggPSBjcmVhdGVGZXRjaFNoaW0oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZldGNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/Fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/Inngest.js":
/*!****************************************************!*\
  !*** ./node_modules/inngest/components/Inngest.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.builtInMiddleware = exports.Inngest = void 0;\nconst api_js_1 = __webpack_require__(/*! ../api/api.js */ \"(rsc)/./node_modules/inngest/api/api.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst crypto_js_1 = __webpack_require__(/*! ../helpers/crypto.js */ \"(rsc)/./node_modules/inngest/helpers/crypto.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst env_js_1 = __webpack_require__(/*! ../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst promises_js_1 = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst logger_js_1 = __webpack_require__(/*! ../middleware/logger.js */ \"(rsc)/./node_modules/inngest/middleware/logger.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst InngestFunction_js_1 = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ./InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ id: \"my-app\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nclass Inngest {\n    get apiBaseUrl() {\n        return this._apiBaseUrl;\n    }\n    get eventBaseUrl() {\n        return this._eventBaseUrl;\n    }\n    get env() {\n        var _a;\n        return (_a = this.headers[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;\n    }\n    get appVersion() {\n        return this._appVersion;\n    }\n    /**\n     * A client used to interact with the Inngest API by sending or reacting to\n     * events.\n     *\n     * To provide event typing, see {@link EventSchemas}.\n     *\n     * ```ts\n     * const inngest = new Inngest({ name: \"My App\" });\n     *\n     * // or to provide event typing too\n     * const inngest = new Inngest({\n     *   name: \"My App\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"app/user.created\": {\n     *       data: { userId: string };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    constructor(options) {\n        /**\n         * Inngest event key, used to send events to Inngest Cloud.\n         */\n        this.eventKey = \"\";\n        /**\n         * The absolute URL of the Inngest Cloud API.\n         */\n        this.sendEventUrl = new URL(`e/${this.eventKey}`, consts_js_1.defaultInngestEventBaseUrl);\n        this.localFns = [];\n        this.createFunction = (rawOptions, rawTrigger, handler) => {\n            const fn = this._createFunction(rawOptions, rawTrigger, handler);\n            this.localFns.push(fn);\n            return fn;\n        };\n        this._createFunction = (rawOptions, rawTrigger, handler) => {\n            const options = this.sanitizeOptions(rawOptions);\n            const triggers = this.sanitizeTriggers(rawTrigger);\n            return new InngestFunction_js_1.InngestFunction(this, Object.assign(Object.assign({}, options), { triggers }), handler);\n        };\n        this.options = options;\n        const { id, fetch, logger = new logger_js_1.DefaultLogger(), middleware, isDev, schemas, appVersion, } = this.options;\n        if (!id) {\n            // TODO PrettyError\n            throw new Error(\"An `id` must be passed to create an Inngest instance.\");\n        }\n        this.id = id;\n        this._mode = (0, env_js_1.getMode)({\n            explicitMode: typeof isDev === \"boolean\" ? (isDev ? \"dev\" : \"cloud\") : undefined,\n        });\n        this.fetch = (0, env_js_1.getFetch)(fetch);\n        this.inngestApi = new api_js_1.InngestApi({\n            baseUrl: this.apiBaseUrl,\n            signingKey: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKey) || \"\",\n            signingKeyFallback: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKeyFallback),\n            fetch: this.fetch,\n            mode: this.mode,\n        });\n        this.schemas = schemas;\n        this.loadModeEnvVars();\n        this.logger = logger;\n        this.middleware = this.initializeMiddleware([\n            ...exports.builtInMiddleware,\n            ...(middleware || []),\n        ]);\n        this._appVersion = appVersion;\n    }\n    /**\n     * Returns a `Promise` that resolves when the app is ready and all middleware\n     * has been initialized.\n     */\n    get ready() {\n        return this.middleware.then(() => { });\n    }\n    /**\n     * Set the environment variables for this client. This is useful if you are\n     * passed environment variables at runtime instead of as globals and need to\n     * update the client with those values as requests come in.\n     */\n    setEnvVars(env = (0, env_js_1.allProcessEnv)()) {\n        this.mode = (0, env_js_1.getMode)({ env, client: this });\n        return this;\n    }\n    loadModeEnvVars() {\n        this._apiBaseUrl =\n            this.options.baseUrl ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestApiBaseUrl] ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestBaseUrl] ||\n                this.mode.getExplicitUrl(consts_js_1.defaultInngestApiBaseUrl);\n        this._eventBaseUrl =\n            this.options.baseUrl ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestEventApiBaseUrl] ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestBaseUrl] ||\n                this.mode.getExplicitUrl(consts_js_1.defaultInngestEventBaseUrl);\n        this.setEventKey(this.options.eventKey || this.mode[\"env\"][consts_js_1.envKeys.InngestEventKey] || \"\");\n        this.headers = (0, env_js_1.inngestHeaders)({\n            inngestEnv: this.options.env,\n            env: this.mode[\"env\"],\n        });\n        this.inngestApi[\"mode\"] = this.mode;\n        this.inngestApi[\"apiBaseUrl\"] = this._apiBaseUrl;\n    }\n    /**\n     * Initialize all passed middleware, running the `register` function on each\n     * in sequence and returning the requested hook registrations.\n     */\n    async initializeMiddleware(middleware = [], opts) {\n        var _a;\n        /**\n         * Wait for the prefix stack to run first; do not trigger ours before this\n         * is complete.\n         */\n        const prefix = await ((_a = opts === null || opts === void 0 ? void 0 : opts.prefixStack) !== null && _a !== void 0 ? _a : []);\n        const stack = middleware.reduce(async (acc, m) => {\n            // Be explicit about waiting for the previous middleware to finish\n            const prev = await acc;\n            const next = await m.init(Object.assign({ client: this }, opts === null || opts === void 0 ? void 0 : opts.registerInput));\n            return [...prev, next];\n        }, Promise.resolve([]));\n        return [...prefix, ...(await stack)];\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(m) {\n        this._mode = m;\n        this.loadModeEnvVars();\n    }\n    /**\n     * Given a response from Inngest, relay the error to the caller.\n     */\n    async getResponseError(response, rawBody, foundErr = \"Unknown error\") {\n        let errorMessage = foundErr;\n        if (errorMessage === \"Unknown error\") {\n            switch (response.status) {\n                case 401:\n                    errorMessage = \"Event key Not Found\";\n                    break;\n                case 400:\n                    errorMessage = \"Cannot process event payload\";\n                    break;\n                case 403:\n                    errorMessage = \"Forbidden\";\n                    break;\n                case 404:\n                    errorMessage = \"Event key not found\";\n                    break;\n                case 406:\n                    errorMessage = `${JSON.stringify(await rawBody)}`;\n                    break;\n                case 409:\n                case 412:\n                    errorMessage = \"Event transformation failed\";\n                    break;\n                case 413:\n                    errorMessage = \"Event payload too large\";\n                    break;\n                case 500:\n                    errorMessage = \"Internal server error\";\n                    break;\n                default:\n                    try {\n                        errorMessage = await response.text();\n                    }\n                    catch (err) {\n                        errorMessage = `${JSON.stringify(await rawBody)}`;\n                    }\n                    break;\n            }\n        }\n        return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);\n    }\n    /**\n     * Set the event key for this instance of Inngest. This is useful if for some\n     * reason the key is not available at time of instantiation or present in the\n     * `INNGEST_EVENT_KEY` environment variable.\n     */\n    setEventKey(\n    /**\n     * Inngest event key, used to send events to Inngest Cloud. Use this is your\n     * key is for some reason not available at time of instantiation or present\n     * in the `INNGEST_EVENT_KEY` environment variable.\n     */\n    eventKey) {\n        this.eventKey = eventKey || consts_js_1.dummyEventKey;\n        this.sendEventUrl = new URL(`e/${this.eventKey}`, this.eventBaseUrl || consts_js_1.defaultInngestEventBaseUrl);\n    }\n    eventKeySet() {\n        return Boolean(this.eventKey) && this.eventKey !== consts_js_1.dummyEventKey;\n    }\n    /**\n     * EXPERIMENTAL: This API is not yet stable and may change in the future\n     * without a major version bump.\n     *\n     * Send a Signal to Inngest.\n     */\n    async sendSignal({ signal, data, env, }) {\n        const headers = Object.assign({}, (env ? { [consts_js_1.headerKeys.Environment]: env } : {}));\n        return this._sendSignal({ signal, data, headers });\n    }\n    async _sendSignal({ signal, data, headers, }) {\n        var _a;\n        const res = await this.inngestApi.sendSignal({ signal, data }, Object.assign(Object.assign({}, this.headers), headers));\n        if (res.ok) {\n            return res.value;\n        }\n        throw new Error(`Failed to send signal: ${((_a = res.error) === null || _a === void 0 ? void 0 : _a.error) || \"Unknown error\"}`);\n    }\n    /**\n     * Send one or many events to Inngest. Takes an entire payload (including\n     * name) as each input.\n     *\n     * ```ts\n     * await inngest.send({ name: \"app/user.created\", data: { id: 123 } });\n     * ```\n     *\n     * Returns a promise that will resolve if the event(s) were sent successfully,\n     * else throws with an error explaining what went wrong.\n     *\n     * If you wish to send an event with custom types (i.e. one that hasn't been\n     * generated), make sure to add it when creating your Inngest instance, like\n     * so:\n     *\n     * ```ts\n     * const inngest = new Inngest({\n     *   name: \"My App\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"my/event\": {\n     *       name: \"my/event\";\n     *       data: { bar: string };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    async send(payload, options) {\n        const headers = Object.assign({}, ((options === null || options === void 0 ? void 0 : options.env) ? { [consts_js_1.headerKeys.Environment]: options.env } : {}));\n        return this._send({ payload, headers });\n    }\n    /**\n     * Internal method for sending an event, used to allow Inngest internals to\n     * further customize the request sent to an Inngest Server.\n     */\n    async _send({ payload, headers, }) {\n        var _a;\n        const nowMillis = new Date().getTime();\n        let maxAttempts = 5;\n        // Attempt to set the event ID seed header. If it fails then disable retries\n        // (but we still want to send the event).\n        try {\n            const entropy = (0, crypto_js_1.createEntropy)(10);\n            const entropyBase64 = Buffer.from(entropy).toString(\"base64\");\n            headers = Object.assign(Object.assign({}, headers), { [consts_js_1.headerKeys.EventIdSeed]: `${nowMillis},${entropyBase64}` });\n        }\n        catch (err) {\n            let message = \"Event-sending retries disabled\";\n            if (err instanceof Error) {\n                message += `: ${err.message}`;\n            }\n            console.debug(message);\n            // Disable retries.\n            maxAttempts = 1;\n        }\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.middleware, \"onSendEvent\", undefined, {\n            transformInput: (prev, output) => {\n                return Object.assign(Object.assign({}, prev), output);\n            },\n            transformOutput(prev, output) {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                };\n            },\n        });\n        let payloads = Array.isArray(payload)\n            ? payload\n            : payload\n                ? [payload]\n                : [];\n        const inputChanges = await ((_a = hooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(hooks, {\n            payloads: [...payloads],\n        }));\n        if (inputChanges === null || inputChanges === void 0 ? void 0 : inputChanges.payloads) {\n            payloads = [...inputChanges.payloads];\n        }\n        // Ensure that we always add \"ts\" and \"data\" fields to events. \"ts\" is auto-\n        // filled by the event server so is safe, and adding here fixes Next.js\n        // server action cache issues.\n        payloads = payloads.map((p) => {\n            return Object.assign(Object.assign({}, p), { \n                // Always generate an idempotency ID for an event for retries\n                id: p.id, ts: p.ts || nowMillis, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                data: p.data || {} });\n        });\n        const applyHookToOutput = async (arg) => {\n            var _a;\n            const hookOutput = await ((_a = hooks.transformOutput) === null || _a === void 0 ? void 0 : _a.call(hooks, arg));\n            return Object.assign(Object.assign({}, arg.result), hookOutput === null || hookOutput === void 0 ? void 0 : hookOutput.result);\n        };\n        /**\n         * It can be valid for a user to send an empty list of events; if this\n         * happens, show a warning that this may not be intended, but don't throw.\n         */\n        if (!payloads.length) {\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"`inngest.send()` called with no events\",\n                reassurance: \"This is not an error, but you may not have intended to do this.\",\n                consequences: \"The returned promise will resolve, but no events have been sent to Inngest.\",\n                stack: true,\n            }));\n            return await applyHookToOutput({ result: { ids: [] } });\n        }\n        // When sending events, check if the dev server is available.  If so, use the\n        // dev server.\n        let url = this.sendEventUrl.href;\n        /**\n         * If in prod mode and key is not present, fail now.\n         */\n        if (this.mode.isCloud && !this.eventKeySet()) {\n            throw new Error((0, errors_js_1.prettyError)({\n                whatHappened: \"Failed to send event\",\n                consequences: \"Your event or events were not sent to Inngest.\",\n                why: \"We couldn't find an event key to use to send events to Inngest.\",\n                toFixNow: errors_js_1.fixEventKeyMissingSteps,\n            }));\n        }\n        /**\n         * If dev mode has been inferred, try to hit the dev server first to see if\n         * it exists. If it does, use it, otherwise fall back to whatever server we\n         * have configured.\n         *\n         * `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a\n         * user has set this it means they have already chosen a URL to hit.\n         */\n        if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {\n            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);\n            if (devAvailable) {\n                url = (0, devserver_js_1.devServerUrl)(consts_js_1.defaultDevServerHost, `e/${this.eventKey}`).href;\n            }\n        }\n        const body = await (0, promises_js_1.retryWithBackoff)(async () => {\n            let rawBody;\n            let body;\n            // We don't need to do fallback auth here because this uses event keys and\n            // not signing keys\n            const response = await this.fetch(url, {\n                method: \"POST\",\n                body: (0, strings_js_1.stringify)(payloads),\n                headers: Object.assign(Object.assign({}, this.headers), headers),\n            });\n            try {\n                rawBody = await response.json();\n                body = await types_js_1.sendEventResponseSchema.parseAsync(rawBody);\n            }\n            catch (err) {\n                throw await this.getResponseError(response, rawBody);\n            }\n            if (body.status !== 200 || body.error) {\n                throw await this.getResponseError(response, rawBody, body.error);\n            }\n            return body;\n        }, {\n            maxAttempts,\n            baseDelay: 100,\n        });\n        return await applyHookToOutput({ result: { ids: body.ids } });\n    }\n    get funcs() {\n        return this.localFns;\n    }\n    /**\n     * Runtime-only validation.\n     */\n    sanitizeOptions(options) {\n        if (Object.prototype.hasOwnProperty.call(options, \"fns\")) {\n            // v2 -> v3 migration warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: \\`fns\\` option has been deprecated in v3; use \\`middleware\\` instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n        if (typeof options === \"string\") {\n            // v2 -> v3 runtime migraton warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);\n            return { id: options };\n        }\n        return options;\n    }\n    /**\n     * Runtime-only validation.\n     */\n    sanitizeTriggers(triggers) {\n        if (typeof triggers === \"string\") {\n            // v2 -> v3 migration warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);\n            return [{ event: triggers }];\n        }\n        if (!Array.isArray(triggers)) {\n            return [triggers];\n        }\n        return triggers;\n    }\n}\nexports.Inngest = Inngest;\n/**\n * Default middleware that is included in every client, placed after the user's\n * middleware on the client but before function-level middleware.\n *\n * It is defined here to ensure that comments are included in the generated TS\n * definitions. Without this, we infer the stack of built-in middleware without\n * comments, losing a lot of value.\n *\n * If this is moved, please ensure that using this package in another project\n * can correctly access comments on mutated input and output.\n *\n * This return pattern mimics the output of a `satisfies` suffix; it's used as\n * we support versions of TypeScript prior to the introduction of `satisfies`.\n */\nexports.builtInMiddleware = ((m) => m)([\n    new InngestMiddleware_js_1.InngestMiddleware({\n        name: \"Inngest: Logger\",\n        init({ client }) {\n            return {\n                onFunctionRun(arg) {\n                    const { ctx } = arg;\n                    const metadata = {\n                        runID: ctx.runId,\n                        eventName: ctx.event.name,\n                        functionName: arg.fn.name,\n                    };\n                    let providedLogger = client[\"logger\"];\n                    // create a child logger if the provided logger has child logger implementation\n                    try {\n                        if (\"child\" in providedLogger) {\n                            providedLogger = providedLogger.child(metadata);\n                        }\n                    }\n                    catch (err) {\n                        console.error('failed to create \"childLogger\" with error: ', err);\n                        // no-op\n                    }\n                    const logger = new logger_js_1.ProxyLogger(providedLogger);\n                    return {\n                        transformInput() {\n                            return {\n                                ctx: {\n                                    /**\n                                     * The passed in logger from the user.\n                                     * Defaults to a console logger if not provided.\n                                     */\n                                    logger: logger,\n                                },\n                            };\n                        },\n                        beforeExecution() {\n                            logger.enable();\n                        },\n                        transformOutput({ result: { error } }) {\n                            if (error) {\n                                logger.error(error);\n                            }\n                        },\n                        async beforeResponse() {\n                            await logger.flush();\n                        },\n                    };\n                },\n            };\n        },\n    }),\n]);\n//# sourceMappingURL=Inngest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsZUFBZTtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyw4REFBZTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLGtGQUF5QjtBQUN4RCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHNCQUFzQixtQkFBTyxDQUFDLGdGQUF3QjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBdUI7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQXlCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLDZCQUE2QixtQkFBTyxDQUFDLHdGQUFzQjtBQUMzRCwrQkFBK0IsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGNBQWMsVUFBVTtBQUN4SDtBQUNBO0FBQ0EsZ0JBQWdCLCtGQUErRjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOEJBQThCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhCQUE4QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUIsRUFBRSxhQUFhO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0Msd0NBQXdDLFdBQVcsNENBQTRDLElBQUk7QUFDbkcsa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQSx1REFBdUQsY0FBYyxnQ0FBZ0M7QUFDckc7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9GQUFvRjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDLFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUVBQXVFLG9EQUFvRCxJQUFJO0FBQ3ZLLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjLHlDQUF5QyxVQUFVLEdBQUcsY0FBYyxHQUFHO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZDQUE2QyxVQUFVLFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGNBQWM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCx5Q0FBeUMsVUFBVSxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCLDJEQUEyRDtBQUM5RztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCLG9HQUFvRztBQUN2SixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QixxR0FBcUc7QUFDeEosc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDBDQUEwQyxVQUFVLFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Jbm5nZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsdEluTWlkZGxld2FyZSA9IGV4cG9ydHMuSW5uZ2VzdCA9IHZvaWQgMDtcbmNvbnN0IGFwaV9qc18xID0gcmVxdWlyZShcIi4uL2FwaS9hcGkuanNcIik7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbmNvbnN0IGNyeXB0b19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY3J5cHRvLmpzXCIpO1xuY29uc3QgZGV2c2VydmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9kZXZzZXJ2ZXIuanNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vudi5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZXJyb3JzLmpzXCIpO1xuY29uc3QgcHJvbWlzZXNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3Byb21pc2VzLmpzXCIpO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyaW5ncy5qc1wiKTtcbmNvbnN0IGxvZ2dlcl9qc18xID0gcmVxdWlyZShcIi4uL21pZGRsZXdhcmUvbG9nZ2VyLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbmNvbnN0IElubmdlc3RGdW5jdGlvbl9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdEZ1bmN0aW9uLmpzXCIpO1xuY29uc3QgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMSA9IHJlcXVpcmUoXCIuL0lubmdlc3RNaWRkbGV3YXJlLmpzXCIpO1xuLyoqXG4gKiBBIGNsaWVudCB1c2VkIHRvIGludGVyYWN0IHdpdGggdGhlIElubmdlc3QgQVBJIGJ5IHNlbmRpbmcgb3IgcmVhY3RpbmcgdG9cbiAqIGV2ZW50cy5cbiAqXG4gKiBUbyBwcm92aWRlIGV2ZW50IHR5cGluZywgc2VlIHtAbGluayBFdmVudFNjaGVtYXN9LlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3QoeyBpZDogXCJteS1hcHBcIiB9KTtcbiAqXG4gKiAvLyBvciB0byBwcm92aWRlIGV2ZW50IHR5cGluZyB0b29cbiAqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gKiAgIGlkOiBcIm15LWFwcFwiLFxuICogICBzY2hlbWFzOiBuZXcgRXZlbnRTY2hlbWFzKCkuZnJvbVJlY29yZDx7XG4gKiAgICAgXCJhcHAvdXNlci5jcmVhdGVkXCI6IHtcbiAqICAgICAgIGRhdGE6IHsgdXNlcklkOiBzdHJpbmcgfTtcbiAqICAgICB9O1xuICogICB9PigpLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIElubmdlc3Qge1xuICAgIGdldCBhcGlCYXNlVXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBpQmFzZVVybDtcbiAgICB9XG4gICAgZ2V0IGV2ZW50QmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50QmFzZVVybDtcbiAgICB9XG4gICAgZ2V0IGVudigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5oZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuRW52aXJvbm1lbnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgYXBwVmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcFZlcnNpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY2xpZW50IHVzZWQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgSW5uZ2VzdCBBUEkgYnkgc2VuZGluZyBvciByZWFjdGluZyB0b1xuICAgICAqIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIFRvIHByb3ZpZGUgZXZlbnQgdHlwaW5nLCBzZWUge0BsaW5rIEV2ZW50U2NoZW1hc30uXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7IG5hbWU6IFwiTXkgQXBwXCIgfSk7XG4gICAgICpcbiAgICAgKiAvLyBvciB0byBwcm92aWRlIGV2ZW50IHR5cGluZyB0b29cbiAgICAgKiBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3Qoe1xuICAgICAqICAgbmFtZTogXCJNeSBBcHBcIixcbiAgICAgKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tUmVjb3JkPHtcbiAgICAgKiAgICAgXCJhcHAvdXNlci5jcmVhdGVkXCI6IHtcbiAgICAgKiAgICAgICBkYXRhOiB7IHVzZXJJZDogc3RyaW5nIH07XG4gICAgICogICAgIH07XG4gICAgICogICB9PigpLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElubmdlc3QgZXZlbnQga2V5LCB1c2VkIHRvIHNlbmQgZXZlbnRzIHRvIElubmdlc3QgQ2xvdWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50S2V5ID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhYnNvbHV0ZSBVUkwgb2YgdGhlIElubmdlc3QgQ2xvdWQgQVBJLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kRXZlbnRVcmwgPSBuZXcgVVJMKGBlLyR7dGhpcy5ldmVudEtleX1gLCBjb25zdHNfanNfMS5kZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCk7XG4gICAgICAgIHRoaXMubG9jYWxGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jcmVhdGVGdW5jdGlvbiA9IChyYXdPcHRpb25zLCByYXdUcmlnZ2VyLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHRoaXMuX2NyZWF0ZUZ1bmN0aW9uKHJhd09wdGlvbnMsIHJhd1RyaWdnZXIsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5sb2NhbEZucy5wdXNoKGZuKTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY3JlYXRlRnVuY3Rpb24gPSAocmF3T3B0aW9ucywgcmF3VHJpZ2dlciwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuc2FuaXRpemVPcHRpb25zKHJhd09wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLnNhbml0aXplVHJpZ2dlcnMocmF3VHJpZ2dlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElubmdlc3RGdW5jdGlvbl9qc18xLklubmdlc3RGdW5jdGlvbih0aGlzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHRyaWdnZXJzIH0pLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBpZCwgZmV0Y2gsIGxvZ2dlciA9IG5ldyBsb2dnZXJfanNfMS5EZWZhdWx0TG9nZ2VyKCksIG1pZGRsZXdhcmUsIGlzRGV2LCBzY2hlbWFzLCBhcHBWZXJzaW9uLCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBgaWRgIG11c3QgYmUgcGFzc2VkIHRvIGNyZWF0ZSBhbiBJbm5nZXN0IGluc3RhbmNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuX21vZGUgPSAoMCwgZW52X2pzXzEuZ2V0TW9kZSkoe1xuICAgICAgICAgICAgZXhwbGljaXRNb2RlOiB0eXBlb2YgaXNEZXYgPT09IFwiYm9vbGVhblwiID8gKGlzRGV2ID8gXCJkZXZcIiA6IFwiY2xvdWRcIikgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZldGNoID0gKDAsIGVudl9qc18xLmdldEZldGNoKShmZXRjaCk7XG4gICAgICAgIHRoaXMuaW5uZ2VzdEFwaSA9IG5ldyBhcGlfanNfMS5Jbm5nZXN0QXBpKHtcbiAgICAgICAgICAgIGJhc2VVcmw6IHRoaXMuYXBpQmFzZVVybCxcbiAgICAgICAgICAgIHNpZ25pbmdLZXk6ICgwLCBlbnZfanNfMS5wcm9jZXNzRW52KShjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTaWduaW5nS2V5KSB8fCBcIlwiLFxuICAgICAgICAgICAgc2lnbmluZ0tleUZhbGxiYWNrOiAoMCwgZW52X2pzXzEucHJvY2Vzc0VudikoY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2lnbmluZ0tleUZhbGxiYWNrKSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gc2NoZW1hcztcbiAgICAgICAgdGhpcy5sb2FkTW9kZUVudlZhcnMoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZSA9IHRoaXMuaW5pdGlhbGl6ZU1pZGRsZXdhcmUoW1xuICAgICAgICAgICAgLi4uZXhwb3J0cy5idWlsdEluTWlkZGxld2FyZSxcbiAgICAgICAgICAgIC4uLihtaWRkbGV3YXJlIHx8IFtdKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuX2FwcFZlcnNpb24gPSBhcHBWZXJzaW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYXBwIGlzIHJlYWR5IGFuZCBhbGwgbWlkZGxld2FyZVxuICAgICAqIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIGdldCByZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlkZGxld2FyZS50aGVuKCgpID0+IHsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZvciB0aGlzIGNsaWVudC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGFyZVxuICAgICAqIHBhc3NlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXQgcnVudGltZSBpbnN0ZWFkIG9mIGFzIGdsb2JhbHMgYW5kIG5lZWQgdG9cbiAgICAgKiB1cGRhdGUgdGhlIGNsaWVudCB3aXRoIHRob3NlIHZhbHVlcyBhcyByZXF1ZXN0cyBjb21lIGluLlxuICAgICAqL1xuICAgIHNldEVudlZhcnMoZW52ID0gKDAsIGVudl9qc18xLmFsbFByb2Nlc3NFbnYpKCkpIHtcbiAgICAgICAgdGhpcy5tb2RlID0gKDAsIGVudl9qc18xLmdldE1vZGUpKHsgZW52LCBjbGllbnQ6IHRoaXMgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsb2FkTW9kZUVudlZhcnMoKSB7XG4gICAgICAgIHRoaXMuX2FwaUJhc2VVcmwgPVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmJhc2VVcmwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QXBpQmFzZVVybF0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QmFzZVVybF0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGUuZ2V0RXhwbGljaXRVcmwoY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRCYXNlVXJsID1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5iYXNlVXJsIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlW1wiZW52XCJdW2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEV2ZW50QXBpQmFzZVVybF0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QmFzZVVybF0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGUuZ2V0RXhwbGljaXRVcmwoY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwpO1xuICAgICAgICB0aGlzLnNldEV2ZW50S2V5KHRoaXMub3B0aW9ucy5ldmVudEtleSB8fCB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RXZlbnRLZXldIHx8IFwiXCIpO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSAoMCwgZW52X2pzXzEuaW5uZ2VzdEhlYWRlcnMpKHtcbiAgICAgICAgICAgIGlubmdlc3RFbnY6IHRoaXMub3B0aW9ucy5lbnYsXG4gICAgICAgICAgICBlbnY6IHRoaXMubW9kZVtcImVudlwiXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5uZ2VzdEFwaVtcIm1vZGVcIl0gPSB0aGlzLm1vZGU7XG4gICAgICAgIHRoaXMuaW5uZ2VzdEFwaVtcImFwaUJhc2VVcmxcIl0gPSB0aGlzLl9hcGlCYXNlVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGFsbCBwYXNzZWQgbWlkZGxld2FyZSwgcnVubmluZyB0aGUgYHJlZ2lzdGVyYCBmdW5jdGlvbiBvbiBlYWNoXG4gICAgICogaW4gc2VxdWVuY2UgYW5kIHJldHVybmluZyB0aGUgcmVxdWVzdGVkIGhvb2sgcmVnaXN0cmF0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZShtaWRkbGV3YXJlID0gW10sIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2FpdCBmb3IgdGhlIHByZWZpeCBzdGFjayB0byBydW4gZmlyc3Q7IGRvIG5vdCB0cmlnZ2VyIG91cnMgYmVmb3JlIHRoaXNcbiAgICAgICAgICogaXMgY29tcGxldGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwcmVmaXggPSBhd2FpdCAoKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnByZWZpeFN0YWNrKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gbWlkZGxld2FyZS5yZWR1Y2UoYXN5bmMgKGFjYywgbSkgPT4ge1xuICAgICAgICAgICAgLy8gQmUgZXhwbGljaXQgYWJvdXQgd2FpdGluZyBmb3IgdGhlIHByZXZpb3VzIG1pZGRsZXdhcmUgdG8gZmluaXNoXG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYXdhaXQgYWNjO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGF3YWl0IG0uaW5pdChPYmplY3QuYXNzaWduKHsgY2xpZW50OiB0aGlzIH0sIG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5yZWdpc3RlcklucHV0KSk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIG5leHRdO1xuICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoW10pKTtcbiAgICAgICAgcmV0dXJuIFsuLi5wcmVmaXgsIC4uLihhd2FpdCBzdGFjayldO1xuICAgIH1cbiAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfVxuICAgIHNldCBtb2RlKG0pIHtcbiAgICAgICAgdGhpcy5fbW9kZSA9IG07XG4gICAgICAgIHRoaXMubG9hZE1vZGVFbnZWYXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcmVzcG9uc2UgZnJvbSBJbm5nZXN0LCByZWxheSB0aGUgZXJyb3IgdG8gdGhlIGNhbGxlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlLCByYXdCb2R5LCBmb3VuZEVyciA9IFwiVW5rbm93biBlcnJvclwiKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBmb3VuZEVycjtcbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSA9PT0gXCJVbmtub3duIGVycm9yXCIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiRXZlbnQga2V5IE5vdCBGb3VuZFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJDYW5ub3QgcHJvY2VzcyBldmVudCBwYXlsb2FkXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIkZvcmJpZGRlblwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJFdmVudCBrZXkgbm90IGZvdW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA2OlxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgJHtKU09OLnN0cmluZ2lmeShhd2FpdCByYXdCb2R5KX1gO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwOTpcbiAgICAgICAgICAgICAgICBjYXNlIDQxMjpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJFdmVudCB0cmFuc2Zvcm1hdGlvbiBmYWlsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MTM6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiRXZlbnQgcGF5bG9hZCB0b28gbGFyZ2VcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYCR7SlNPTi5zdHJpbmdpZnkoYXdhaXQgcmF3Qm9keSl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBJbm5nZXN0IEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGV2ZW50IGtleSBmb3IgdGhpcyBpbnN0YW5jZSBvZiBJbm5nZXN0LiBUaGlzIGlzIHVzZWZ1bCBpZiBmb3Igc29tZVxuICAgICAqIHJlYXNvbiB0aGUga2V5IGlzIG5vdCBhdmFpbGFibGUgYXQgdGltZSBvZiBpbnN0YW50aWF0aW9uIG9yIHByZXNlbnQgaW4gdGhlXG4gICAgICogYElOTkdFU1RfRVZFTlRfS0VZYCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBzZXRFdmVudEtleShcbiAgICAvKipcbiAgICAgKiBJbm5nZXN0IGV2ZW50IGtleSwgdXNlZCB0byBzZW5kIGV2ZW50cyB0byBJbm5nZXN0IENsb3VkLiBVc2UgdGhpcyBpcyB5b3VyXG4gICAgICoga2V5IGlzIGZvciBzb21lIHJlYXNvbiBub3QgYXZhaWxhYmxlIGF0IHRpbWUgb2YgaW5zdGFudGlhdGlvbiBvciBwcmVzZW50XG4gICAgICogaW4gdGhlIGBJTk5HRVNUX0VWRU5UX0tFWWAgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAgICovXG4gICAgZXZlbnRLZXkpIHtcbiAgICAgICAgdGhpcy5ldmVudEtleSA9IGV2ZW50S2V5IHx8IGNvbnN0c19qc18xLmR1bW15RXZlbnRLZXk7XG4gICAgICAgIHRoaXMuc2VuZEV2ZW50VXJsID0gbmV3IFVSTChgZS8ke3RoaXMuZXZlbnRLZXl9YCwgdGhpcy5ldmVudEJhc2VVcmwgfHwgY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwpO1xuICAgIH1cbiAgICBldmVudEtleVNldCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5ldmVudEtleSkgJiYgdGhpcy5ldmVudEtleSAhPT0gY29uc3RzX2pzXzEuZHVtbXlFdmVudEtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRVhQRVJJTUVOVEFMOiBUaGlzIEFQSSBpcyBub3QgeWV0IHN0YWJsZSBhbmQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG4gICAgICogd2l0aG91dCBhIG1ham9yIHZlcnNpb24gYnVtcC5cbiAgICAgKlxuICAgICAqIFNlbmQgYSBTaWduYWwgdG8gSW5uZ2VzdC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kU2lnbmFsKHsgc2lnbmFsLCBkYXRhLCBlbnYsIH0pIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIChlbnYgPyB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLkVudmlyb25tZW50XTogZW52IH0gOiB7fSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZFNpZ25hbCh7IHNpZ25hbCwgZGF0YSwgaGVhZGVycyB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmRTaWduYWwoeyBzaWduYWwsIGRhdGEsIGhlYWRlcnMsIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmlubmdlc3RBcGkuc2VuZFNpZ25hbCh7IHNpZ25hbCwgZGF0YSB9LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksIGhlYWRlcnMpKTtcbiAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZW5kIHNpZ25hbDogJHsoKF9hID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyb3IpIHx8IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIG9uZSBvciBtYW55IGV2ZW50cyB0byBJbm5nZXN0LiBUYWtlcyBhbiBlbnRpcmUgcGF5bG9hZCAoaW5jbHVkaW5nXG4gICAgICogbmFtZSkgYXMgZWFjaCBpbnB1dC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgaW5uZ2VzdC5zZW5kKHsgbmFtZTogXCJhcHAvdXNlci5jcmVhdGVkXCIsIGRhdGE6IHsgaWQ6IDEyMyB9IH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgaWYgdGhlIGV2ZW50KHMpIHdlcmUgc2VudCBzdWNjZXNzZnVsbHksXG4gICAgICogZWxzZSB0aHJvd3Mgd2l0aCBhbiBlcnJvciBleHBsYWluaW5nIHdoYXQgd2VudCB3cm9uZy5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3aXNoIHRvIHNlbmQgYW4gZXZlbnQgd2l0aCBjdXN0b20gdHlwZXMgKGkuZS4gb25lIHRoYXQgaGFzbid0IGJlZW5cbiAgICAgKiBnZW5lcmF0ZWQpLCBtYWtlIHN1cmUgdG8gYWRkIGl0IHdoZW4gY3JlYXRpbmcgeW91ciBJbm5nZXN0IGluc3RhbmNlLCBsaWtlXG4gICAgICogc286XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gICAgICogICBuYW1lOiBcIk15IEFwcFwiLFxuICAgICAqICAgc2NoZW1hczogbmV3IEV2ZW50U2NoZW1hcygpLmZyb21SZWNvcmQ8e1xuICAgICAqICAgICBcIm15L2V2ZW50XCI6IHtcbiAgICAgKiAgICAgICBuYW1lOiBcIm15L2V2ZW50XCI7XG4gICAgICogICAgICAgZGF0YTogeyBiYXI6IHN0cmluZyB9O1xuICAgICAqICAgICB9O1xuICAgICAqICAgfT4oKSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kKHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVudikgPyB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLkVudmlyb25tZW50XTogb3B0aW9ucy5lbnYgfSA6IHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kKHsgcGF5bG9hZCwgaGVhZGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIGZvciBzZW5kaW5nIGFuIGV2ZW50LCB1c2VkIHRvIGFsbG93IElubmdlc3QgaW50ZXJuYWxzIHRvXG4gICAgICogZnVydGhlciBjdXN0b21pemUgdGhlIHJlcXVlc3Qgc2VudCB0byBhbiBJbm5nZXN0IFNlcnZlci5cbiAgICAgKi9cbiAgICBhc3luYyBfc2VuZCh7IHBheWxvYWQsIGhlYWRlcnMsIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBub3dNaWxsaXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgbGV0IG1heEF0dGVtcHRzID0gNTtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzZXQgdGhlIGV2ZW50IElEIHNlZWQgaGVhZGVyLiBJZiBpdCBmYWlscyB0aGVuIGRpc2FibGUgcmV0cmllc1xuICAgICAgICAvLyAoYnV0IHdlIHN0aWxsIHdhbnQgdG8gc2VuZCB0aGUgZXZlbnQpLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW50cm9weSA9ICgwLCBjcnlwdG9fanNfMS5jcmVhdGVFbnRyb3B5KSgxMCk7XG4gICAgICAgICAgICBjb25zdCBlbnRyb3B5QmFzZTY0ID0gQnVmZmVyLmZyb20oZW50cm9weSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICAgICAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzKSwgeyBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5FdmVudElkU2VlZF06IGAke25vd01pbGxpc30sJHtlbnRyb3B5QmFzZTY0fWAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIkV2ZW50LXNlbmRpbmcgcmV0cmllcyBkaXNhYmxlZFwiO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gRGlzYWJsZSByZXRyaWVzLlxuICAgICAgICAgICAgbWF4QXR0ZW1wdHMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm1pZGRsZXdhcmUsIFwib25TZW5kRXZlbnRcIiwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1JbnB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYpLCBvdXRwdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zZm9ybU91dHB1dChwcmV2LCBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5yZXN1bHQpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQucmVzdWx0KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBwYXlsb2FkcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZClcbiAgICAgICAgICAgID8gcGF5bG9hZFxuICAgICAgICAgICAgOiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgPyBbcGF5bG9hZF1cbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCBpbnB1dENoYW5nZXMgPSBhd2FpdCAoKF9hID0gaG9va3MudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGhvb2tzLCB7XG4gICAgICAgICAgICBwYXlsb2FkczogWy4uLnBheWxvYWRzXSxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoaW5wdXRDaGFuZ2VzID09PSBudWxsIHx8IGlucHV0Q2hhbmdlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRDaGFuZ2VzLnBheWxvYWRzKSB7XG4gICAgICAgICAgICBwYXlsb2FkcyA9IFsuLi5pbnB1dENoYW5nZXMucGF5bG9hZHNdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGFsd2F5cyBhZGQgXCJ0c1wiIGFuZCBcImRhdGFcIiBmaWVsZHMgdG8gZXZlbnRzLiBcInRzXCIgaXMgYXV0by1cbiAgICAgICAgLy8gZmlsbGVkIGJ5IHRoZSBldmVudCBzZXJ2ZXIgc28gaXMgc2FmZSwgYW5kIGFkZGluZyBoZXJlIGZpeGVzIE5leHQuanNcbiAgICAgICAgLy8gc2VydmVyIGFjdGlvbiBjYWNoZSBpc3N1ZXMuXG4gICAgICAgIHBheWxvYWRzID0gcGF5bG9hZHMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwKSwgeyBcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgZ2VuZXJhdGUgYW4gaWRlbXBvdGVuY3kgSUQgZm9yIGFuIGV2ZW50IGZvciByZXRyaWVzXG4gICAgICAgICAgICAgICAgaWQ6IHAuaWQsIHRzOiBwLnRzIHx8IG5vd01pbGxpcywgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGRhdGE6IHAuZGF0YSB8fCB7fSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFwcGx5SG9va1RvT3V0cHV0ID0gYXN5bmMgKGFyZykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgaG9va091dHB1dCA9IGF3YWl0ICgoX2EgPSBob29rcy50cmFuc2Zvcm1PdXRwdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGhvb2tzLCBhcmcpKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFyZy5yZXN1bHQpLCBob29rT3V0cHV0ID09PSBudWxsIHx8IGhvb2tPdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvb2tPdXRwdXQucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IGNhbiBiZSB2YWxpZCBmb3IgYSB1c2VyIHRvIHNlbmQgYW4gZW1wdHkgbGlzdCBvZiBldmVudHM7IGlmIHRoaXNcbiAgICAgICAgICogaGFwcGVucywgc2hvdyBhIHdhcm5pbmcgdGhhdCB0aGlzIG1heSBub3QgYmUgaW50ZW5kZWQsIGJ1dCBkb24ndCB0aHJvdy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghcGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ3YXJuXCIsXG4gICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBcImBpbm5nZXN0LnNlbmQoKWAgY2FsbGVkIHdpdGggbm8gZXZlbnRzXCIsXG4gICAgICAgICAgICAgICAgcmVhc3N1cmFuY2U6IFwiVGhpcyBpcyBub3QgYW4gZXJyb3IsIGJ1dCB5b3UgbWF5IG5vdCBoYXZlIGludGVuZGVkIHRvIGRvIHRoaXMuXCIsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIlRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgYnV0IG5vIGV2ZW50cyBoYXZlIGJlZW4gc2VudCB0byBJbm5nZXN0LlwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFwcGx5SG9va1RvT3V0cHV0KHsgcmVzdWx0OiB7IGlkczogW10gfSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHNlbmRpbmcgZXZlbnRzLCBjaGVjayBpZiB0aGUgZGV2IHNlcnZlciBpcyBhdmFpbGFibGUuICBJZiBzbywgdXNlIHRoZVxuICAgICAgICAvLyBkZXYgc2VydmVyLlxuICAgICAgICBsZXQgdXJsID0gdGhpcy5zZW5kRXZlbnRVcmwuaHJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGluIHByb2QgbW9kZSBhbmQga2V5IGlzIG5vdCBwcmVzZW50LCBmYWlsIG5vdy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm1vZGUuaXNDbG91ZCAmJiAhdGhpcy5ldmVudEtleVNldCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBcIkZhaWxlZCB0byBzZW5kIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIllvdXIgZXZlbnQgb3IgZXZlbnRzIHdlcmUgbm90IHNlbnQgdG8gSW5uZ2VzdC5cIixcbiAgICAgICAgICAgICAgICB3aHk6IFwiV2UgY291bGRuJ3QgZmluZCBhbiBldmVudCBrZXkgdG8gdXNlIHRvIHNlbmQgZXZlbnRzIHRvIElubmdlc3QuXCIsXG4gICAgICAgICAgICAgICAgdG9GaXhOb3c6IGVycm9yc19qc18xLmZpeEV2ZW50S2V5TWlzc2luZ1N0ZXBzLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBkZXYgbW9kZSBoYXMgYmVlbiBpbmZlcnJlZCwgdHJ5IHRvIGhpdCB0aGUgZGV2IHNlcnZlciBmaXJzdCB0byBzZWUgaWZcbiAgICAgICAgICogaXQgZXhpc3RzLiBJZiBpdCBkb2VzLCB1c2UgaXQsIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gd2hhdGV2ZXIgc2VydmVyIHdlXG4gICAgICAgICAqIGhhdmUgY29uZmlndXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogYElOTkdFU1RfQkFTRV9VUkxgIGlzIHVzZWQgdG8gc2V0IGJvdGggZGV2IHNlcnZlciBhbmQgcHJvZCBVUkxzLCBzbyBpZiBhXG4gICAgICAgICAqIHVzZXIgaGFzIHNldCB0aGlzIGl0IG1lYW5zIHRoZXkgaGF2ZSBhbHJlYWR5IGNob3NlbiBhIFVSTCB0byBoaXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5tb2RlLmlzRGV2ICYmIHRoaXMubW9kZS5pc0luZmVycmVkICYmICF0aGlzLmV2ZW50QmFzZVVybCkge1xuICAgICAgICAgICAgY29uc3QgZGV2QXZhaWxhYmxlID0gYXdhaXQgKDAsIGRldnNlcnZlcl9qc18xLmRldlNlcnZlckF2YWlsYWJsZSkoY29uc3RzX2pzXzEuZGVmYXVsdERldlNlcnZlckhvc3QsIHRoaXMuZmV0Y2gpO1xuICAgICAgICAgICAgaWYgKGRldkF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJVcmwpKGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0LCBgZS8ke3RoaXMuZXZlbnRLZXl9YCkuaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgKDAsIHByb21pc2VzX2pzXzEucmV0cnlXaXRoQmFja29mZikoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJhd0JvZHk7XG4gICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gZmFsbGJhY2sgYXV0aCBoZXJlIGJlY2F1c2UgdGhpcyB1c2VzIGV2ZW50IGtleXMgYW5kXG4gICAgICAgICAgICAvLyBub3Qgc2lnbmluZyBrZXlzXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkocGF5bG9hZHMpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmF3Qm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBib2R5ID0gYXdhaXQgdHlwZXNfanNfMS5zZW5kRXZlbnRSZXNwb25zZVNjaGVtYS5wYXJzZUFzeW5jKHJhd0JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuZ2V0UmVzcG9uc2VFcnJvcihyZXNwb25zZSwgcmF3Qm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCB8fCBib2R5LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5nZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlLCByYXdCb2R5LCBib2R5LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXhBdHRlbXB0cyxcbiAgICAgICAgICAgIGJhc2VEZWxheTogMTAwLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwcGx5SG9va1RvT3V0cHV0KHsgcmVzdWx0OiB7IGlkczogYm9keS5pZHMgfSB9KTtcbiAgICB9XG4gICAgZ2V0IGZ1bmNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbEZucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVudGltZS1vbmx5IHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc2FuaXRpemVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImZuc1wiKSkge1xuICAgICAgICAgICAgLy8gdjIgLT4gdjMgbWlncmF0aW9uIHdhcm5pbmdcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9IElubmdlc3RGdW5jdGlvbjogXFxgZm5zXFxgIG9wdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIGluIHYzOyB1c2UgXFxgbWlkZGxld2FyZVxcYCBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9zZGsvbWlncmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyB2MiAtPiB2MyBydW50aW1lIG1pZ3JhdG9uIHdhcm5pbmdcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9IElubmdlc3RGdW5jdGlvbjogQ3JlYXRpbmcgYSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBoYXMgYmVlbiBkZXByZWNhdGVkIGluIHYzOyBwYXNzIGFuIG9iamVjdCBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9zZGsvbWlncmF0aW9uYCk7XG4gICAgICAgICAgICByZXR1cm4geyBpZDogb3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW50aW1lLW9ubHkgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzYW5pdGl6ZVRyaWdnZXJzKHRyaWdnZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJpZ2dlcnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIHYyIC0+IHYzIG1pZ3JhdGlvbiB3YXJuaW5nXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y29uc3RzX2pzXzEubG9nUHJlZml4fSBJbm5nZXN0RnVuY3Rpb246IENyZWF0aW5nIGEgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gdjM7IHBhc3MgYW4gb2JqZWN0IGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcbiAgICAgICAgICAgIHJldHVybiBbeyBldmVudDogdHJpZ2dlcnMgfV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRyaWdnZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0cmlnZ2Vyc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaWdnZXJzO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdCA9IElubmdlc3Q7XG4vKipcbiAqIERlZmF1bHQgbWlkZGxld2FyZSB0aGF0IGlzIGluY2x1ZGVkIGluIGV2ZXJ5IGNsaWVudCwgcGxhY2VkIGFmdGVyIHRoZSB1c2VyJ3NcbiAqIG1pZGRsZXdhcmUgb24gdGhlIGNsaWVudCBidXQgYmVmb3JlIGZ1bmN0aW9uLWxldmVsIG1pZGRsZXdhcmUuXG4gKlxuICogSXQgaXMgZGVmaW5lZCBoZXJlIHRvIGVuc3VyZSB0aGF0IGNvbW1lbnRzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZ2VuZXJhdGVkIFRTXG4gKiBkZWZpbml0aW9ucy4gV2l0aG91dCB0aGlzLCB3ZSBpbmZlciB0aGUgc3RhY2sgb2YgYnVpbHQtaW4gbWlkZGxld2FyZSB3aXRob3V0XG4gKiBjb21tZW50cywgbG9zaW5nIGEgbG90IG9mIHZhbHVlLlxuICpcbiAqIElmIHRoaXMgaXMgbW92ZWQsIHBsZWFzZSBlbnN1cmUgdGhhdCB1c2luZyB0aGlzIHBhY2thZ2UgaW4gYW5vdGhlciBwcm9qZWN0XG4gKiBjYW4gY29ycmVjdGx5IGFjY2VzcyBjb21tZW50cyBvbiBtdXRhdGVkIGlucHV0IGFuZCBvdXRwdXQuXG4gKlxuICogVGhpcyByZXR1cm4gcGF0dGVybiBtaW1pY3MgdGhlIG91dHB1dCBvZiBhIGBzYXRpc2ZpZXNgIHN1ZmZpeDsgaXQncyB1c2VkIGFzXG4gKiB3ZSBzdXBwb3J0IHZlcnNpb25zIG9mIFR5cGVTY3JpcHQgcHJpb3IgdG8gdGhlIGludHJvZHVjdGlvbiBvZiBgc2F0aXNmaWVzYC5cbiAqL1xuZXhwb3J0cy5idWlsdEluTWlkZGxld2FyZSA9ICgobSkgPT4gbSkoW1xuICAgIG5ldyBJbm5nZXN0TWlkZGxld2FyZV9qc18xLklubmdlc3RNaWRkbGV3YXJlKHtcbiAgICAgICAgbmFtZTogXCJJbm5nZXN0OiBMb2dnZXJcIixcbiAgICAgICAgaW5pdCh7IGNsaWVudCB9KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9uRnVuY3Rpb25SdW4oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY3R4IH0gPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuSUQ6IGN0eC5ydW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogY3R4LmV2ZW50Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGFyZy5mbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvdmlkZWRMb2dnZXIgPSBjbGllbnRbXCJsb2dnZXJcIl07XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNoaWxkIGxvZ2dlciBpZiB0aGUgcHJvdmlkZWQgbG9nZ2VyIGhhcyBjaGlsZCBsb2dnZXIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImNoaWxkXCIgaW4gcHJvdmlkZWRMb2dnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZExvZ2dlciA9IHByb3ZpZGVkTG9nZ2VyLmNoaWxkKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgdG8gY3JlYXRlIFwiY2hpbGRMb2dnZXJcIiB3aXRoIGVycm9yOiAnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dnZXIgPSBuZXcgbG9nZ2VyX2pzXzEuUHJveHlMb2dnZXIocHJvdmlkZWRMb2dnZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBwYXNzZWQgaW4gbG9nZ2VyIGZyb20gdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWZhdWx0cyB0byBhIGNvbnNvbGUgbG9nZ2VyIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyOiBsb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFeGVjdXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU91dHB1dCh7IHJlc3VsdDogeyBlcnJvciB9IH0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgYmVmb3JlUmVzcG9uc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbG9nZ2VyLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pLFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/Inngest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestCommHandler.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/components/InngestCommHandler.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _RequestSignature_instances, _RequestSignature_verifySignature;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestCommHandler = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/inngest/node_modules/debug/src/index.js\"));\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst ServerTiming_js_1 = __webpack_require__(/*! ../helpers/ServerTiming.js */ \"(rsc)/./node_modules/inngest/helpers/ServerTiming.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst enum_js_1 = __webpack_require__(/*! ../helpers/enum.js */ \"(rsc)/./node_modules/inngest/helpers/enum.js\");\nconst env_js_1 = __webpack_require__(/*! ../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst net_js_1 = __webpack_require__(/*! ../helpers/net.js */ \"(rsc)/./node_modules/inngest/helpers/net.js\");\nconst promises_js_1 = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst stream_js_1 = __webpack_require__(/*! ../helpers/stream.js */ \"(rsc)/./node_modules/inngest/helpers/stream.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\n/**\n * A schema for the response from Inngest when registering.\n */\nconst registerResSchema = zod_1.z.object({\n    status: zod_1.z.number().default(200),\n    skipped: zod_1.z.boolean().optional().default(false),\n    modified: zod_1.z.boolean().optional().default(false),\n    error: zod_1.z.string().default(\"Successfully registered\"),\n});\n/**\n * `InngestCommHandler` is a class for handling incoming requests from Inngest (or\n * Inngest's tooling such as the dev server or CLI) and taking appropriate\n * action for any served functions.\n *\n * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using\n * this class; the exposed `serve` function will - most commonly - create an\n * instance of `InngestCommHandler` and then return `instance.createHandler()`.\n *\n * See individual parameter details for more information, or see the\n * source code for an existing handler, e.g.\n * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}\n *\n * @example\n * ```\n * // my-custom-handler.ts\n * import {\n *   InngestCommHandler,\n *   type ServeHandlerOptions,\n * } from \"./components/InngestCommHandler\";\n *\n * export const serve = (options: ServeHandlerOptions) => {\n *   const handler = new InngestCommHandler({\n *     frameworkName: \"my-custom-handler\",\n *     ...options,\n *     handler: (req: Request) => {\n *       return {\n *         body: () => req.json(),\n *         headers: (key) => req.headers.get(key),\n *         method: () => req.method,\n *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n *         transformResponse: ({ body, status, headers }) => {\n *           return new Response(body, { status, headers });\n *         },\n *       };\n *     },\n *   });\n *\n *   return handler.createHandler();\n * };\n * ```\n *\n * @public\n */\nclass InngestCommHandler {\n    constructor(options) {\n        var _a;\n        /**\n         * A private collection of functions that are being served. This map is used\n         * to find and register functions when interacting with Inngest Cloud.\n         */\n        this.fns = {};\n        this.env = (0, env_js_1.allProcessEnv)();\n        // Set input options directly so we can reference them later\n        this._options = options;\n        /**\n         * v2 -> v3 migration error.\n         *\n         * If a serve handler is passed a client as the first argument, it'll be\n         * spread in to these options. We should be able to detect this by picking\n         * up a unique property on the object.\n         */\n        if (Object.prototype.hasOwnProperty.call(options, \"eventKey\")) {\n            throw new Error(`${consts_js_1.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \\`client\\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n        this.frameworkName = options.frameworkName;\n        this.client = options.client;\n        if (options.id) {\n            console.warn(`${consts_js_1.logPrefix} The \\`id\\` serve option is deprecated and will be removed in v4`);\n        }\n        this.id = options.id || this.client.id;\n        this.handler = options.handler;\n        /**\n         * Provide a hidden option to allow expired signatures to be accepted during\n         * testing.\n         */\n        this.allowExpiredSignatures = Boolean(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, prefer-rest-params\n        (_a = arguments[\"0\"]) === null || _a === void 0 ? void 0 : _a.__testingAllowExpiredSignatures);\n        // Ensure we filter any undefined functions in case of missing imports.\n        this.rawFns = options.functions.filter(Boolean);\n        if (this.rawFns.length !== options.functions.length) {\n            // TODO PrettyError\n            console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);\n        }\n        this.fns = this.rawFns.reduce((acc, fn) => {\n            const configs = fn[\"getConfig\"]({\n                baseUrl: new URL(\"https://example.com\"),\n                appPrefix: this.id,\n            });\n            const fns = configs.reduce((acc, { id }, index) => {\n                return Object.assign(Object.assign({}, acc), { [id]: { fn, onFailure: Boolean(index) } });\n            }, {});\n            configs.forEach(({ id }) => {\n                if (acc[id]) {\n                    // TODO PrettyError\n                    throw new Error(`Duplicate function ID \"${id}\"; please change a function's name or provide an explicit ID to avoid conflicts.`);\n                }\n            });\n            return Object.assign(Object.assign({}, acc), fns);\n        }, {});\n        this.inngestRegisterUrl = new URL(\"/fn/register\", this.apiBaseUrl);\n        this.signingKey = options.signingKey;\n        this.signingKeyFallback = options.signingKeyFallback;\n        this._serveHost = options.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n        this._servePath = options.servePath || this.env[consts_js_1.envKeys.InngestServePath];\n        this.skipSignatureValidation = options.skipSignatureValidation || false;\n        const defaultLogLevel = \"info\";\n        this.logLevel = zod_1.z\n            .enum(types_js_1.logLevels)\n            .default(defaultLogLevel)\n            .catch((ctx) => {\n            this.log(\"warn\", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);\n            return defaultLogLevel;\n        })\n            .parse(options.logLevel || this.env[consts_js_1.envKeys.InngestLogLevel]);\n        if (this.logLevel === \"debug\") {\n            /**\n             * `debug` is an old library; sometimes its runtime detection doesn't work\n             * for newer pairings of framework/runtime.\n             *\n             * One silly symptom of this is that `Debug()` returns an anonymous\n             * function with no extra properties instead of a `Debugger` instance if\n             * the wrong code is consumed following a bad detection. This results in\n             * the following `.enable()` call failing, so we just try carefully to\n             * enable it here.\n             */\n            if (debug_1.default.enable && typeof debug_1.default.enable === \"function\") {\n                debug_1.default.enable(`${consts_js_1.debugPrefix}:*`);\n            }\n        }\n        const defaultStreamingOption = false;\n        this.streaming = zod_1.z\n            .union([zod_1.z.enum([\"allow\", \"force\"]), zod_1.z.literal(false)])\n            .default(defaultStreamingOption)\n            .catch((ctx) => {\n            this.log(\"warn\", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);\n            return defaultStreamingOption;\n        })\n            .parse(options.streaming || this.env[consts_js_1.envKeys.InngestStreaming]);\n        this.fetch = options.fetch ? (0, env_js_1.getFetch)(options.fetch) : this.client[\"fetch\"];\n    }\n    /**\n     * Get the API base URL for the Inngest API.\n     *\n     * This is a getter to encourage checking the environment for the API base URL\n     * each time it's accessed, as it may change during execution.\n     */\n    get apiBaseUrl() {\n        return (this._options.baseUrl ||\n            this.env[consts_js_1.envKeys.InngestApiBaseUrl] ||\n            this.env[consts_js_1.envKeys.InngestBaseUrl] ||\n            this.client.apiBaseUrl ||\n            consts_js_1.defaultInngestApiBaseUrl);\n    }\n    /**\n     * Get the event API base URL for the Inngest API.\n     *\n     * This is a getter to encourage checking the environment for the event API\n     * base URL each time it's accessed, as it may change during execution.\n     */\n    get eventApiBaseUrl() {\n        return (this._options.baseUrl ||\n            this.env[consts_js_1.envKeys.InngestEventApiBaseUrl] ||\n            this.env[consts_js_1.envKeys.InngestBaseUrl] ||\n            this.client.eventBaseUrl ||\n            consts_js_1.defaultInngestEventBaseUrl);\n    }\n    /**\n     * The host used to access the Inngest serve endpoint, e.g.:\n     *\n     *     \"https://myapp.com\"\n     *\n     * By default, the library will try to infer this using request details such\n     * as the \"Host\" header and request path, but sometimes this isn't possible\n     * (e.g. when running in a more controlled environments such as AWS Lambda or\n     * when dealing with proxies/redirects).\n     *\n     * Provide the custom hostname here to ensure that the path is reported\n     * correctly when registering functions with Inngest.\n     *\n     * To also provide a custom path, use `servePath`.\n     */\n    get serveHost() {\n        return this._serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n    }\n    /**\n     * The path to the Inngest serve endpoint. e.g.:\n     *\n     *     \"/some/long/path/to/inngest/endpoint\"\n     *\n     * By default, the library will try to infer this using request details such\n     * as the \"Host\" header and request path, but sometimes this isn't possible\n     * (e.g. when running in a more controlled environments such as AWS Lambda or\n     * when dealing with proxies/redirects).\n     *\n     * Provide the custom path (excluding the hostname) here to ensure that the\n     * path is reported correctly when registering functions with Inngest.\n     *\n     * To also provide a custom hostname, use `serveHost`.\n     *\n     * This is a getter to encourage checking the environment for the serve path\n     * each time it's accessed, as it may change during execution.\n     */\n    get servePath() {\n        return this._servePath || this.env[consts_js_1.envKeys.InngestServePath];\n    }\n    get hashedEventKey() {\n        if (!this.client[\"eventKey\"] || this.client[\"eventKey\"] === consts_js_1.dummyEventKey) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashEventKey)(this.client[\"eventKey\"]);\n    }\n    // hashedSigningKey creates a sha256 checksum of the signing key with the\n    // same signing key prefix.\n    get hashedSigningKey() {\n        if (!this.signingKey) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKey);\n    }\n    get hashedSigningKeyFallback() {\n        if (!this.signingKeyFallback) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);\n    }\n    /**\n     * Returns a `boolean` representing whether this handler will stream responses\n     * or not. Takes into account the user's preference and the platform's\n     * capabilities.\n     */\n    async shouldStream(actions) {\n        const rawProbe = await actions.queryStringWithDefaults(\"testing for probe\", consts_js_1.queryKeys.Probe);\n        if (rawProbe !== undefined) {\n            return false;\n        }\n        // We must be able to stream responses to continue.\n        if (!actions.transformStreamingResponse) {\n            return false;\n        }\n        // If the user has forced streaming, we should always stream.\n        if (this.streaming === \"force\") {\n            return true;\n        }\n        // If the user has allowed streaming, we should stream if the platform\n        // supports it.\n        return (this.streaming === \"allow\" &&\n            (0, env_js_1.platformSupportsStreaming)(this.frameworkName, this.env));\n    }\n    /**\n     * `createHandler` should be used to return a type-equivalent version of the\n     * `handler` specified during instantiation.\n     *\n     * @example\n     * ```\n     * // my-custom-handler.ts\n     * import {\n     *   InngestCommHandler,\n     *   type ServeHandlerOptions,\n     * } from \"./components/InngestCommHandler\";\n     *\n     * export const serve = (options: ServeHandlerOptions) => {\n     *   const handler = new InngestCommHandler({\n     *     frameworkName: \"my-custom-handler\",\n     *     ...options,\n     *     handler: (req: Request) => {\n     *       return {\n     *         body: () => req.json(),\n     *         headers: (key) => req.headers.get(key),\n     *         method: () => req.method,\n     *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n     *         transformResponse: ({ body, status, headers }) => {\n     *           return new Response(body, { status, headers });\n     *         },\n     *       };\n     *     },\n     *   });\n     *\n     *   return handler.createHandler();\n     * };\n     * ```\n     */\n    createHandler() {\n        const handler = async (...args) => {\n            var _a, _b;\n            const timer = new ServerTiming_js_1.ServerTiming();\n            /**\n             * Used for testing, allow setting action overrides externally when\n             * calling the handler. Always search the final argument.\n             */\n            const lastArg = args[args.length - 1];\n            const actionOverrides = typeof lastArg === \"object\" &&\n                lastArg !== null &&\n                \"actionOverrides\" in lastArg &&\n                typeof lastArg[\"actionOverrides\"] === \"object\" &&\n                lastArg[\"actionOverrides\"] !== null\n                ? lastArg[\"actionOverrides\"]\n                : {};\n            /**\n             * We purposefully `await` the handler, as it could be either sync or\n             * async.\n             */\n            const rawActions = Object.assign(Object.assign({}, (await timer\n                .wrap(\"handler\", () => this.handler(...args))\n                .catch((0, errors_js_1.rethrowError)(\"Serve handler failed to run\")))), actionOverrides);\n            /**\n             * Map over every `action` in `rawActions` and create a new `actions`\n             * object where each function is safely promisified with each access\n             * requiring a reason.\n             *\n             * This helps us provide high quality errors about what's going wrong for\n             * each access without having to wrap every access in a try/catch.\n             */\n            const promisifiedActions = Object.entries(rawActions).reduce((acc, [key, value]) => {\n                if (typeof value !== \"function\") {\n                    return acc;\n                }\n                return Object.assign(Object.assign({}, acc), { [key]: (reason, ...args) => {\n                        const errMessage = [\n                            `Failed calling \\`${key}\\` from serve handler`,\n                            reason,\n                        ]\n                            .filter(Boolean)\n                            .join(\" when \");\n                        const fn = () => value(...args);\n                        return (0, promises_js_1.runAsPromise)(fn)\n                            .catch((0, errors_js_1.rethrowError)(errMessage))\n                            .catch((err) => {\n                            this.log(\"error\", err);\n                            throw err;\n                        });\n                    } });\n            }, {});\n            /**\n             * Mapped promisified handlers from userland `serve()` function mixed in\n             * with some helpers.\n             */\n            const actions = Object.assign(Object.assign(Object.assign({}, promisifiedActions), { queryStringWithDefaults: async (reason, key) => {\n                    var _a;\n                    const url = await actions.url(reason);\n                    const ret = (await ((_a = actions.queryString) === null || _a === void 0 ? void 0 : _a.call(actions, reason, key, url))) ||\n                        url.searchParams.get(key) ||\n                        undefined;\n                    return ret;\n                } }), actionOverrides);\n            const [env, expectedServerKind] = await Promise.all([\n                (_a = actions.env) === null || _a === void 0 ? void 0 : _a.call(actions, \"starting to handle request\"),\n                actions.headers(\"checking expected server kind\", consts_js_1.headerKeys.InngestServerKind),\n            ]);\n            // Always make sure to merge whatever env we've been given with\n            // `process.env`; some platforms may not provide all the necessary\n            // environment variables or may use two sources.\n            this.env = Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), env);\n            const getInngestHeaders = () => (0, env_js_1.inngestHeaders)({\n                env: this.env,\n                framework: this.frameworkName,\n                client: this.client,\n                expectedServerKind: expectedServerKind || undefined,\n                extras: {\n                    \"Server-Timing\": timer.getHeader(),\n                },\n            });\n            const assumedMode = (0, env_js_1.getMode)({ env: this.env, client: this.client });\n            if (assumedMode.isExplicit) {\n                this._mode = assumedMode;\n            }\n            else {\n                const serveIsProd = await ((_b = actions.isProduction) === null || _b === void 0 ? void 0 : _b.call(actions, \"starting to handle request\"));\n                if (typeof serveIsProd === \"boolean\") {\n                    this._mode = new env_js_1.Mode({\n                        type: serveIsProd ? \"cloud\" : \"dev\",\n                        isExplicit: false,\n                    });\n                }\n                else {\n                    this._mode = assumedMode;\n                }\n            }\n            this.upsertKeysFromEnv();\n            const methodP = actions.method(\"starting to handle request\");\n            const headerPromises = [\n                consts_js_1.headerKeys.TraceParent,\n                consts_js_1.headerKeys.TraceState,\n            ].map(async (header) => {\n                const value = await actions.headers(`fetching ${header} for forwarding`, header);\n                return { header, value };\n            });\n            const contentLength = await actions\n                .headers(\"checking signature for request\", consts_js_1.headerKeys.ContentLength)\n                .then((value) => {\n                if (!value) {\n                    return undefined;\n                }\n                return parseInt(value, 10);\n            });\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const [signature, method, body] = await Promise.all([\n                actions\n                    .headers(\"checking signature for request\", consts_js_1.headerKeys.Signature)\n                    .then((headerSignature) => {\n                    return headerSignature !== null && headerSignature !== void 0 ? headerSignature : undefined;\n                }),\n                methodP,\n                methodP.then((method) => {\n                    if (method === \"POST\" || method === \"PUT\") {\n                        if (!contentLength) {\n                            // Return empty string because req.json() will throw an error.\n                            return \"\";\n                        }\n                        return actions.body(`checking body for request signing as method is ${method}`);\n                    }\n                    return \"\";\n                }),\n            ]);\n            const signatureValidation = this.validateSignature(signature, body);\n            const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders) => {\n                return fetchedHeaders.reduce((acc, { header, value }) => {\n                    if (value) {\n                        acc[header] = value;\n                    }\n                    return acc;\n                }, {});\n            });\n            const actionRes = timer.wrap(\"action\", () => this.handleAction({\n                actions,\n                timer,\n                getInngestHeaders,\n                reqArgs: args,\n                signatureValidation,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                body,\n                method,\n                headers: headersToForwardP,\n            }));\n            /**\n             * Prepares an action response by merging returned data to provide\n             * trailing information such as `Server-Timing` headers.\n             *\n             * It should always prioritize the headers returned by the action, as they\n             * may contain important information such as `Content-Type`.\n             */\n            const prepareActionRes = async (res) => {\n                var _a;\n                const headers = Object.assign(Object.assign(Object.assign(Object.assign({}, getInngestHeaders()), (await headersToForwardP)), res.headers), (res.version === null\n                    ? {}\n                    : {\n                        [consts_js_1.headerKeys.RequestVersion]: ((_a = res.version) !== null && _a !== void 0 ? _a : InngestExecution_js_1.PREFERRED_EXECUTION_VERSION).toString(),\n                    }));\n                let signature;\n                try {\n                    signature = await signatureValidation.then((result) => {\n                        if (!result.success || !result.keyUsed) {\n                            return undefined;\n                        }\n                        return this.getResponseSignature(result.keyUsed, res.body);\n                    });\n                }\n                catch (err) {\n                    // If we fail to sign, retun a 500 with the error.\n                    return Object.assign(Object.assign({}, res), { headers, body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(err)), status: 500 });\n                }\n                if (signature) {\n                    headers[consts_js_1.headerKeys.Signature] = signature;\n                }\n                return Object.assign(Object.assign({}, res), { headers });\n            };\n            if (await this.shouldStream(actions)) {\n                const method = await actions.method(\"starting streaming response\");\n                if (method === \"POST\") {\n                    const { stream, finalize } = await (0, stream_js_1.createStream)();\n                    /**\n                     * Errors are handled by `handleAction` here to ensure that an\n                     * appropriate response is always given.\n                     */\n                    void actionRes.then((res) => {\n                        return finalize(prepareActionRes(res));\n                    });\n                    return timer.wrap(\"res\", () => {\n                        var _a;\n                        return (_a = actions.transformStreamingResponse) === null || _a === void 0 ? void 0 : _a.call(actions, \"starting streaming response\", {\n                            status: 201,\n                            headers: getInngestHeaders(),\n                            body: stream,\n                            version: null,\n                        });\n                    });\n                }\n            }\n            return timer.wrap(\"res\", async () => {\n                return actionRes.then(prepareActionRes).then((actionRes) => {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return actions.transformResponse(\"sending back response\", actionRes);\n                });\n            });\n        };\n        /**\n         * Some platforms check (at runtime) the length of the function being used\n         * to handle an endpoint. If this is a variadic function, it will fail that\n         * check.\n         *\n         * Therefore, we expect the arguments accepted to be the same length as the\n         * `handler` function passed internally.\n         *\n         * We also set a name to avoid a common useless name in tracing such as\n         * `\"anonymous\"` or `\"bound function\"`.\n         *\n         * https://github.com/getsentry/sentry-javascript/issues/3284\n         */\n        Object.defineProperties(handler, {\n            name: {\n                value: \"InngestHandler\",\n            },\n            length: {\n                value: this.handler.length,\n            },\n        });\n        return handler;\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(m) {\n        this._mode = m;\n        if (m) {\n            this.client[\"mode\"] = m;\n        }\n    }\n    /**\n     * Given a set of functions to check if an action is available from the\n     * instance's handler, enact any action that is found.\n     *\n     * This method can fetch varying payloads of data, but ultimately is the place\n     * where _decisions_ are made regarding functionality.\n     *\n     * For example, if we find that we should be viewing the UI, this function\n     * will decide whether the UI should be visible based on the payload it has\n     * found (e.g. env vars, options, etc).\n     */\n    async handleAction({ actions, timer, getInngestHeaders, reqArgs, signatureValidation, body, method, headers, }) {\n        var _a;\n        // This is when the request body is completely missing; it does not\n        // include an empty body. This commonly happens when the HTTP framework\n        // doesn't have body parsing middleware.\n        const isMissingBody = body === undefined;\n        try {\n            let url = await actions.url(\"starting to handle request\");\n            if (method === \"POST\") {\n                if (isMissingBody) {\n                    this.log(\"error\", \"Missing body when executing, possibly due to missing request body middleware\");\n                    return {\n                        status: 500,\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                        },\n                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(\"Missing request body when executing, possibly due to missing request body middleware\"))),\n                        version: undefined,\n                    };\n                }\n                const validationResult = await signatureValidation;\n                if (!validationResult.success) {\n                    return {\n                        status: 401,\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                        },\n                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(validationResult.err)),\n                        version: undefined,\n                    };\n                }\n                const rawProbe = await actions.queryStringWithDefaults(\"testing for probe\", consts_js_1.queryKeys.Probe);\n                if (rawProbe) {\n                    const probe = (0, enum_js_1.enumFromValue)(consts_js_1.probe, rawProbe);\n                    if (!probe) {\n                        // If we're here, we've received a probe that we don't recognize.\n                        // Fail.\n                        return {\n                            status: 400,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(`Unknown probe \"${rawProbe}\"`))),\n                            version: undefined,\n                        };\n                    }\n                    // Provide actions for every probe available.\n                    const probeActions = {\n                        [consts_js_1.probe.Trust]: () => ({\n                            status: 200,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: \"\",\n                            version: undefined,\n                        }),\n                    };\n                    return probeActions[probe]();\n                }\n                const fnId = await actions.queryStringWithDefaults(\"processing run request\", consts_js_1.queryKeys.FnId);\n                if (!fnId) {\n                    // TODO PrettyError\n                    throw new Error(\"No function ID found in request\");\n                }\n                const stepId = (await actions.queryStringWithDefaults(\"processing run request\", consts_js_1.queryKeys.StepId)) || null;\n                const { version, result } = this.runStep({\n                    functionId: fnId,\n                    data: body,\n                    stepId,\n                    timer,\n                    reqArgs,\n                    headers: await headers,\n                });\n                const stepOutput = await result;\n                /**\n                 * Functions can return `undefined`, but we'll always convert this to\n                 * `null`, as this is appropriately serializable by JSON.\n                 */\n                const opDataUndefinedToNull = (op) => {\n                    op.data = (0, functions_js_1.undefinedToNull)(op.data);\n                    return op;\n                };\n                const resultHandlers = {\n                    \"function-rejected\": (result) => {\n                        return {\n                            status: result.retriable ? 500 : 400,\n                            headers: Object.assign({ \"Content-Type\": \"application/json\", [consts_js_1.headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\" }, (typeof result.retriable === \"string\"\n                                ? { [consts_js_1.headerKeys.RetryAfter]: result.retriable }\n                                : {})),\n                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.error)),\n                            version,\n                        };\n                    },\n                    \"function-resolved\": (result) => {\n                        return {\n                            status: 200,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.data)),\n                            version,\n                        };\n                    },\n                    \"step-not-found\": (result) => {\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                                [consts_js_1.headerKeys.NoRetry]: \"false\",\n                            },\n                            body: (0, strings_js_1.stringify)({\n                                error: `Could not find step \"${result.step.displayName || result.step.id}\" to run; timed out`,\n                            }),\n                            version,\n                        };\n                    },\n                    \"step-ran\": (result) => {\n                        const step = opDataUndefinedToNull(result.step);\n                        return {\n                            status: 206,\n                            headers: Object.assign({ \"Content-Type\": \"application/json\" }, (typeof result.retriable !== \"undefined\"\n                                ? Object.assign({ [consts_js_1.headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\" }, (typeof result.retriable === \"string\"\n                                    ? { [consts_js_1.headerKeys.RetryAfter]: result.retriable }\n                                    : {})) : {})),\n                            body: (0, strings_js_1.stringify)([step]),\n                            version,\n                        };\n                    },\n                    \"steps-found\": (result) => {\n                        const steps = result.steps.map(opDataUndefinedToNull);\n                        return {\n                            status: 206,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)(steps),\n                            version,\n                        };\n                    },\n                };\n                const handler = resultHandlers[stepOutput.type];\n                try {\n                    return await handler(stepOutput);\n                }\n                catch (err) {\n                    this.log(\"error\", \"Error handling execution result\", err);\n                    throw err;\n                }\n            }\n            // TODO: This feels hacky, so we should probably make it not hacky.\n            const env = (_a = getInngestHeaders()[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;\n            if (method === \"GET\") {\n                return {\n                    status: 200,\n                    body: (0, strings_js_1.stringify)(await this.introspectionBody({\n                        actions,\n                        env,\n                        signatureValidation,\n                        url,\n                    })),\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    version: undefined,\n                };\n            }\n            if (method === \"PUT\") {\n                const [deployId, inBandSyncRequested] = await Promise.all([\n                    actions\n                        .queryStringWithDefaults(\"processing deployment request\", consts_js_1.queryKeys.DeployId)\n                        .then((deployId) => {\n                        return deployId === \"undefined\" ? undefined : deployId;\n                    }),\n                    Promise.resolve((0, env_js_1.parseAsBoolean)(this.env[consts_js_1.envKeys.InngestAllowInBandSync]))\n                        .then((allowInBandSync) => {\n                        if (allowInBandSync !== undefined && !allowInBandSync) {\n                            return consts_js_1.syncKind.OutOfBand;\n                        }\n                        return actions.headers(\"processing deployment request\", consts_js_1.headerKeys.InngestSyncKind);\n                    })\n                        .then((kind) => {\n                        return kind === consts_js_1.syncKind.InBand;\n                    }),\n                ]);\n                if (inBandSyncRequested) {\n                    if (isMissingBody) {\n                        this.log(\"error\", \"Missing body when syncing, possibly due to missing request body middleware\");\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(\"Missing request body when syncing, possibly due to missing request body middleware\"))),\n                            version: undefined,\n                        };\n                    }\n                    // Validation can be successful if we're in dev mode and did not\n                    // actually validate a key. In this case, also check that we did indeed\n                    // use a particular key to validate.\n                    const sigCheck = await signatureValidation;\n                    if (!sigCheck.success) {\n                        return {\n                            status: 401,\n                            body: (0, strings_js_1.stringify)({\n                                code: \"sig_verification_failed\",\n                            }),\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            version: undefined,\n                        };\n                    }\n                    const res = types_js_1.inBandSyncRequestBodySchema.safeParse(body);\n                    if (!res.success) {\n                        return {\n                            status: 400,\n                            body: (0, strings_js_1.stringify)({\n                                code: \"invalid_request\",\n                                message: res.error.message,\n                            }),\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            version: undefined,\n                        };\n                    }\n                    // We can trust the URL here because it's coming from\n                    // signature-verified request.\n                    url = this.reqUrl(new URL(res.data.url));\n                    // This should be an in-band sync\n                    const respBody = await this.inBandRegisterBody({\n                        actions,\n                        deployId,\n                        env,\n                        signatureValidation,\n                        url,\n                    });\n                    return {\n                        status: 200,\n                        body: (0, strings_js_1.stringify)(respBody),\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                            [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.InBand,\n                        },\n                        version: undefined,\n                    };\n                }\n                // If we're here, this is a legacy out-of-band sync\n                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getInngestHeaders);\n                return {\n                    status,\n                    body: (0, strings_js_1.stringify)({ message, modified }),\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand,\n                    },\n                    version: undefined,\n                };\n            }\n        }\n        catch (err) {\n            return {\n                status: 500,\n                body: (0, strings_js_1.stringify)(Object.assign({ type: \"internal\" }, (0, errors_js_1.serializeError)(err))),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                version: undefined,\n            };\n        }\n        return {\n            status: 405,\n            body: JSON.stringify({\n                message: \"No action found; request was likely not POST, PUT, or GET\",\n                mode: this._mode,\n            }),\n            headers: {},\n            version: undefined,\n        };\n    }\n    runStep({ functionId, stepId, data, timer, reqArgs, headers, }) {\n        var _a, _b;\n        const fn = this.fns[functionId];\n        if (!fn) {\n            // TODO PrettyError\n            throw new Error(`Could not find function with ID \"${functionId}\"`);\n        }\n        const immediateFnData = (0, functions_js_1.parseFnData)(data);\n        let { version } = immediateFnData;\n        // Handle opting in to optimized parallelism in v3.\n        if (version === InngestExecution_js_1.ExecutionVersion.V1 &&\n            ((_b = (_a = fn.fn)[\"shouldOptimizeParallelism\"]) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            version = InngestExecution_js_1.ExecutionVersion.V2;\n        }\n        const result = (0, promises_js_1.runAsPromise)(async () => {\n            const anyFnData = await (0, functions_js_1.fetchAllFnData)({\n                data: immediateFnData,\n                api: this.client[\"inngestApi\"],\n                version,\n            });\n            if (!anyFnData.ok) {\n                throw new Error(anyFnData.error);\n            }\n            const executionStarters = ((s) => s)({\n                [InngestExecution_js_1.ExecutionVersion.V0]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, data]) => {\n                        return Object.assign(Object.assign({}, acc), { \n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            [id]: { id, data } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n                [InngestExecution_js_1.ExecutionVersion.V1]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {\n                        return Object.assign(Object.assign({}, acc), { [id]: result.type === \"data\"\n                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                    { id, data: result.data }\n                                : result.type === \"input\"\n                                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                        { id, input: result.input }\n                                    : { id, error: result.error } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n                [InngestExecution_js_1.ExecutionVersion.V2]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {\n                        return Object.assign(Object.assign({}, acc), { [id]: result.type === \"data\"\n                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                    { id, data: result.data }\n                                : result.type === \"input\"\n                                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                        { id, input: result.input }\n                                    : { id, error: result.error } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n            });\n            const executionOptions = await executionStarters[version](anyFnData.value);\n            return fn.fn[\"createExecution\"](executionOptions).start();\n        });\n        return { version, result };\n    }\n    configs(url) {\n        const configs = Object.values(this.rawFns).reduce((acc, fn) => [\n            ...acc,\n            ...fn[\"getConfig\"]({ baseUrl: url, appPrefix: this.id }),\n        ], []);\n        for (const config of configs) {\n            const check = types_js_1.functionConfigSchema.safeParse(config);\n            if (!check.success) {\n                const errors = check.error.errors.map((err) => err.message).join(\"; \");\n                this.log(\"warn\", `Config invalid for function \"${config.id}\" : ${errors}`);\n            }\n        }\n        return configs;\n    }\n    /**\n     * Return an Inngest serve endpoint URL given a potential `path` and `host`.\n     *\n     * Will automatically use the `serveHost` and `servePath` if they have been\n     * set when registering.\n     */\n    reqUrl(url) {\n        let ret = new URL(url);\n        const serveHost = this.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n        const servePath = this.servePath || this.env[consts_js_1.envKeys.InngestServePath];\n        if (servePath) {\n            ret.pathname = servePath;\n        }\n        if (serveHost) {\n            ret = new URL(ret.pathname + ret.search, serveHost);\n        }\n        return ret;\n    }\n    registerBody({ url, deployId, }) {\n        const body = {\n            url: url.href,\n            deployType: \"ping\",\n            framework: this.frameworkName,\n            appName: this.id,\n            functions: this.configs(url),\n            sdk: `js:v${version_js_1.version}`,\n            v: \"0.1\",\n            deployId: deployId || undefined,\n            capabilities: {\n                trust_probe: \"v1\",\n                connect: \"v1\",\n            },\n            appVersion: this.client.appVersion,\n        };\n        return body;\n    }\n    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url, }) {\n        const registerBody = this.registerBody({ deployId, url });\n        const introspectionBody = await this.introspectionBody({\n            actions,\n            env,\n            signatureValidation,\n            url,\n        });\n        const body = {\n            app_id: this.id,\n            appVersion: this.client.appVersion,\n            capabilities: registerBody.capabilities,\n            env,\n            framework: registerBody.framework,\n            functions: registerBody.functions,\n            inspection: introspectionBody,\n            platform: (0, env_js_1.getPlatformName)(Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), this.env)),\n            sdk_author: \"inngest\",\n            sdk_language: \"\",\n            sdk_version: \"\",\n            sdk: registerBody.sdk,\n            url: registerBody.url,\n        };\n        if (introspectionBody.authentication_succeeded) {\n            body.sdk_language = introspectionBody.sdk_language;\n            body.sdk_version = introspectionBody.sdk_version;\n        }\n        return body;\n    }\n    async introspectionBody({ actions, env, signatureValidation, url, }) {\n        var _a, _b, _c, _d, _e;\n        const registerBody = this.registerBody({\n            url: this.reqUrl(url),\n            deployId: null,\n        });\n        if (!this._mode) {\n            throw new Error(\"No mode set; cannot introspect without mode\");\n        }\n        let introspection = {\n            authentication_succeeded: null,\n            extra: {\n                is_mode_explicit: this._mode.isExplicit,\n            },\n            has_event_key: this.client[\"eventKeySet\"](),\n            has_signing_key: Boolean(this.signingKey),\n            function_count: registerBody.functions.length,\n            mode: this._mode.type,\n            schema_version: \"2024-05-24\",\n        };\n        // Only allow authenticated introspection in Cloud mode, since Dev mode skips\n        // signature validation\n        if (this._mode.type === \"cloud\") {\n            try {\n                const validationResult = await signatureValidation;\n                if (!validationResult.success) {\n                    throw new Error(\"Signature validation failed\");\n                }\n                introspection = Object.assign(Object.assign({}, introspection), { authentication_succeeded: true, api_origin: this.apiBaseUrl, app_id: this.id, capabilities: {\n                        trust_probe: \"v1\",\n                        connect: \"v1\",\n                    }, env, event_api_origin: this.eventApiBaseUrl, event_key_hash: (_a = this.hashedEventKey) !== null && _a !== void 0 ? _a : null, extra: Object.assign(Object.assign({}, introspection.extra), { is_streaming: await this.shouldStream(actions) }), framework: this.frameworkName, sdk_language: \"js\", sdk_version: version_js_1.version, serve_origin: (_b = this.serveHost) !== null && _b !== void 0 ? _b : null, serve_path: (_c = this.servePath) !== null && _c !== void 0 ? _c : null, signing_key_fallback_hash: (_d = this.hashedSigningKeyFallback) !== null && _d !== void 0 ? _d : null, signing_key_hash: (_e = this.hashedSigningKey) !== null && _e !== void 0 ? _e : null });\n            }\n            catch (_f) {\n                // Swallow signature validation error since we'll just return the\n                // unauthenticated introspection\n                introspection = Object.assign(Object.assign({}, introspection), { authentication_succeeded: false });\n            }\n        }\n        return introspection;\n    }\n    async register(url, deployId, getHeaders) {\n        var _a;\n        const body = this.registerBody({ url, deployId });\n        let res;\n        // Whenever we register, we check to see if the dev server is up.  This\n        // is a noop and returns false in production. Clone the URL object to avoid\n        // mutating the property between requests.\n        let registerURL = new URL(this.inngestRegisterUrl.href);\n        const inferredDevMode = this._mode && this._mode.isInferred && this._mode.isDev;\n        if (inferredDevMode) {\n            const host = (0, env_js_1.devServerHost)(this.env);\n            const hasDevServer = await (0, devserver_js_1.devServerAvailable)(host, this.fetch);\n            if (hasDevServer) {\n                registerURL = (0, devserver_js_1.devServerUrl)(host, \"/fn/register\");\n            }\n        }\n        else if ((_a = this._mode) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {\n            registerURL = (0, devserver_js_1.devServerUrl)(this._mode.explicitDevUrl.href, \"/fn/register\");\n        }\n        if (deployId) {\n            registerURL.searchParams.set(consts_js_1.queryKeys.DeployId, deployId);\n        }\n        try {\n            res = await (0, net_js_1.fetchWithAuthFallback)({\n                authToken: this.hashedSigningKey,\n                authTokenFallback: this.hashedSigningKeyFallback,\n                fetch: this.fetch,\n                url: registerURL.href,\n                options: {\n                    method: \"POST\",\n                    body: (0, strings_js_1.stringify)(body),\n                    headers: Object.assign(Object.assign({}, getHeaders()), { [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand }),\n                    redirect: \"follow\",\n                },\n            });\n        }\n        catch (err) {\n            this.log(\"error\", err);\n            return {\n                status: 500,\n                message: `Failed to register${err instanceof Error ? `; ${err.message}` : \"\"}`,\n                modified: false,\n            };\n        }\n        const raw = await res.text();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        let data = {};\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            data = JSON.parse(raw);\n        }\n        catch (err) {\n            this.log(\"warn\", \"Couldn't unpack register response:\", err);\n            let message = \"Failed to register\";\n            if (err instanceof Error) {\n                message += `; ${err.message}`;\n            }\n            message += `; status code: ${res.status}`;\n            return {\n                status: 500,\n                message,\n                modified: false,\n            };\n        }\n        let status;\n        let error;\n        let skipped;\n        let modified;\n        try {\n            ({ status, error, skipped, modified } = registerResSchema.parse(data));\n        }\n        catch (err) {\n            this.log(\"warn\", \"Invalid register response schema:\", err);\n            let message = \"Failed to register\";\n            if (err instanceof Error) {\n                message += `; ${err.message}`;\n            }\n            message += `; status code: ${res.status}`;\n            return {\n                status: 500,\n                message,\n                modified: false,\n            };\n        }\n        // The dev server polls this endpoint to register functions every few\n        // seconds, but we only want to log that we've registered functions if\n        // the function definitions change.  Therefore, we compare the body sent\n        // during registration with the body of the current functions and refuse\n        // to register if the functions are the same.\n        if (!skipped) {\n            this.log(\"debug\", \"registered inngest functions:\", res.status, res.statusText, data);\n        }\n        return { status, message: error, modified };\n    }\n    /**\n     * Given an environment, upsert any missing keys. This is useful in\n     * situations where environment variables are passed directly to handlers or\n     * are otherwise difficult to access during initialization.\n     */\n    upsertKeysFromEnv() {\n        if (this.env[consts_js_1.envKeys.InngestSigningKey]) {\n            if (!this.signingKey) {\n                this.signingKey = String(this.env[consts_js_1.envKeys.InngestSigningKey]);\n            }\n            this.client[\"inngestApi\"].setSigningKey(this.signingKey);\n        }\n        if (this.env[consts_js_1.envKeys.InngestSigningKeyFallback]) {\n            if (!this.signingKeyFallback) {\n                this.signingKeyFallback = String(this.env[consts_js_1.envKeys.InngestSigningKeyFallback]);\n            }\n            this.client[\"inngestApi\"].setSigningKeyFallback(this.signingKeyFallback);\n        }\n        if (!this.client[\"eventKeySet\"]() && this.env[consts_js_1.envKeys.InngestEventKey]) {\n            this.client.setEventKey(String(this.env[consts_js_1.envKeys.InngestEventKey]));\n        }\n        // v2 -> v3 migration warnings\n        if (this.env[consts_js_1.envKeys.InngestDevServerUrl]) {\n            this.log(\"warn\", `Use of ${consts_js_1.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${consts_js_1.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n    }\n    /**\n     * Validate the signature of a request and return the signing key used to\n     * validate it.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async validateSignature(sig, body) {\n        try {\n            // Skip signature validation if requested (used by connect)\n            if (this.skipSignatureValidation) {\n                return { success: true, keyUsed: \"\" };\n            }\n            // Never validate signatures outside of prod. Make sure to check the mode\n            // exists here instead of using nullish coalescing to confirm that the check\n            // has been completed.\n            if (this._mode && !this._mode.isCloud) {\n                return { success: true, keyUsed: \"\" };\n            }\n            // If we're here, we're in production; lack of a signing key is an error.\n            if (!this.signingKey) {\n                // TODO PrettyError\n                throw new Error(`No signing key found in client options or ${consts_js_1.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);\n            }\n            // If we're here, we're in production; lack of a req signature is an error.\n            if (!sig) {\n                // TODO PrettyError\n                throw new Error(`No ${consts_js_1.headerKeys.Signature} provided`);\n            }\n            // Validate the signature\n            return {\n                success: true,\n                keyUsed: new RequestSignature(sig).verifySignature({\n                    body,\n                    allowExpiredSignatures: this.allowExpiredSignatures,\n                    signingKey: this.signingKey,\n                    signingKeyFallback: this.signingKeyFallback,\n                }),\n            };\n        }\n        catch (err) {\n            return { success: false, err: err };\n        }\n    }\n    getResponseSignature(key, body) {\n        const now = Date.now();\n        const mac = (0, net_js_1.signDataWithKey)(body, key, now.toString());\n        return `t=${now}&s=${mac}`;\n    }\n    /**\n     * Log to stdout/stderr if the log level is set to include the given level.\n     * The default log level is `\"info\"`.\n     *\n     * This is an abstraction over `console.log` and will try to use the correct\n     * method for the given log level.  For example, `log(\"error\", \"foo\")` will\n     * call `console.error(\"foo\")`.\n     */\n    log(level, ...args) {\n        const logLevels = [\n            \"debug\",\n            \"info\",\n            \"warn\",\n            \"error\",\n            \"fatal\",\n            \"silent\",\n        ];\n        const logLevelSetting = logLevels.indexOf(this.logLevel);\n        const currentLevel = logLevels.indexOf(level);\n        if (currentLevel >= logLevelSetting) {\n            let logger = console.log;\n            if (Object.prototype.hasOwnProperty.call(console, level)) {\n                logger = console[level];\n            }\n            logger(`${consts_js_1.logPrefix} ${level} -`, ...args);\n        }\n    }\n}\nexports.InngestCommHandler = InngestCommHandler;\nclass RequestSignature {\n    constructor(sig) {\n        _RequestSignature_instances.add(this);\n        const params = new URLSearchParams(sig);\n        this.timestamp = params.get(\"t\") || \"\";\n        this.signature = params.get(\"s\") || \"\";\n        if (!this.timestamp || !this.signature) {\n            // TODO PrettyError\n            throw new Error(`Invalid ${consts_js_1.headerKeys.Signature} provided`);\n        }\n    }\n    hasExpired(allowExpiredSignatures) {\n        if (allowExpiredSignatures) {\n            return false;\n        }\n        const delta = Date.now() - new Date(parseInt(this.timestamp) * 1000).valueOf();\n        return delta > 1000 * 60 * 5;\n    }\n    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures, }) {\n        try {\n            __classPrivateFieldGet(this, _RequestSignature_instances, \"m\", _RequestSignature_verifySignature).call(this, { body, signingKey, allowExpiredSignatures });\n            return signingKey;\n        }\n        catch (err) {\n            if (!signingKeyFallback) {\n                throw err;\n            }\n            __classPrivateFieldGet(this, _RequestSignature_instances, \"m\", _RequestSignature_verifySignature).call(this, {\n                body,\n                signingKey: signingKeyFallback,\n                allowExpiredSignatures,\n            });\n            return signingKeyFallback;\n        }\n    }\n}\n_RequestSignature_instances = new WeakSet(), _RequestSignature_verifySignature = function _RequestSignature_verifySignature({ body, signingKey, allowExpiredSignatures, }) {\n    if (this.hasExpired(allowExpiredSignatures)) {\n        // TODO PrettyError\n        throw new Error(\"Signature has expired\");\n    }\n    const mac = (0, net_js_1.signDataWithKey)(body, signingKey, this.timestamp);\n    if (mac !== this.signature) {\n        // TODO PrettyError\n        throw new Error(\"Invalid signature\");\n    }\n};\n//# sourceMappingURL=InngestCommHandler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixnQ0FBZ0MsbUJBQU8sQ0FBQywyRUFBTztBQUMvQyxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsd0ZBQTRCO0FBQzlELG9CQUFvQixtQkFBTyxDQUFDLDRFQUFzQjtBQUNsRCx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBeUI7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsd0VBQW9CO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQXlCO0FBQ3hELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyxnRkFBd0I7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQywwREFBYTtBQUN4QyxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBZTtBQUM1Qyw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBaUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOEJBQThCO0FBQ2hGLGlDQUFpQyx1QkFBdUI7QUFDeEQseUNBQXlDLGlCQUFpQjtBQUMxRCxZQUFZO0FBQ1o7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCLGdIQUFnSDtBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQ0FBK0MsSUFBSTtBQUNuRCxxREFBcUQsVUFBVSxRQUFRLGlDQUFpQztBQUN4RyxhQUFhLElBQUk7QUFDakIsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBLDhEQUE4RCxHQUFHLEdBQUc7QUFDcEU7QUFDQSxhQUFhO0FBQ2IsaURBQWlEO0FBQ2pELFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CLGdCQUFnQixnQkFBZ0I7QUFDOUc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3QkFBd0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CLGdCQUFnQiwrQkFBK0I7QUFDcEk7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsOEJBQThCO0FBQ3BGLHFDQUFxQyx1QkFBdUI7QUFDNUQsNkNBQTZDLGlCQUFpQjtBQUM5RCxnQkFBZ0I7QUFDaEI7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseUJBQXlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYix3REFBd0Qsb0NBQW9DO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFFBQVE7QUFDeEUseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsT0FBTztBQUNyRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVUsK0ZBQStGO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVUsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUZBQXlGO0FBQ2xIO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDBIQUEwSCxTQUFTO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDJHQUEyRztBQUNoSyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwrREFBK0QsMENBQTBDLFVBQVU7QUFDbkgsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsb0NBQW9DO0FBQ3pGLGtEQUFrRCx1RUFBdUU7QUFDekgsd0NBQXdDO0FBQ3hDLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFvRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usb0NBQW9DO0FBQ3BHO0FBQ0Esb0dBQW9HO0FBQ3BHLDZEQUE2RDtBQUM3RDtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGdFQUFnRSxvQ0FBb0M7QUFDcEc7QUFDQSxvR0FBb0c7QUFDcEcsNkRBQTZELFVBQVU7QUFDdkU7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx3Q0FBd0MsMkJBQTJCO0FBQ25FLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsZ0VBQWdFLG9DQUFvQztBQUNwRztBQUNBLG9HQUFvRztBQUNwRyw2REFBNkQsVUFBVTtBQUN2RTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHdDQUF3QywyQkFBMkI7QUFDbkUscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGLGlFQUFpRSxVQUFVLE1BQU0sT0FBTztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFtRDtBQUNsRixpREFBaUQsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlDQUF5QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsb0JBQW9CO0FBQ2xGO0FBQ0E7QUFDQSxxQkFBcUIsc0tBQXNLLDBCQUEwQixnREFBZ0QsMGFBQTBhO0FBQy9xQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxvQkFBb0IsaUNBQWlDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1CQUFtQiwwRUFBMEU7QUFDeEo7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCLEVBQUUsWUFBWSxPQUFPO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRSxZQUFZO0FBQzVDO0FBQ0EsMEJBQTBCLGVBQWUsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFLFlBQVk7QUFDNUM7QUFDQSwwQkFBMEIsZUFBZSxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlDQUF5QywyQkFBMkIsYUFBYSxvQ0FBb0M7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSw2RUFBNkUsdUNBQXVDO0FBQ3BIO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxzQ0FBc0Msa0NBQWtDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJLEtBQUssSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUIsRUFBRSxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQStEO0FBQ3JGO0FBQ0EsMkhBQTJILDBDQUEwQztBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCwyQ0FBMkM7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcywgX1JlcXVlc3RTaWduYXR1cmVfdmVyaWZ5U2lnbmF0dXJlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jbm5nZXN0Q29tbUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBTZXJ2ZXJUaW1pbmdfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL1NlcnZlclRpbWluZy5qc1wiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3QgZGV2c2VydmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9kZXZzZXJ2ZXIuanNcIik7XG5jb25zdCBlbnVtX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lbnVtLmpzXCIpO1xuY29uc3QgZW52X2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lbnYuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGZ1bmN0aW9uc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZnVuY3Rpb25zLmpzXCIpO1xuY29uc3QgbmV0X2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9uZXQuanNcIik7XG5jb25zdCBwcm9taXNlc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvcHJvbWlzZXMuanNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0cmVhbS5qc1wiKTtcbmNvbnN0IHN0cmluZ3NfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0cmluZ3MuanNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uL3R5cGVzLmpzXCIpO1xuY29uc3QgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL3ZlcnNpb24uanNcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbi8qKlxuICogQSBzY2hlbWEgZm9yIHRoZSByZXNwb25zZSBmcm9tIElubmdlc3Qgd2hlbiByZWdpc3RlcmluZy5cbiAqL1xuY29uc3QgcmVnaXN0ZXJSZXNTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgc3RhdHVzOiB6b2RfMS56Lm51bWJlcigpLmRlZmF1bHQoMjAwKSxcbiAgICBza2lwcGVkOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLmRlZmF1bHQoZmFsc2UpLFxuICAgIG1vZGlmaWVkOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLmRlZmF1bHQoZmFsc2UpLFxuICAgIGVycm9yOiB6b2RfMS56LnN0cmluZygpLmRlZmF1bHQoXCJTdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZFwiKSxcbn0pO1xuLyoqXG4gKiBgSW5uZ2VzdENvbW1IYW5kbGVyYCBpcyBhIGNsYXNzIGZvciBoYW5kbGluZyBpbmNvbWluZyByZXF1ZXN0cyBmcm9tIElubmdlc3QgKG9yXG4gKiBJbm5nZXN0J3MgdG9vbGluZyBzdWNoIGFzIHRoZSBkZXYgc2VydmVyIG9yIENMSSkgYW5kIHRha2luZyBhcHByb3ByaWF0ZVxuICogYWN0aW9uIGZvciBhbnkgc2VydmVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbGwgaGFuZGxlcnMgKE5leHQuanMsIFJlZHdvb2RKUywgUmVtaXgsIERlbm8gRnJlc2gsIGV0Yy4pIGFyZSBjcmVhdGVkIHVzaW5nXG4gKiB0aGlzIGNsYXNzOyB0aGUgZXhwb3NlZCBgc2VydmVgIGZ1bmN0aW9uIHdpbGwgLSBtb3N0IGNvbW1vbmx5IC0gY3JlYXRlIGFuXG4gKiBpbnN0YW5jZSBvZiBgSW5uZ2VzdENvbW1IYW5kbGVyYCBhbmQgdGhlbiByZXR1cm4gYGluc3RhbmNlLmNyZWF0ZUhhbmRsZXIoKWAuXG4gKlxuICogU2VlIGluZGl2aWR1YWwgcGFyYW1ldGVyIGRldGFpbHMgZm9yIG1vcmUgaW5mb3JtYXRpb24sIG9yIHNlZSB0aGVcbiAqIHNvdXJjZSBjb2RlIGZvciBhbiBleGlzdGluZyBoYW5kbGVyLCBlLmcuXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2lubmdlc3QvaW5uZ2VzdC1qcy9ibG9iL21haW4vc3JjL25leHQudHN9XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogLy8gbXktY3VzdG9tLWhhbmRsZXIudHNcbiAqIGltcG9ydCB7XG4gKiAgIElubmdlc3RDb21tSGFuZGxlcixcbiAqICAgdHlwZSBTZXJ2ZUhhbmRsZXJPcHRpb25zLFxuICogfSBmcm9tIFwiLi9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlclwiO1xuICpcbiAqIGV4cG9ydCBjb25zdCBzZXJ2ZSA9IChvcHRpb25zOiBTZXJ2ZUhhbmRsZXJPcHRpb25zKSA9PiB7XG4gKiAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgSW5uZ2VzdENvbW1IYW5kbGVyKHtcbiAqICAgICBmcmFtZXdvcmtOYW1lOiBcIm15LWN1c3RvbS1oYW5kbGVyXCIsXG4gKiAgICAgLi4ub3B0aW9ucyxcbiAqICAgICBoYW5kbGVyOiAocmVxOiBSZXF1ZXN0KSA9PiB7XG4gKiAgICAgICByZXR1cm4ge1xuICogICAgICAgICBib2R5OiAoKSA9PiByZXEuanNvbigpLFxuICogICAgICAgICBoZWFkZXJzOiAoa2V5KSA9PiByZXEuaGVhZGVycy5nZXQoa2V5KSxcbiAqICAgICAgICAgbWV0aG9kOiAoKSA9PiByZXEubWV0aG9kLFxuICogICAgICAgICB1cmw6ICgpID0+IG5ldyBVUkwocmVxLnVybCwgYGh0dHBzOi8vJHtyZXEuaGVhZGVycy5nZXQoXCJob3N0XCIpIHx8IFwiXCJ9YCksXG4gKiAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiAoeyBib2R5LCBzdGF0dXMsIGhlYWRlcnMgfSkgPT4ge1xuICogICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgeyBzdGF0dXMsIGhlYWRlcnMgfSk7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICB9O1xuICogICAgIH0sXG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIGhhbmRsZXIuY3JlYXRlSGFuZGxlcigpO1xuICogfTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSW5uZ2VzdENvbW1IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcHJpdmF0ZSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSBiZWluZyBzZXJ2ZWQuIFRoaXMgbWFwIGlzIHVzZWRcbiAgICAgICAgICogdG8gZmluZCBhbmQgcmVnaXN0ZXIgZnVuY3Rpb25zIHdoZW4gaW50ZXJhY3Rpbmcgd2l0aCBJbm5nZXN0IENsb3VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbnMgPSB7fTtcbiAgICAgICAgdGhpcy5lbnYgPSAoMCwgZW52X2pzXzEuYWxsUHJvY2Vzc0VudikoKTtcbiAgICAgICAgLy8gU2V0IGlucHV0IG9wdGlvbnMgZGlyZWN0bHkgc28gd2UgY2FuIHJlZmVyZW5jZSB0aGVtIGxhdGVyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogdjIgLT4gdjMgbWlncmF0aW9uIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIHNlcnZlIGhhbmRsZXIgaXMgcGFzc2VkIGEgY2xpZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgaXQnbGwgYmVcbiAgICAgICAgICogc3ByZWFkIGluIHRvIHRoZXNlIG9wdGlvbnMuIFdlIHNob3VsZCBiZSBhYmxlIHRvIGRldGVjdCB0aGlzIGJ5IHBpY2tpbmdcbiAgICAgICAgICogdXAgYSB1bmlxdWUgcHJvcGVydHkgb24gdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJldmVudEtleVwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnN0c19qc18xLmxvZ1ByZWZpeH0gWW91J3ZlIHBhc3NlZCBhbiBJbm5nZXN0IGNsaWVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8geW91ciBzZXJ2ZSBoYW5kbGVyLiBUaGlzIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gdjM7IHBsZWFzZSBwYXNzIHRoZSBJbm5nZXN0IGNsaWVudCBhcyB0aGUgXFxgY2xpZW50XFxgIHByb3BlcnR5IG9mIGFuIG9wdGlvbnMgb2JqZWN0IGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYW1ld29ya05hbWUgPSBvcHRpb25zLmZyYW1ld29ya05hbWU7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG4gICAgICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y29uc3RzX2pzXzEubG9nUHJlZml4fSBUaGUgXFxgaWRcXGAgc2VydmUgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkIHx8IHRoaXMuY2xpZW50LmlkO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBvcHRpb25zLmhhbmRsZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlIGEgaGlkZGVuIG9wdGlvbiB0byBhbGxvdyBleHBpcmVkIHNpZ25hdHVyZXMgdG8gYmUgYWNjZXB0ZWQgZHVyaW5nXG4gICAgICAgICAqIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93RXhwaXJlZFNpZ25hdHVyZXMgPSBCb29sZWFuKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgKF9hID0gYXJndW1lbnRzW1wiMFwiXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9fdGVzdGluZ0FsbG93RXhwaXJlZFNpZ25hdHVyZXMpO1xuICAgICAgICAvLyBFbnN1cmUgd2UgZmlsdGVyIGFueSB1bmRlZmluZWQgZnVuY3Rpb25zIGluIGNhc2Ugb2YgbWlzc2luZyBpbXBvcnRzLlxuICAgICAgICB0aGlzLnJhd0ZucyA9IG9wdGlvbnMuZnVuY3Rpb25zLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgaWYgKHRoaXMucmF3Rm5zLmxlbmd0aCAhPT0gb3B0aW9ucy5mdW5jdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNvbWUgZnVuY3Rpb25zIHBhc3NlZCB0byBzZXJ2ZSgpIGFyZSB1bmRlZmluZWQgYW5kIG1pc2NvbmZpZ3VyZWQuICBQbGVhc2UgY2hlY2sgeW91ciBpbXBvcnRzLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm5zID0gdGhpcy5yYXdGbnMucmVkdWNlKChhY2MsIGZuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdzID0gZm5bXCJnZXRDb25maWdcIl0oe1xuICAgICAgICAgICAgICAgIGJhc2VVcmw6IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpLFxuICAgICAgICAgICAgICAgIGFwcFByZWZpeDogdGhpcy5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm5zID0gY29uZmlncy5yZWR1Y2UoKGFjYywgeyBpZCB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2lkXTogeyBmbiwgb25GYWlsdXJlOiBCb29sZWFuKGluZGV4KSB9IH0pO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKCh7IGlkIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIElEIFwiJHtpZH1cIjsgcGxlYXNlIGNoYW5nZSBhIGZ1bmN0aW9uJ3MgbmFtZSBvciBwcm92aWRlIGFuIGV4cGxpY2l0IElEIHRvIGF2b2lkIGNvbmZsaWN0cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIGZucyk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy5pbm5nZXN0UmVnaXN0ZXJVcmwgPSBuZXcgVVJMKFwiL2ZuL3JlZ2lzdGVyXCIsIHRoaXMuYXBpQmFzZVVybCk7XG4gICAgICAgIHRoaXMuc2lnbmluZ0tleSA9IG9wdGlvbnMuc2lnbmluZ0tleTtcbiAgICAgICAgdGhpcy5zaWduaW5nS2V5RmFsbGJhY2sgPSBvcHRpb25zLnNpZ25pbmdLZXlGYWxsYmFjaztcbiAgICAgICAgdGhpcy5fc2VydmVIb3N0ID0gb3B0aW9ucy5zZXJ2ZUhvc3QgfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVIb3N0XTtcbiAgICAgICAgdGhpcy5fc2VydmVQYXRoID0gb3B0aW9ucy5zZXJ2ZVBhdGggfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVQYXRoXTtcbiAgICAgICAgdGhpcy5za2lwU2lnbmF0dXJlVmFsaWRhdGlvbiA9IG9wdGlvbnMuc2tpcFNpZ25hdHVyZVZhbGlkYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMb2dMZXZlbCA9IFwiaW5mb1wiO1xuICAgICAgICB0aGlzLmxvZ0xldmVsID0gem9kXzEuelxuICAgICAgICAgICAgLmVudW0odHlwZXNfanNfMS5sb2dMZXZlbHMpXG4gICAgICAgICAgICAuZGVmYXVsdChkZWZhdWx0TG9nTGV2ZWwpXG4gICAgICAgICAgICAuY2F0Y2goKGN0eCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ3YXJuXCIsIGBVbmtub3duIGxvZyBsZXZlbCBwYXNzZWQ6ICR7U3RyaW5nKGN0eC5pbnB1dCl9OyBkZWZhdWx0aW5nIHRvICR7ZGVmYXVsdExvZ0xldmVsfWApO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dMZXZlbDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5wYXJzZShvcHRpb25zLmxvZ0xldmVsIHx8IHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdExvZ0xldmVsXSk7XG4gICAgICAgIGlmICh0aGlzLmxvZ0xldmVsID09PSBcImRlYnVnXCIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYGRlYnVnYCBpcyBhbiBvbGQgbGlicmFyeTsgc29tZXRpbWVzIGl0cyBydW50aW1lIGRldGVjdGlvbiBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgICAqIGZvciBuZXdlciBwYWlyaW5ncyBvZiBmcmFtZXdvcmsvcnVudGltZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBPbmUgc2lsbHkgc3ltcHRvbSBvZiB0aGlzIGlzIHRoYXQgYERlYnVnKClgIHJldHVybnMgYW4gYW5vbnltb3VzXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiB3aXRoIG5vIGV4dHJhIHByb3BlcnRpZXMgaW5zdGVhZCBvZiBhIGBEZWJ1Z2dlcmAgaW5zdGFuY2UgaWZcbiAgICAgICAgICAgICAqIHRoZSB3cm9uZyBjb2RlIGlzIGNvbnN1bWVkIGZvbGxvd2luZyBhIGJhZCBkZXRlY3Rpb24uIFRoaXMgcmVzdWx0cyBpblxuICAgICAgICAgICAgICogdGhlIGZvbGxvd2luZyBgLmVuYWJsZSgpYCBjYWxsIGZhaWxpbmcsIHNvIHdlIGp1c3QgdHJ5IGNhcmVmdWxseSB0b1xuICAgICAgICAgICAgICogZW5hYmxlIGl0IGhlcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChkZWJ1Z18xLmRlZmF1bHQuZW5hYmxlICYmIHR5cGVvZiBkZWJ1Z18xLmRlZmF1bHQuZW5hYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z18xLmRlZmF1bHQuZW5hYmxlKGAke2NvbnN0c19qc18xLmRlYnVnUHJlZml4fToqYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdFN0cmVhbWluZ09wdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cmVhbWluZyA9IHpvZF8xLnpcbiAgICAgICAgICAgIC51bmlvbihbem9kXzEuei5lbnVtKFtcImFsbG93XCIsIFwiZm9yY2VcIl0pLCB6b2RfMS56LmxpdGVyYWwoZmFsc2UpXSlcbiAgICAgICAgICAgIC5kZWZhdWx0KGRlZmF1bHRTdHJlYW1pbmdPcHRpb24pXG4gICAgICAgICAgICAuY2F0Y2goKGN0eCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ3YXJuXCIsIGBVbmtub3duIHN0cmVhbWluZyBvcHRpb24gcGFzc2VkOiAke1N0cmluZyhjdHguaW5wdXQpfTsgZGVmYXVsdGluZyB0byAke1N0cmluZyhkZWZhdWx0U3RyZWFtaW5nT3B0aW9uKX1gKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3RyZWFtaW5nT3B0aW9uO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnBhcnNlKG9wdGlvbnMuc3RyZWFtaW5nIHx8IHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFN0cmVhbWluZ10pO1xuICAgICAgICB0aGlzLmZldGNoID0gb3B0aW9ucy5mZXRjaCA/ICgwLCBlbnZfanNfMS5nZXRGZXRjaCkob3B0aW9ucy5mZXRjaCkgOiB0aGlzLmNsaWVudFtcImZldGNoXCJdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEFQSSBiYXNlIFVSTCBmb3IgdGhlIElubmdlc3QgQVBJLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGdldHRlciB0byBlbmNvdXJhZ2UgY2hlY2tpbmcgdGhlIGVudmlyb25tZW50IGZvciB0aGUgQVBJIGJhc2UgVVJMXG4gICAgICogZWFjaCB0aW1lIGl0J3MgYWNjZXNzZWQsIGFzIGl0IG1heSBjaGFuZ2UgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYXBpQmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vcHRpb25zLmJhc2VVcmwgfHxcbiAgICAgICAgICAgIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEFwaUJhc2VVcmxdIHx8XG4gICAgICAgICAgICB0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RCYXNlVXJsXSB8fFxuICAgICAgICAgICAgdGhpcy5jbGllbnQuYXBpQmFzZVVybCB8fFxuICAgICAgICAgICAgY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBldmVudCBBUEkgYmFzZSBVUkwgZm9yIHRoZSBJbm5nZXN0IEFQSS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBnZXR0ZXIgdG8gZW5jb3VyYWdlIGNoZWNraW5nIHRoZSBlbnZpcm9ubWVudCBmb3IgdGhlIGV2ZW50IEFQSVxuICAgICAqIGJhc2UgVVJMIGVhY2ggdGltZSBpdCdzIGFjY2Vzc2VkLCBhcyBpdCBtYXkgY2hhbmdlIGR1cmluZyBleGVjdXRpb24uXG4gICAgICovXG4gICAgZ2V0IGV2ZW50QXBpQmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vcHRpb25zLmJhc2VVcmwgfHxcbiAgICAgICAgICAgIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEV2ZW50QXBpQmFzZVVybF0gfHxcbiAgICAgICAgICAgIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEJhc2VVcmxdIHx8XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5ldmVudEJhc2VVcmwgfHxcbiAgICAgICAgICAgIGNvbnN0c19qc18xLmRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGhvc3QgdXNlZCB0byBhY2Nlc3MgdGhlIElubmdlc3Qgc2VydmUgZW5kcG9pbnQsIGUuZy46XG4gICAgICpcbiAgICAgKiAgICAgXCJodHRwczovL215YXBwLmNvbVwiXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgbGlicmFyeSB3aWxsIHRyeSB0byBpbmZlciB0aGlzIHVzaW5nIHJlcXVlc3QgZGV0YWlscyBzdWNoXG4gICAgICogYXMgdGhlIFwiSG9zdFwiIGhlYWRlciBhbmQgcmVxdWVzdCBwYXRoLCBidXQgc29tZXRpbWVzIHRoaXMgaXNuJ3QgcG9zc2libGVcbiAgICAgKiAoZS5nLiB3aGVuIHJ1bm5pbmcgaW4gYSBtb3JlIGNvbnRyb2xsZWQgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQVdTIExhbWJkYSBvclxuICAgICAqIHdoZW4gZGVhbGluZyB3aXRoIHByb3hpZXMvcmVkaXJlY3RzKS5cbiAgICAgKlxuICAgICAqIFByb3ZpZGUgdGhlIGN1c3RvbSBob3N0bmFtZSBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZSBwYXRoIGlzIHJlcG9ydGVkXG4gICAgICogY29ycmVjdGx5IHdoZW4gcmVnaXN0ZXJpbmcgZnVuY3Rpb25zIHdpdGggSW5uZ2VzdC5cbiAgICAgKlxuICAgICAqIFRvIGFsc28gcHJvdmlkZSBhIGN1c3RvbSBwYXRoLCB1c2UgYHNlcnZlUGF0aGAuXG4gICAgICovXG4gICAgZ2V0IHNlcnZlSG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlSG9zdCB8fCB0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTZXJ2ZUhvc3RdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgSW5uZ2VzdCBzZXJ2ZSBlbmRwb2ludC4gZS5nLjpcbiAgICAgKlxuICAgICAqICAgICBcIi9zb21lL2xvbmcvcGF0aC90by9pbm5nZXN0L2VuZHBvaW50XCJcbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBsaWJyYXJ5IHdpbGwgdHJ5IHRvIGluZmVyIHRoaXMgdXNpbmcgcmVxdWVzdCBkZXRhaWxzIHN1Y2hcbiAgICAgKiBhcyB0aGUgXCJIb3N0XCIgaGVhZGVyIGFuZCByZXF1ZXN0IHBhdGgsIGJ1dCBzb21ldGltZXMgdGhpcyBpc24ndCBwb3NzaWJsZVxuICAgICAqIChlLmcuIHdoZW4gcnVubmluZyBpbiBhIG1vcmUgY29udHJvbGxlZCBlbnZpcm9ubWVudHMgc3VjaCBhcyBBV1MgTGFtYmRhIG9yXG4gICAgICogd2hlbiBkZWFsaW5nIHdpdGggcHJveGllcy9yZWRpcmVjdHMpLlxuICAgICAqXG4gICAgICogUHJvdmlkZSB0aGUgY3VzdG9tIHBhdGggKGV4Y2x1ZGluZyB0aGUgaG9zdG5hbWUpIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICogcGF0aCBpcyByZXBvcnRlZCBjb3JyZWN0bHkgd2hlbiByZWdpc3RlcmluZyBmdW5jdGlvbnMgd2l0aCBJbm5nZXN0LlxuICAgICAqXG4gICAgICogVG8gYWxzbyBwcm92aWRlIGEgY3VzdG9tIGhvc3RuYW1lLCB1c2UgYHNlcnZlSG9zdGAuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgZ2V0dGVyIHRvIGVuY291cmFnZSBjaGVja2luZyB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBzZXJ2ZSBwYXRoXG4gICAgICogZWFjaCB0aW1lIGl0J3MgYWNjZXNzZWQsIGFzIGl0IG1heSBjaGFuZ2UgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgc2VydmVQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVQYXRoIHx8IHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNlcnZlUGF0aF07XG4gICAgfVxuICAgIGdldCBoYXNoZWRFdmVudEtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudFtcImV2ZW50S2V5XCJdIHx8IHRoaXMuY2xpZW50W1wiZXZlbnRLZXlcIl0gPT09IGNvbnN0c19qc18xLmR1bW15RXZlbnRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBzdHJpbmdzX2pzXzEuaGFzaEV2ZW50S2V5KSh0aGlzLmNsaWVudFtcImV2ZW50S2V5XCJdKTtcbiAgICB9XG4gICAgLy8gaGFzaGVkU2lnbmluZ0tleSBjcmVhdGVzIGEgc2hhMjU2IGNoZWNrc3VtIG9mIHRoZSBzaWduaW5nIGtleSB3aXRoIHRoZVxuICAgIC8vIHNhbWUgc2lnbmluZyBrZXkgcHJlZml4LlxuICAgIGdldCBoYXNoZWRTaWduaW5nS2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluZ0tleSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfanNfMS5oYXNoU2lnbmluZ0tleSkodGhpcy5zaWduaW5nS2V5KTtcbiAgICB9XG4gICAgZ2V0IGhhc2hlZFNpZ25pbmdLZXlGYWxsYmFjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25pbmdLZXlGYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfanNfMS5oYXNoU2lnbmluZ0tleSkodGhpcy5zaWduaW5nS2V5RmFsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYGJvb2xlYW5gIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgaGFuZGxlciB3aWxsIHN0cmVhbSByZXNwb25zZXNcbiAgICAgKiBvciBub3QuIFRha2VzIGludG8gYWNjb3VudCB0aGUgdXNlcidzIHByZWZlcmVuY2UgYW5kIHRoZSBwbGF0Zm9ybSdzXG4gICAgICogY2FwYWJpbGl0aWVzLlxuICAgICAqL1xuICAgIGFzeW5jIHNob3VsZFN0cmVhbShhY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHJhd1Byb2JlID0gYXdhaXQgYWN0aW9ucy5xdWVyeVN0cmluZ1dpdGhEZWZhdWx0cyhcInRlc3RpbmcgZm9yIHByb2JlXCIsIGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5Qcm9iZSk7XG4gICAgICAgIGlmIChyYXdQcm9iZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbXVzdCBiZSBhYmxlIHRvIHN0cmVhbSByZXNwb25zZXMgdG8gY29udGludWUuXG4gICAgICAgIGlmICghYWN0aW9ucy50cmFuc2Zvcm1TdHJlYW1pbmdSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBmb3JjZWQgc3RyZWFtaW5nLCB3ZSBzaG91bGQgYWx3YXlzIHN0cmVhbS5cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtaW5nID09PSBcImZvcmNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBhbGxvd2VkIHN0cmVhbWluZywgd2Ugc2hvdWxkIHN0cmVhbSBpZiB0aGUgcGxhdGZvcm1cbiAgICAgICAgLy8gc3VwcG9ydHMgaXQuXG4gICAgICAgIHJldHVybiAodGhpcy5zdHJlYW1pbmcgPT09IFwiYWxsb3dcIiAmJlxuICAgICAgICAgICAgKDAsIGVudl9qc18xLnBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmcpKHRoaXMuZnJhbWV3b3JrTmFtZSwgdGhpcy5lbnYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNyZWF0ZUhhbmRsZXJgIHNob3VsZCBiZSB1c2VkIHRvIHJldHVybiBhIHR5cGUtZXF1aXZhbGVudCB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIGBoYW5kbGVyYCBzcGVjaWZpZWQgZHVyaW5nIGluc3RhbnRpYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIC8vIG15LWN1c3RvbS1oYW5kbGVyLnRzXG4gICAgICogaW1wb3J0IHtcbiAgICAgKiAgIElubmdlc3RDb21tSGFuZGxlcixcbiAgICAgKiAgIHR5cGUgU2VydmVIYW5kbGVyT3B0aW9ucyxcbiAgICAgKiB9IGZyb20gXCIuL2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyXCI7XG4gICAgICpcbiAgICAgKiBleHBvcnQgY29uc3Qgc2VydmUgPSAob3B0aW9uczogU2VydmVIYW5kbGVyT3B0aW9ucykgPT4ge1xuICAgICAqICAgY29uc3QgaGFuZGxlciA9IG5ldyBJbm5nZXN0Q29tbUhhbmRsZXIoe1xuICAgICAqICAgICBmcmFtZXdvcmtOYW1lOiBcIm15LWN1c3RvbS1oYW5kbGVyXCIsXG4gICAgICogICAgIC4uLm9wdGlvbnMsXG4gICAgICogICAgIGhhbmRsZXI6IChyZXE6IFJlcXVlc3QpID0+IHtcbiAgICAgKiAgICAgICByZXR1cm4ge1xuICAgICAqICAgICAgICAgYm9keTogKCkgPT4gcmVxLmpzb24oKSxcbiAgICAgKiAgICAgICAgIGhlYWRlcnM6IChrZXkpID0+IHJlcS5oZWFkZXJzLmdldChrZXkpLFxuICAgICAqICAgICAgICAgbWV0aG9kOiAoKSA9PiByZXEubWV0aG9kLFxuICAgICAqICAgICAgICAgdXJsOiAoKSA9PiBuZXcgVVJMKHJlcS51cmwsIGBodHRwczovLyR7cmVxLmhlYWRlcnMuZ2V0KFwiaG9zdFwiKSB8fCBcIlwifWApLFxuICAgICAqICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6ICh7IGJvZHksIHN0YXR1cywgaGVhZGVycyB9KSA9PiB7XG4gICAgICogICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgeyBzdGF0dXMsIGhlYWRlcnMgfSk7XG4gICAgICogICAgICAgICB9LFxuICAgICAqICAgICAgIH07XG4gICAgICogICAgIH0sXG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIGhhbmRsZXIuY3JlYXRlSGFuZGxlcigpO1xuICAgICAqIH07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JlYXRlSGFuZGxlcigpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSBuZXcgU2VydmVyVGltaW5nX2pzXzEuU2VydmVyVGltaW5nKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZWQgZm9yIHRlc3RpbmcsIGFsbG93IHNldHRpbmcgYWN0aW9uIG92ZXJyaWRlcyBleHRlcm5hbGx5IHdoZW5cbiAgICAgICAgICAgICAqIGNhbGxpbmcgdGhlIGhhbmRsZXIuIEFsd2F5cyBzZWFyY2ggdGhlIGZpbmFsIGFyZ3VtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uT3ZlcnJpZGVzID0gdHlwZW9mIGxhc3RBcmcgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBsYXN0QXJnICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgXCJhY3Rpb25PdmVycmlkZXNcIiBpbiBsYXN0QXJnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGxhc3RBcmdbXCJhY3Rpb25PdmVycmlkZXNcIl0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBsYXN0QXJnW1wiYWN0aW9uT3ZlcnJpZGVzXCJdICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBsYXN0QXJnW1wiYWN0aW9uT3ZlcnJpZGVzXCJdXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgcHVycG9zZWZ1bGx5IGBhd2FpdGAgdGhlIGhhbmRsZXIsIGFzIGl0IGNvdWxkIGJlIGVpdGhlciBzeW5jIG9yXG4gICAgICAgICAgICAgKiBhc3luYy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcmF3QWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGF3YWl0IHRpbWVyXG4gICAgICAgICAgICAgICAgLndyYXAoXCJoYW5kbGVyXCIsICgpID0+IHRoaXMuaGFuZGxlciguLi5hcmdzKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKDAsIGVycm9yc19qc18xLnJldGhyb3dFcnJvcikoXCJTZXJ2ZSBoYW5kbGVyIGZhaWxlZCB0byBydW5cIikpKSksIGFjdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcCBvdmVyIGV2ZXJ5IGBhY3Rpb25gIGluIGByYXdBY3Rpb25zYCBhbmQgY3JlYXRlIGEgbmV3IGBhY3Rpb25zYFxuICAgICAgICAgICAgICogb2JqZWN0IHdoZXJlIGVhY2ggZnVuY3Rpb24gaXMgc2FmZWx5IHByb21pc2lmaWVkIHdpdGggZWFjaCBhY2Nlc3NcbiAgICAgICAgICAgICAqIHJlcXVpcmluZyBhIHJlYXNvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGhlbHBzIHVzIHByb3ZpZGUgaGlnaCBxdWFsaXR5IGVycm9ycyBhYm91dCB3aGF0J3MgZ29pbmcgd3JvbmcgZm9yXG4gICAgICAgICAgICAgKiBlYWNoIGFjY2VzcyB3aXRob3V0IGhhdmluZyB0byB3cmFwIGV2ZXJ5IGFjY2VzcyBpbiBhIHRyeS9jYXRjaC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzaWZpZWRBY3Rpb25zID0gT2JqZWN0LmVudHJpZXMocmF3QWN0aW9ucykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtrZXldOiAocmVhc29uLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNZXNzYWdlID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBGYWlsZWQgY2FsbGluZyBcXGAke2tleX1cXGAgZnJvbSBzZXJ2ZSBoYW5kbGVyYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiIHdoZW4gXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSAoKSA9PiB2YWx1ZSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKGZuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoMCwgZXJyb3JzX2pzXzEucmV0aHJvd0Vycm9yKShlcnJNZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFwcGVkIHByb21pc2lmaWVkIGhhbmRsZXJzIGZyb20gdXNlcmxhbmQgYHNlcnZlKClgIGZ1bmN0aW9uIG1peGVkIGluXG4gICAgICAgICAgICAgKiB3aXRoIHNvbWUgaGVscGVycy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9taXNpZmllZEFjdGlvbnMpLCB7IHF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzOiBhc3luYyAocmVhc29uLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCBhY3Rpb25zLnVybChyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSAoYXdhaXQgKChfYSA9IGFjdGlvbnMucXVlcnlTdHJpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFjdGlvbnMsIHJlYXNvbiwga2V5LCB1cmwpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9IH0pLCBhY3Rpb25PdmVycmlkZXMpO1xuICAgICAgICAgICAgY29uc3QgW2VudiwgZXhwZWN0ZWRTZXJ2ZXJLaW5kXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAoX2EgPSBhY3Rpb25zLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWN0aW9ucywgXCJzdGFydGluZyB0byBoYW5kbGUgcmVxdWVzdFwiKSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zLmhlYWRlcnMoXCJjaGVja2luZyBleHBlY3RlZCBzZXJ2ZXIga2luZFwiLCBjb25zdHNfanNfMS5oZWFkZXJLZXlzLklubmdlc3RTZXJ2ZXJLaW5kKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gQWx3YXlzIG1ha2Ugc3VyZSB0byBtZXJnZSB3aGF0ZXZlciBlbnYgd2UndmUgYmVlbiBnaXZlbiB3aXRoXG4gICAgICAgICAgICAvLyBgcHJvY2Vzcy5lbnZgOyBzb21lIHBsYXRmb3JtcyBtYXkgbm90IHByb3ZpZGUgYWxsIHRoZSBuZWNlc3NhcnlcbiAgICAgICAgICAgIC8vIGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBtYXkgdXNlIHR3byBzb3VyY2VzLlxuICAgICAgICAgICAgdGhpcy5lbnYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBlbnZfanNfMS5hbGxQcm9jZXNzRW52KSgpKSwgZW52KTtcbiAgICAgICAgICAgIGNvbnN0IGdldElubmdlc3RIZWFkZXJzID0gKCkgPT4gKDAsIGVudl9qc18xLmlubmdlc3RIZWFkZXJzKSh7XG4gICAgICAgICAgICAgICAgZW52OiB0aGlzLmVudixcbiAgICAgICAgICAgICAgICBmcmFtZXdvcms6IHRoaXMuZnJhbWV3b3JrTmFtZSxcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkU2VydmVyS2luZDogZXhwZWN0ZWRTZXJ2ZXJLaW5kIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleHRyYXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJTZXJ2ZXItVGltaW5nXCI6IHRpbWVyLmdldEhlYWRlcigpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFzc3VtZWRNb2RlID0gKDAsIGVudl9qc18xLmdldE1vZGUpKHsgZW52OiB0aGlzLmVudiwgY2xpZW50OiB0aGlzLmNsaWVudCB9KTtcbiAgICAgICAgICAgIGlmIChhc3N1bWVkTW9kZS5pc0V4cGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IGFzc3VtZWRNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVJc1Byb2QgPSBhd2FpdCAoKF9iID0gYWN0aW9ucy5pc1Byb2R1Y3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGFjdGlvbnMsIFwic3RhcnRpbmcgdG8gaGFuZGxlIHJlcXVlc3RcIikpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VydmVJc1Byb2QgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBuZXcgZW52X2pzXzEuTW9kZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBzZXJ2ZUlzUHJvZCA/IFwiY2xvdWRcIiA6IFwiZGV2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V4cGxpY2l0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gYXNzdW1lZE1vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cHNlcnRLZXlzRnJvbUVudigpO1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kUCA9IGFjdGlvbnMubWV0aG9kKFwic3RhcnRpbmcgdG8gaGFuZGxlIHJlcXVlc3RcIik7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQcm9taXNlcyA9IFtcbiAgICAgICAgICAgICAgICBjb25zdHNfanNfMS5oZWFkZXJLZXlzLlRyYWNlUGFyZW50LFxuICAgICAgICAgICAgICAgIGNvbnN0c19qc18xLmhlYWRlcktleXMuVHJhY2VTdGF0ZSxcbiAgICAgICAgICAgIF0ubWFwKGFzeW5jIChoZWFkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGFjdGlvbnMuaGVhZGVycyhgZmV0Y2hpbmcgJHtoZWFkZXJ9IGZvciBmb3J3YXJkaW5nYCwgaGVhZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFkZXIsIHZhbHVlIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBhd2FpdCBhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmhlYWRlcnMoXCJjaGVja2luZyBzaWduYXR1cmUgZm9yIHJlcXVlc3RcIiwgY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Db250ZW50TGVuZ3RoKVxuICAgICAgICAgICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIGNvbnN0IFtzaWduYXR1cmUsIG1ldGhvZCwgYm9keV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAuaGVhZGVycyhcImNoZWNraW5nIHNpZ25hdHVyZSBmb3IgcmVxdWVzdFwiLCBjb25zdHNfanNfMS5oZWFkZXJLZXlzLlNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGhlYWRlclNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyU2lnbmF0dXJlICE9PSBudWxsICYmIGhlYWRlclNpZ25hdHVyZSAhPT0gdm9pZCAwID8gaGVhZGVyU2lnbmF0dXJlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG1ldGhvZFAsXG4gICAgICAgICAgICAgICAgbWV0aG9kUC50aGVuKChtZXRob2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJQT1NUXCIgfHwgbWV0aG9kID09PSBcIlBVVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGJlY2F1c2UgcmVxLmpzb24oKSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnMuYm9keShgY2hlY2tpbmcgYm9keSBmb3IgcmVxdWVzdCBzaWduaW5nIGFzIG1ldGhvZCBpcyAke21ldGhvZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlVmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVTaWduYXR1cmUoc2lnbmF0dXJlLCBib2R5KTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnNUb0ZvcndhcmRQID0gUHJvbWlzZS5hbGwoaGVhZGVyUHJvbWlzZXMpLnRoZW4oKGZldGNoZWRIZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoZWRIZWFkZXJzLnJlZHVjZSgoYWNjLCB7IGhlYWRlciwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1toZWFkZXJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvblJlcyA9IHRpbWVyLndyYXAoXCJhY3Rpb25cIiwgKCkgPT4gdGhpcy5oYW5kbGVBY3Rpb24oe1xuICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgdGltZXIsXG4gICAgICAgICAgICAgICAgZ2V0SW5uZ2VzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVxQXJnczogYXJncyxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzVG9Gb3J3YXJkUCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJlcGFyZXMgYW4gYWN0aW9uIHJlc3BvbnNlIGJ5IG1lcmdpbmcgcmV0dXJuZWQgZGF0YSB0byBwcm92aWRlXG4gICAgICAgICAgICAgKiB0cmFpbGluZyBpbmZvcm1hdGlvbiBzdWNoIGFzIGBTZXJ2ZXItVGltaW5nYCBoZWFkZXJzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEl0IHNob3VsZCBhbHdheXMgcHJpb3JpdGl6ZSB0aGUgaGVhZGVycyByZXR1cm5lZCBieSB0aGUgYWN0aW9uLCBhcyB0aGV5XG4gICAgICAgICAgICAgKiBtYXkgY29udGFpbiBpbXBvcnRhbnQgaW5mb3JtYXRpb24gc3VjaCBhcyBgQ29udGVudC1UeXBlYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZUFjdGlvblJlcyA9IGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldElubmdlc3RIZWFkZXJzKCkpLCAoYXdhaXQgaGVhZGVyc1RvRm9yd2FyZFApKSwgcmVzLmhlYWRlcnMpLCAocmVzLnZlcnNpb24gPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlJlcXVlc3RWZXJzaW9uXTogKChfYSA9IHJlcy52ZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBhd2FpdCBzaWduYXR1cmVWYWxpZGF0aW9uLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcyB8fCAhcmVzdWx0LmtleVVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVzcG9uc2VTaWduYXR1cmUocmVzdWx0LmtleVVzZWQsIHJlcy5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byBzaWduLCByZXR1biBhIDUwMCB3aXRoIHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzKSwgeyBoZWFkZXJzLCBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShlcnIpKSwgc3RhdHVzOiA1MDAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlNpZ25hdHVyZV0gPSBzaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcyksIHsgaGVhZGVycyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5zaG91bGRTdHJlYW0oYWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRob2QgPSBhd2FpdCBhY3Rpb25zLm1ldGhvZChcInN0YXJ0aW5nIHN0cmVhbWluZyByZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN0cmVhbSwgZmluYWxpemUgfSA9IGF3YWl0ICgwLCBzdHJlYW1fanNfMS5jcmVhdGVTdHJlYW0pKCk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBFcnJvcnMgYXJlIGhhbmRsZWQgYnkgYGhhbmRsZUFjdGlvbmAgaGVyZSB0byBlbnN1cmUgdGhhdCBhblxuICAgICAgICAgICAgICAgICAgICAgKiBhcHByb3ByaWF0ZSByZXNwb25zZSBpcyBhbHdheXMgZ2l2ZW4uXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2b2lkIGFjdGlvblJlcy50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZShwcmVwYXJlQWN0aW9uUmVzKHJlcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyLndyYXAoXCJyZXNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGFjdGlvbnMudHJhbnNmb3JtU3RyZWFtaW5nUmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFjdGlvbnMsIFwic3RhcnRpbmcgc3RyZWFtaW5nIHJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBnZXRJbm5nZXN0SGVhZGVycygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aW1lci53cmFwKFwicmVzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uUmVzLnRoZW4ocHJlcGFyZUFjdGlvblJlcykudGhlbigoYWN0aW9uUmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucy50cmFuc2Zvcm1SZXNwb25zZShcInNlbmRpbmcgYmFjayByZXNwb25zZVwiLCBhY3Rpb25SZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb21lIHBsYXRmb3JtcyBjaGVjayAoYXQgcnVudGltZSkgdGhlIGxlbmd0aCBvZiB0aGUgZnVuY3Rpb24gYmVpbmcgdXNlZFxuICAgICAgICAgKiB0byBoYW5kbGUgYW4gZW5kcG9pbnQuIElmIHRoaXMgaXMgYSB2YXJpYWRpYyBmdW5jdGlvbiwgaXQgd2lsbCBmYWlsIHRoYXRcbiAgICAgICAgICogY2hlY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXJlZm9yZSwgd2UgZXhwZWN0IHRoZSBhcmd1bWVudHMgYWNjZXB0ZWQgdG8gYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuICAgICAgICAgKiBgaGFuZGxlcmAgZnVuY3Rpb24gcGFzc2VkIGludGVybmFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIGFsc28gc2V0IGEgbmFtZSB0byBhdm9pZCBhIGNvbW1vbiB1c2VsZXNzIG5hbWUgaW4gdHJhY2luZyBzdWNoIGFzXG4gICAgICAgICAqIGBcImFub255bW91c1wiYCBvciBgXCJib3VuZCBmdW5jdGlvblwiYC5cbiAgICAgICAgICpcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMzI4NFxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaGFuZGxlciwge1xuICAgICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIklubmdlc3RIYW5kbGVyXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaGFuZGxlci5sZW5ndGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIGdldCBtb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9XG4gICAgc2V0IG1vZGUobSkge1xuICAgICAgICB0aGlzLl9tb2RlID0gbTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50W1wibW9kZVwiXSA9IG07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzZXQgb2YgZnVuY3Rpb25zIHRvIGNoZWNrIGlmIGFuIGFjdGlvbiBpcyBhdmFpbGFibGUgZnJvbSB0aGVcbiAgICAgKiBpbnN0YW5jZSdzIGhhbmRsZXIsIGVuYWN0IGFueSBhY3Rpb24gdGhhdCBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBmZXRjaCB2YXJ5aW5nIHBheWxvYWRzIG9mIGRhdGEsIGJ1dCB1bHRpbWF0ZWx5IGlzIHRoZSBwbGFjZVxuICAgICAqIHdoZXJlIF9kZWNpc2lvbnNfIGFyZSBtYWRlIHJlZ2FyZGluZyBmdW5jdGlvbmFsaXR5LlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHdlIGZpbmQgdGhhdCB3ZSBzaG91bGQgYmUgdmlld2luZyB0aGUgVUksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiB3aWxsIGRlY2lkZSB3aGV0aGVyIHRoZSBVSSBzaG91bGQgYmUgdmlzaWJsZSBiYXNlZCBvbiB0aGUgcGF5bG9hZCBpdCBoYXNcbiAgICAgKiBmb3VuZCAoZS5nLiBlbnYgdmFycywgb3B0aW9ucywgZXRjKS5cbiAgICAgKi9cbiAgICBhc3luYyBoYW5kbGVBY3Rpb24oeyBhY3Rpb25zLCB0aW1lciwgZ2V0SW5uZ2VzdEhlYWRlcnMsIHJlcUFyZ3MsIHNpZ25hdHVyZVZhbGlkYXRpb24sIGJvZHksIG1ldGhvZCwgaGVhZGVycywgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlbiB0aGUgcmVxdWVzdCBib2R5IGlzIGNvbXBsZXRlbHkgbWlzc2luZzsgaXQgZG9lcyBub3RcbiAgICAgICAgLy8gaW5jbHVkZSBhbiBlbXB0eSBib2R5LiBUaGlzIGNvbW1vbmx5IGhhcHBlbnMgd2hlbiB0aGUgSFRUUCBmcmFtZXdvcmtcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIGJvZHkgcGFyc2luZyBtaWRkbGV3YXJlLlxuICAgICAgICBjb25zdCBpc01pc3NpbmdCb2R5ID0gYm9keSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHVybCA9IGF3YWl0IGFjdGlvbnMudXJsKFwic3RhcnRpbmcgdG8gaGFuZGxlIHJlcXVlc3RcIik7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgICAgIGlmIChpc01pc3NpbmdCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgXCJNaXNzaW5nIGJvZHkgd2hlbiBleGVjdXRpbmcsIHBvc3NpYmx5IGR1ZSB0byBtaXNzaW5nIHJlcXVlc3QgYm9keSBtaWRkbGV3YXJlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKCgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikobmV3IEVycm9yKFwiTWlzc2luZyByZXF1ZXN0IGJvZHkgd2hlbiBleGVjdXRpbmcsIHBvc3NpYmx5IGR1ZSB0byBtaXNzaW5nIHJlcXVlc3QgYm9keSBtaWRkbGV3YXJlXCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBzaWduYXR1cmVWYWxpZGF0aW9uO1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKSh2YWxpZGF0aW9uUmVzdWx0LmVycikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByYXdQcm9iZSA9IGF3YWl0IGFjdGlvbnMucXVlcnlTdHJpbmdXaXRoRGVmYXVsdHMoXCJ0ZXN0aW5nIGZvciBwcm9iZVwiLCBjb25zdHNfanNfMS5xdWVyeUtleXMuUHJvYmUpO1xuICAgICAgICAgICAgICAgIGlmIChyYXdQcm9iZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9iZSA9ICgwLCBlbnVtX2pzXzEuZW51bUZyb21WYWx1ZSkoY29uc3RzX2pzXzEucHJvYmUsIHJhd1Byb2JlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9iZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgaGVyZSwgd2UndmUgcmVjZWl2ZWQgYSBwcm9iZSB0aGF0IHdlIGRvbid0IHJlY29nbml6ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhaWwuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShuZXcgRXJyb3IoYFVua25vd24gcHJvYmUgXCIke3Jhd1Byb2JlfVwiYCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgYWN0aW9ucyBmb3IgZXZlcnkgcHJvYmUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9iZUFjdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbY29uc3RzX2pzXzEucHJvYmUuVHJ1c3RdOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvYmVBY3Rpb25zW3Byb2JlXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmbklkID0gYXdhaXQgYWN0aW9ucy5xdWVyeVN0cmluZ1dpdGhEZWZhdWx0cyhcInByb2Nlc3NpbmcgcnVuIHJlcXVlc3RcIiwgY29uc3RzX2pzXzEucXVlcnlLZXlzLkZuSWQpO1xuICAgICAgICAgICAgICAgIGlmICghZm5JZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIElEIGZvdW5kIGluIHJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBJZCA9IChhd2FpdCBhY3Rpb25zLnF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzKFwicHJvY2Vzc2luZyBydW4gcmVxdWVzdFwiLCBjb25zdHNfanNfMS5xdWVyeUtleXMuU3RlcElkKSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZlcnNpb24sIHJlc3VsdCB9ID0gdGhpcy5ydW5TdGVwKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25JZDogZm5JZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcElkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICAgICAgcmVxQXJncyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogYXdhaXQgaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwT3V0cHV0ID0gYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9ucyBjYW4gcmV0dXJuIGB1bmRlZmluZWRgLCBidXQgd2UnbGwgYWx3YXlzIGNvbnZlcnQgdGhpcyB0b1xuICAgICAgICAgICAgICAgICAqIGBudWxsYCwgYXMgdGhpcyBpcyBhcHByb3ByaWF0ZWx5IHNlcmlhbGl6YWJsZSBieSBKU09OLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wRGF0YVVuZGVmaW5lZFRvTnVsbCA9IChvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcC5kYXRhID0gKDAsIGZ1bmN0aW9uc19qc18xLnVuZGVmaW5lZFRvTnVsbCkob3AuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdEhhbmRsZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uLXJlamVjdGVkXCI6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXN1bHQucmV0cmlhYmxlID8gNTAwIDogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgW2NvbnN0c19qc18xLmhlYWRlcktleXMuTm9SZXRyeV06IHJlc3VsdC5yZXRyaWFibGUgPyBcImZhbHNlXCIgOiBcInRydWVcIiB9LCAodHlwZW9mIHJlc3VsdC5yZXRyaWFibGUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlJldHJ5QWZ0ZXJdOiByZXN1bHQucmV0cmlhYmxlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSgoMCwgZnVuY3Rpb25zX2pzXzEudW5kZWZpbmVkVG9OdWxsKShyZXN1bHQuZXJyb3IpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbi1yZXNvbHZlZFwiOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGZ1bmN0aW9uc19qc18xLnVuZGVmaW5lZFRvTnVsbCkocmVzdWx0LmRhdGEpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdGVwLW5vdC1mb3VuZFwiOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLk5vUmV0cnldOiBcImZhbHNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYENvdWxkIG5vdCBmaW5kIHN0ZXAgXCIke3Jlc3VsdC5zdGVwLmRpc3BsYXlOYW1lIHx8IHJlc3VsdC5zdGVwLmlkfVwiIHRvIHJ1bjsgdGltZWQgb3V0YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdGVwLXJhblwiOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gb3BEYXRhVW5kZWZpbmVkVG9OdWxsKHJlc3VsdC5zdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sICh0eXBlb2YgcmVzdWx0LnJldHJpYWJsZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oeyBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Ob1JldHJ5XTogcmVzdWx0LnJldHJpYWJsZSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiIH0sICh0eXBlb2YgcmVzdWx0LnJldHJpYWJsZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlJldHJ5QWZ0ZXJdOiByZXN1bHQucmV0cmlhYmxlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKSA6IHt9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKFtzdGVwXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwic3RlcHMtZm91bmRcIjogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSByZXN1bHQuc3RlcHMubWFwKG9wRGF0YVVuZGVmaW5lZFRvTnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoc3RlcHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHJlc3VsdEhhbmRsZXJzW3N0ZXBPdXRwdXQudHlwZV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZXIoc3RlcE91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCBcIkVycm9yIGhhbmRsaW5nIGV4ZWN1dGlvbiByZXN1bHRcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZmVlbHMgaGFja3ksIHNvIHdlIHNob3VsZCBwcm9iYWJseSBtYWtlIGl0IG5vdCBoYWNreS5cbiAgICAgICAgICAgIGNvbnN0IGVudiA9IChfYSA9IGdldElubmdlc3RIZWFkZXJzKClbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5FbnZpcm9ubWVudF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KShhd2FpdCB0aGlzLmludHJvc3BlY3Rpb25Cb2R5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiUFVUXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZGVwbG95SWQsIGluQmFuZFN5bmNSZXF1ZXN0ZWRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAucXVlcnlTdHJpbmdXaXRoRGVmYXVsdHMoXCJwcm9jZXNzaW5nIGRlcGxveW1lbnQgcmVxdWVzdFwiLCBjb25zdHNfanNfMS5xdWVyeUtleXMuRGVwbG95SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoZGVwbG95SWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXBsb3lJZCA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCA6IGRlcGxveUlkO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCgwLCBlbnZfanNfMS5wYXJzZUFzQm9vbGVhbikodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QWxsb3dJbkJhbmRTeW5jXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoYWxsb3dJbkJhbmRTeW5jKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dJbkJhbmRTeW5jICE9PSB1bmRlZmluZWQgJiYgIWFsbG93SW5CYW5kU3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdHNfanNfMS5zeW5jS2luZC5PdXRPZkJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucy5oZWFkZXJzKFwicHJvY2Vzc2luZyBkZXBsb3ltZW50IHJlcXVlc3RcIiwgY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Jbm5nZXN0U3luY0tpbmQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGtpbmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBraW5kID09PSBjb25zdHNfanNfMS5zeW5jS2luZC5JbkJhbmQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGlmIChpbkJhbmRTeW5jUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pc3NpbmdCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcImVycm9yXCIsIFwiTWlzc2luZyBib2R5IHdoZW4gc3luY2luZywgcG9zc2libHkgZHVlIHRvIG1pc3NpbmcgcmVxdWVzdCBib2R5IG1pZGRsZXdhcmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVlc3QgYm9keSB3aGVuIHN5bmNpbmcsIHBvc3NpYmx5IGR1ZSB0byBtaXNzaW5nIHJlcXVlc3QgYm9keSBtaWRkbGV3YXJlXCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0aW9uIGNhbiBiZSBzdWNjZXNzZnVsIGlmIHdlJ3JlIGluIGRldiBtb2RlIGFuZCBkaWQgbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IHZhbGlkYXRlIGEga2V5LiBJbiB0aGlzIGNhc2UsIGFsc28gY2hlY2sgdGhhdCB3ZSBkaWQgaW5kZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBhIHBhcnRpY3VsYXIga2V5IHRvIHZhbGlkYXRlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWdDaGVjayA9IGF3YWl0IHNpZ25hdHVyZVZhbGlkYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2lnQ2hlY2suc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcInNpZ192ZXJpZmljYXRpb25fZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdHlwZXNfanNfMS5pbkJhbmRTeW5jUmVxdWVzdEJvZHlTY2hlbWEuc2FmZVBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9yZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlcy5lcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB0cnVzdCB0aGUgVVJMIGhlcmUgYmVjYXVzZSBpdCdzIGNvbWluZyBmcm9tXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZS12ZXJpZmllZCByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLnJlcVVybChuZXcgVVJMKHJlcy5kYXRhLnVybCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhbiBpbi1iYW5kIHN5bmNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcEJvZHkgPSBhd2FpdCB0aGlzLmluQmFuZFJlZ2lzdGVyQm9keSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwbG95SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKHJlc3BCb2R5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Jbm5nZXN0U3luY0tpbmRdOiBjb25zdHNfanNfMS5zeW5jS2luZC5JbkJhbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBoZXJlLCB0aGlzIGlzIGEgbGVnYWN5IG91dC1vZi1iYW5kIHN5bmNcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXR1cywgbWVzc2FnZSwgbW9kaWZpZWQgfSA9IGF3YWl0IHRoaXMucmVnaXN0ZXIodGhpcy5yZXFVcmwodXJsKSwgZGVwbG95SWQsIGdldElubmdlc3RIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSh7IG1lc3NhZ2UsIG1vZGlmaWVkIH0pLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLklubmdlc3RTeW5jS2luZF06IGNvbnN0c19qc18xLnN5bmNLaW5kLk91dE9mQmFuZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwiaW50ZXJuYWxcIiB9LCAoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKGVycikpKSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiA0MDUsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBhY3Rpb24gZm91bmQ7IHJlcXVlc3Qgd2FzIGxpa2VseSBub3QgUE9TVCwgUFVULCBvciBHRVRcIixcbiAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLl9tb2RlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuU3RlcCh7IGZ1bmN0aW9uSWQsIHN0ZXBJZCwgZGF0YSwgdGltZXIsIHJlcUFyZ3MsIGhlYWRlcnMsIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZm4gPSB0aGlzLmZuc1tmdW5jdGlvbklkXTtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBmdW5jdGlvbiB3aXRoIElEIFwiJHtmdW5jdGlvbklkfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1tZWRpYXRlRm5EYXRhID0gKDAsIGZ1bmN0aW9uc19qc18xLnBhcnNlRm5EYXRhKShkYXRhKTtcbiAgICAgICAgbGV0IHsgdmVyc2lvbiB9ID0gaW1tZWRpYXRlRm5EYXRhO1xuICAgICAgICAvLyBIYW5kbGUgb3B0aW5nIGluIHRvIG9wdGltaXplZCBwYXJhbGxlbGlzbSBpbiB2My5cbiAgICAgICAgaWYgKHZlcnNpb24gPT09IElubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxICYmXG4gICAgICAgICAgICAoKF9iID0gKF9hID0gZm4uZm4pW1wic2hvdWxkT3B0aW1pemVQYXJhbGxlbGlzbVwiXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSkge1xuICAgICAgICAgICAgdmVyc2lvbiA9IElubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYW55Rm5EYXRhID0gYXdhaXQgKDAsIGZ1bmN0aW9uc19qc18xLmZldGNoQWxsRm5EYXRhKSh7XG4gICAgICAgICAgICAgICAgZGF0YTogaW1tZWRpYXRlRm5EYXRhLFxuICAgICAgICAgICAgICAgIGFwaTogdGhpcy5jbGllbnRbXCJpbm5nZXN0QXBpXCJdLFxuICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYW55Rm5EYXRhLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFueUZuRGF0YS5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25TdGFydGVycyA9ICgocykgPT4gcykoe1xuICAgICAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMF06ICh7IGV2ZW50LCBldmVudHMsIHN0ZXBzLCBjdHgsIHZlcnNpb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFN0YXRlID0gT2JqZWN0LmVudHJpZXMoc3RlcHMgIT09IG51bGwgJiYgc3RlcHMgIT09IHZvaWQgMCA/IHN0ZXBzIDoge30pLnJlZHVjZSgoYWNjLCBbaWQsIGRhdGFdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWRdOiB7IGlkLCBkYXRhIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucnVuX2lkKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucnVuX2lkKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiAoX2EgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguYXR0ZW1wdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRSdW5TdGVwOiBzdGVwSWQgPT09IFwic3RlcFwiID8gdW5kZWZpbmVkIDogc3RlcElkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZhaWx1cmVIYW5kbGVyOiBmbi5vbkZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcENvbXBsZXRpb25PcmRlcjogKF9jID0gKF9iID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnN0YWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhY2spICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjFdOiAoeyBldmVudCwgZXZlbnRzLCBzdGVwcywgY3R4LCB2ZXJzaW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IE9iamVjdC5lbnRyaWVzKHN0ZXBzICE9PSBudWxsICYmIHN0ZXBzICE9PSB2b2lkIDAgPyBzdGVwcyA6IHt9KS5yZWR1Y2UoKGFjYywgW2lkLCByZXN1bHRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtpZF06IHJlc3VsdC50eXBlID09PSBcImRhdGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQsIGRhdGE6IHJlc3VsdC5kYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXN1bHQudHlwZSA9PT0gXCJpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkLCBpbnB1dDogcmVzdWx0LmlucHV0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeyBpZCwgZXJyb3I6IHJlc3VsdC5lcnJvciB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJ1bl9pZCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJ1bl9pZCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdDogKF9hID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmF0dGVtcHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkUnVuU3RlcDogc3RlcElkID09PSBcInN0ZXBcIiA/IHVuZGVmaW5lZCA6IHN0ZXBJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGYWlsdXJlSGFuZGxlcjogZm4ub25GYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVJbW1lZGlhdGVFeGVjdXRpb246IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5kaXNhYmxlX2ltbWVkaWF0ZV9leGVjdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcENvbXBsZXRpb25PcmRlcjogKF9jID0gKF9iID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnN0YWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhY2spICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjJdOiAoeyBldmVudCwgZXZlbnRzLCBzdGVwcywgY3R4LCB2ZXJzaW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IE9iamVjdC5lbnRyaWVzKHN0ZXBzICE9PSBudWxsICYmIHN0ZXBzICE9PSB2b2lkIDAgPyBzdGVwcyA6IHt9KS5yZWR1Y2UoKGFjYywgW2lkLCByZXN1bHRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtpZF06IHJlc3VsdC50eXBlID09PSBcImRhdGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQsIGRhdGE6IHJlc3VsdC5kYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXN1bHQudHlwZSA9PT0gXCJpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkLCBpbnB1dDogcmVzdWx0LmlucHV0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeyBpZCwgZXJyb3I6IHJlc3VsdC5lcnJvciB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJ1bl9pZCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnJ1bl9pZCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdDogKF9hID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmF0dGVtcHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkUnVuU3RlcDogc3RlcElkID09PSBcInN0ZXBcIiA/IHVuZGVmaW5lZCA6IHN0ZXBJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGYWlsdXJlSGFuZGxlcjogZm4ub25GYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVJbW1lZGlhdGVFeGVjdXRpb246IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5kaXNhYmxlX2ltbWVkaWF0ZV9leGVjdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcENvbXBsZXRpb25PcmRlcjogKF9jID0gKF9iID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnN0YWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhY2spICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uT3B0aW9ucyA9IGF3YWl0IGV4ZWN1dGlvblN0YXJ0ZXJzW3ZlcnNpb25dKGFueUZuRGF0YS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uZm5bXCJjcmVhdGVFeGVjdXRpb25cIl0oZXhlY3V0aW9uT3B0aW9ucykuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHZlcnNpb24sIHJlc3VsdCB9O1xuICAgIH1cbiAgICBjb25maWdzKHVybCkge1xuICAgICAgICBjb25zdCBjb25maWdzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJhd0ZucykucmVkdWNlKChhY2MsIGZuKSA9PiBbXG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAuLi5mbltcImdldENvbmZpZ1wiXSh7IGJhc2VVcmw6IHVybCwgYXBwUHJlZml4OiB0aGlzLmlkIH0pLFxuICAgICAgICBdLCBbXSk7XG4gICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gdHlwZXNfanNfMS5mdW5jdGlvbkNvbmZpZ1NjaGVtYS5zYWZlUGFyc2UoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICghY2hlY2suc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGNoZWNrLmVycm9yLmVycm9ycy5tYXAoKGVycikgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oXCI7IFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgYENvbmZpZyBpbnZhbGlkIGZvciBmdW5jdGlvbiBcIiR7Y29uZmlnLmlkfVwiIDogJHtlcnJvcnN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBJbm5nZXN0IHNlcnZlIGVuZHBvaW50IFVSTCBnaXZlbiBhIHBvdGVudGlhbCBgcGF0aGAgYW5kIGBob3N0YC5cbiAgICAgKlxuICAgICAqIFdpbGwgYXV0b21hdGljYWxseSB1c2UgdGhlIGBzZXJ2ZUhvc3RgIGFuZCBgc2VydmVQYXRoYCBpZiB0aGV5IGhhdmUgYmVlblxuICAgICAqIHNldCB3aGVuIHJlZ2lzdGVyaW5nLlxuICAgICAqL1xuICAgIHJlcVVybCh1cmwpIHtcbiAgICAgICAgbGV0IHJldCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgY29uc3Qgc2VydmVIb3N0ID0gdGhpcy5zZXJ2ZUhvc3QgfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVIb3N0XTtcbiAgICAgICAgY29uc3Qgc2VydmVQYXRoID0gdGhpcy5zZXJ2ZVBhdGggfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVQYXRoXTtcbiAgICAgICAgaWYgKHNlcnZlUGF0aCkge1xuICAgICAgICAgICAgcmV0LnBhdGhuYW1lID0gc2VydmVQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJ2ZUhvc3QpIHtcbiAgICAgICAgICAgIHJldCA9IG5ldyBVUkwocmV0LnBhdGhuYW1lICsgcmV0LnNlYXJjaCwgc2VydmVIb3N0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZWdpc3RlckJvZHkoeyB1cmwsIGRlcGxveUlkLCB9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICB1cmw6IHVybC5ocmVmLFxuICAgICAgICAgICAgZGVwbG95VHlwZTogXCJwaW5nXCIsXG4gICAgICAgICAgICBmcmFtZXdvcms6IHRoaXMuZnJhbWV3b3JrTmFtZSxcbiAgICAgICAgICAgIGFwcE5hbWU6IHRoaXMuaWQsXG4gICAgICAgICAgICBmdW5jdGlvbnM6IHRoaXMuY29uZmlncyh1cmwpLFxuICAgICAgICAgICAgc2RrOiBganM6diR7dmVyc2lvbl9qc18xLnZlcnNpb259YCxcbiAgICAgICAgICAgIHY6IFwiMC4xXCIsXG4gICAgICAgICAgICBkZXBsb3lJZDogZGVwbG95SWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgICAgICAgICAgdHJ1c3RfcHJvYmU6IFwidjFcIixcbiAgICAgICAgICAgICAgICBjb25uZWN0OiBcInYxXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwVmVyc2lvbjogdGhpcy5jbGllbnQuYXBwVmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICAgIGFzeW5jIGluQmFuZFJlZ2lzdGVyQm9keSh7IGFjdGlvbnMsIGRlcGxveUlkLCBlbnYsIHNpZ25hdHVyZVZhbGlkYXRpb24sIHVybCwgfSkge1xuICAgICAgICBjb25zdCByZWdpc3RlckJvZHkgPSB0aGlzLnJlZ2lzdGVyQm9keSh7IGRlcGxveUlkLCB1cmwgfSk7XG4gICAgICAgIGNvbnN0IGludHJvc3BlY3Rpb25Cb2R5ID0gYXdhaXQgdGhpcy5pbnRyb3NwZWN0aW9uQm9keSh7XG4gICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgc2lnbmF0dXJlVmFsaWRhdGlvbixcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBhcHBfaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBhcHBWZXJzaW9uOiB0aGlzLmNsaWVudC5hcHBWZXJzaW9uLFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiByZWdpc3RlckJvZHkuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgZnJhbWV3b3JrOiByZWdpc3RlckJvZHkuZnJhbWV3b3JrLFxuICAgICAgICAgICAgZnVuY3Rpb25zOiByZWdpc3RlckJvZHkuZnVuY3Rpb25zLFxuICAgICAgICAgICAgaW5zcGVjdGlvbjogaW50cm9zcGVjdGlvbkJvZHksXG4gICAgICAgICAgICBwbGF0Zm9ybTogKDAsIGVudl9qc18xLmdldFBsYXRmb3JtTmFtZSkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgZW52X2pzXzEuYWxsUHJvY2Vzc0VudikoKSksIHRoaXMuZW52KSksXG4gICAgICAgICAgICBzZGtfYXV0aG9yOiBcImlubmdlc3RcIixcbiAgICAgICAgICAgIHNka19sYW5ndWFnZTogXCJcIixcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBcIlwiLFxuICAgICAgICAgICAgc2RrOiByZWdpc3RlckJvZHkuc2RrLFxuICAgICAgICAgICAgdXJsOiByZWdpc3RlckJvZHkudXJsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW50cm9zcGVjdGlvbkJvZHkuYXV0aGVudGljYXRpb25fc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICBib2R5LnNka19sYW5ndWFnZSA9IGludHJvc3BlY3Rpb25Cb2R5LnNka19sYW5ndWFnZTtcbiAgICAgICAgICAgIGJvZHkuc2RrX3ZlcnNpb24gPSBpbnRyb3NwZWN0aW9uQm9keS5zZGtfdmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gICAgYXN5bmMgaW50cm9zcGVjdGlvbkJvZHkoeyBhY3Rpb25zLCBlbnYsIHNpZ25hdHVyZVZhbGlkYXRpb24sIHVybCwgfSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBjb25zdCByZWdpc3RlckJvZHkgPSB0aGlzLnJlZ2lzdGVyQm9keSh7XG4gICAgICAgICAgICB1cmw6IHRoaXMucmVxVXJsKHVybCksXG4gICAgICAgICAgICBkZXBsb3lJZDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5fbW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbW9kZSBzZXQ7IGNhbm5vdCBpbnRyb3NwZWN0IHdpdGhvdXQgbW9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW50cm9zcGVjdGlvbiA9IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uX3N1Y2NlZWRlZDogbnVsbCxcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgaXNfbW9kZV9leHBsaWNpdDogdGhpcy5fbW9kZS5pc0V4cGxpY2l0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc19ldmVudF9rZXk6IHRoaXMuY2xpZW50W1wiZXZlbnRLZXlTZXRcIl0oKSxcbiAgICAgICAgICAgIGhhc19zaWduaW5nX2tleTogQm9vbGVhbih0aGlzLnNpZ25pbmdLZXkpLFxuICAgICAgICAgICAgZnVuY3Rpb25fY291bnQ6IHJlZ2lzdGVyQm9keS5mdW5jdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5fbW9kZS50eXBlLFxuICAgICAgICAgICAgc2NoZW1hX3ZlcnNpb246IFwiMjAyNC0wNS0yNFwiLFxuICAgICAgICB9O1xuICAgICAgICAvLyBPbmx5IGFsbG93IGF1dGhlbnRpY2F0ZWQgaW50cm9zcGVjdGlvbiBpbiBDbG91ZCBtb2RlLCBzaW5jZSBEZXYgbW9kZSBza2lwc1xuICAgICAgICAvLyBzaWduYXR1cmUgdmFsaWRhdGlvblxuICAgICAgICBpZiAodGhpcy5fbW9kZS50eXBlID09PSBcImNsb3VkXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNpZ25hdHVyZVZhbGlkYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIHZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnRyb3NwZWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRyb3NwZWN0aW9uKSwgeyBhdXRoZW50aWNhdGlvbl9zdWNjZWVkZWQ6IHRydWUsIGFwaV9vcmlnaW46IHRoaXMuYXBpQmFzZVVybCwgYXBwX2lkOiB0aGlzLmlkLCBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydXN0X3Byb2JlOiBcInYxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiBcInYxXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sIGVudiwgZXZlbnRfYXBpX29yaWdpbjogdGhpcy5ldmVudEFwaUJhc2VVcmwsIGV2ZW50X2tleV9oYXNoOiAoX2EgPSB0aGlzLmhhc2hlZEV2ZW50S2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCBleHRyYTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRyb3NwZWN0aW9uLmV4dHJhKSwgeyBpc19zdHJlYW1pbmc6IGF3YWl0IHRoaXMuc2hvdWxkU3RyZWFtKGFjdGlvbnMpIH0pLCBmcmFtZXdvcms6IHRoaXMuZnJhbWV3b3JrTmFtZSwgc2RrX2xhbmd1YWdlOiBcImpzXCIsIHNka192ZXJzaW9uOiB2ZXJzaW9uX2pzXzEudmVyc2lvbiwgc2VydmVfb3JpZ2luOiAoX2IgPSB0aGlzLnNlcnZlSG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCwgc2VydmVfcGF0aDogKF9jID0gdGhpcy5zZXJ2ZVBhdGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsIHNpZ25pbmdfa2V5X2ZhbGxiYWNrX2hhc2g6IChfZCA9IHRoaXMuaGFzaGVkU2lnbmluZ0tleUZhbGxiYWNrKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsLCBzaWduaW5nX2tleV9oYXNoOiAoX2UgPSB0aGlzLmhhc2hlZFNpZ25pbmdLZXkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2YpIHtcbiAgICAgICAgICAgICAgICAvLyBTd2FsbG93IHNpZ25hdHVyZSB2YWxpZGF0aW9uIGVycm9yIHNpbmNlIHdlJ2xsIGp1c3QgcmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgIC8vIHVuYXV0aGVudGljYXRlZCBpbnRyb3NwZWN0aW9uXG4gICAgICAgICAgICAgICAgaW50cm9zcGVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW50cm9zcGVjdGlvbiksIHsgYXV0aGVudGljYXRpb25fc3VjY2VlZGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50cm9zcGVjdGlvbjtcbiAgICB9XG4gICAgYXN5bmMgcmVnaXN0ZXIodXJsLCBkZXBsb3lJZCwgZ2V0SGVhZGVycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnJlZ2lzdGVyQm9keSh7IHVybCwgZGVwbG95SWQgfSk7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIC8vIFdoZW5ldmVyIHdlIHJlZ2lzdGVyLCB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRldiBzZXJ2ZXIgaXMgdXAuICBUaGlzXG4gICAgICAgIC8vIGlzIGEgbm9vcCBhbmQgcmV0dXJucyBmYWxzZSBpbiBwcm9kdWN0aW9uLiBDbG9uZSB0aGUgVVJMIG9iamVjdCB0byBhdm9pZFxuICAgICAgICAvLyBtdXRhdGluZyB0aGUgcHJvcGVydHkgYmV0d2VlbiByZXF1ZXN0cy5cbiAgICAgICAgbGV0IHJlZ2lzdGVyVVJMID0gbmV3IFVSTCh0aGlzLmlubmdlc3RSZWdpc3RlclVybC5ocmVmKTtcbiAgICAgICAgY29uc3QgaW5mZXJyZWREZXZNb2RlID0gdGhpcy5fbW9kZSAmJiB0aGlzLl9tb2RlLmlzSW5mZXJyZWQgJiYgdGhpcy5fbW9kZS5pc0RldjtcbiAgICAgICAgaWYgKGluZmVycmVkRGV2TW9kZSkge1xuICAgICAgICAgICAgY29uc3QgaG9zdCA9ICgwLCBlbnZfanNfMS5kZXZTZXJ2ZXJIb3N0KSh0aGlzLmVudik7XG4gICAgICAgICAgICBjb25zdCBoYXNEZXZTZXJ2ZXIgPSBhd2FpdCAoMCwgZGV2c2VydmVyX2pzXzEuZGV2U2VydmVyQXZhaWxhYmxlKShob3N0LCB0aGlzLmZldGNoKTtcbiAgICAgICAgICAgIGlmIChoYXNEZXZTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlclVSTCA9ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJVcmwpKGhvc3QsIFwiL2ZuL3JlZ2lzdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChfYSA9IHRoaXMuX21vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHBsaWNpdERldlVybCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJVUkwgPSAoMCwgZGV2c2VydmVyX2pzXzEuZGV2U2VydmVyVXJsKSh0aGlzLl9tb2RlLmV4cGxpY2l0RGV2VXJsLmhyZWYsIFwiL2ZuL3JlZ2lzdGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXBsb3lJZCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJVUkwuc2VhcmNoUGFyYW1zLnNldChjb25zdHNfanNfMS5xdWVyeUtleXMuRGVwbG95SWQsIGRlcGxveUlkKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gYXdhaXQgKDAsIG5ldF9qc18xLmZldGNoV2l0aEF1dGhGYWxsYmFjaykoe1xuICAgICAgICAgICAgICAgIGF1dGhUb2tlbjogdGhpcy5oYXNoZWRTaWduaW5nS2V5LFxuICAgICAgICAgICAgICAgIGF1dGhUb2tlbkZhbGxiYWNrOiB0aGlzLmhhc2hlZFNpZ25pbmdLZXlGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgICAgICB1cmw6IHJlZ2lzdGVyVVJMLmhyZWYsXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoYm9keSksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0SGVhZGVycygpKSwgeyBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Jbm5nZXN0U3luY0tpbmRdOiBjb25zdHNfanNfMS5zeW5jS2luZC5PdXRPZkJhbmQgfSksXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgdG8gcmVnaXN0ZXIke2VyciBpbnN0YW5jZW9mIEVycm9yID8gYDsgJHtlcnIubWVzc2FnZX1gIDogXCJcIn1gLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgXCJDb3VsZG4ndCB1bnBhY2sgcmVnaXN0ZXIgcmVzcG9uc2U6XCIsIGVycik7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IFwiRmFpbGVkIHRvIHJlZ2lzdGVyXCI7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA7ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDsgc3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c31gO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXR1cztcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBsZXQgc2tpcHBlZDtcbiAgICAgICAgbGV0IG1vZGlmaWVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKHsgc3RhdHVzLCBlcnJvciwgc2tpcHBlZCwgbW9kaWZpZWQgfSA9IHJlZ2lzdGVyUmVzU2NoZW1hLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgXCJJbnZhbGlkIHJlZ2lzdGVyIHJlc3BvbnNlIHNjaGVtYTpcIiwgZXJyKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJGYWlsZWQgdG8gcmVnaXN0ZXJcIjtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDsgJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZSArPSBgOyBzdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzfWA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZGV2IHNlcnZlciBwb2xscyB0aGlzIGVuZHBvaW50IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyBldmVyeSBmZXdcbiAgICAgICAgLy8gc2Vjb25kcywgYnV0IHdlIG9ubHkgd2FudCB0byBsb2cgdGhhdCB3ZSd2ZSByZWdpc3RlcmVkIGZ1bmN0aW9ucyBpZlxuICAgICAgICAvLyB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbnMgY2hhbmdlLiAgVGhlcmVmb3JlLCB3ZSBjb21wYXJlIHRoZSBib2R5IHNlbnRcbiAgICAgICAgLy8gZHVyaW5nIHJlZ2lzdHJhdGlvbiB3aXRoIHRoZSBib2R5IG9mIHRoZSBjdXJyZW50IGZ1bmN0aW9ucyBhbmQgcmVmdXNlXG4gICAgICAgIC8vIHRvIHJlZ2lzdGVyIGlmIHRoZSBmdW5jdGlvbnMgYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAoIXNraXBwZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiZGVidWdcIiwgXCJyZWdpc3RlcmVkIGlubmdlc3QgZnVuY3Rpb25zOlwiLCByZXMuc3RhdHVzLCByZXMuc3RhdHVzVGV4dCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzLCBtZXNzYWdlOiBlcnJvciwgbW9kaWZpZWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gZW52aXJvbm1lbnQsIHVwc2VydCBhbnkgbWlzc2luZyBrZXlzLiBUaGlzIGlzIHVzZWZ1bCBpblxuICAgICAqIHNpdHVhdGlvbnMgd2hlcmUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFyZSBwYXNzZWQgZGlyZWN0bHkgdG8gaGFuZGxlcnMgb3JcbiAgICAgKiBhcmUgb3RoZXJ3aXNlIGRpZmZpY3VsdCB0byBhY2Nlc3MgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIHVwc2VydEtleXNGcm9tRW52KCkge1xuICAgICAgICBpZiAodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2lnbmluZ0tleV0pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduaW5nS2V5ID0gU3RyaW5nKHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNpZ25pbmdLZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXS5zZXRTaWduaW5nS2V5KHRoaXMuc2lnbmluZ0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNpZ25pbmdLZXlGYWxsYmFja10pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduaW5nS2V5RmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IFN0cmluZyh0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTaWduaW5nS2V5RmFsbGJhY2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXS5zZXRTaWduaW5nS2V5RmFsbGJhY2sodGhpcy5zaWduaW5nS2V5RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRbXCJldmVudEtleVNldFwiXSgpICYmIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEV2ZW50S2V5XSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuc2V0RXZlbnRLZXkoU3RyaW5nKHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEV2ZW50S2V5XSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHYyIC0+IHYzIG1pZ3JhdGlvbiB3YXJuaW5nc1xuICAgICAgICBpZiAodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RGV2U2VydmVyVXJsXSkge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ3YXJuXCIsIGBVc2Ugb2YgJHtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3REZXZTZXJ2ZXJVcmx9IGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gdjM7IHBsZWFzZSB1c2UgJHtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RCYXNlVXJsfSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9zZGsvbWlncmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIHNpZ25hdHVyZSBvZiBhIHJlcXVlc3QgYW5kIHJldHVybiB0aGUgc2lnbmluZyBrZXkgdXNlZCB0b1xuICAgICAqIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICAgIGFzeW5jIHZhbGlkYXRlU2lnbmF0dXJlKHNpZywgYm9keSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2tpcCBzaWduYXR1cmUgdmFsaWRhdGlvbiBpZiByZXF1ZXN0ZWQgKHVzZWQgYnkgY29ubmVjdClcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBTaWduYXR1cmVWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwga2V5VXNlZDogXCJcIiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmV2ZXIgdmFsaWRhdGUgc2lnbmF0dXJlcyBvdXRzaWRlIG9mIHByb2QuIE1ha2Ugc3VyZSB0byBjaGVjayB0aGUgbW9kZVxuICAgICAgICAgICAgLy8gZXhpc3RzIGhlcmUgaW5zdGVhZCBvZiB1c2luZyBudWxsaXNoIGNvYWxlc2NpbmcgdG8gY29uZmlybSB0aGF0IHRoZSBjaGVja1xuICAgICAgICAgICAgLy8gaGFzIGJlZW4gY29tcGxldGVkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgJiYgIXRoaXMuX21vZGUuaXNDbG91ZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGtleVVzZWQ6IFwiXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGhlcmUsIHdlJ3JlIGluIHByb2R1Y3Rpb247IGxhY2sgb2YgYSBzaWduaW5nIGtleSBpcyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc2lnbmluZyBrZXkgZm91bmQgaW4gY2xpZW50IG9wdGlvbnMgb3IgJHtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTaWduaW5nS2V5fSBlbnYgdmFyLiBGaW5kIHlvdXIga2V5cyBhdCBodHRwczovL2FwcC5pbm5nZXN0LmNvbS9zZWNyZXRzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBoZXJlLCB3ZSdyZSBpbiBwcm9kdWN0aW9uOyBsYWNrIG9mIGEgcmVxIHNpZ25hdHVyZSBpcyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJHtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlNpZ25hdHVyZX0gcHJvdmlkZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzaWduYXR1cmVcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXlVc2VkOiBuZXcgUmVxdWVzdFNpZ25hdHVyZShzaWcpLnZlcmlmeVNpZ25hdHVyZSh7XG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93RXhwaXJlZFNpZ25hdHVyZXM6IHRoaXMuYWxsb3dFeHBpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmluZ0tleTogdGhpcy5zaWduaW5nS2V5LFxuICAgICAgICAgICAgICAgICAgICBzaWduaW5nS2V5RmFsbGJhY2s6IHRoaXMuc2lnbmluZ0tleUZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyOiBlcnIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXNwb25zZVNpZ25hdHVyZShrZXksIGJvZHkpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgbWFjID0gKDAsIG5ldF9qc18xLnNpZ25EYXRhV2l0aEtleSkoYm9keSwga2V5LCBub3cudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBgdD0ke25vd30mcz0ke21hY31gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgdG8gc3Rkb3V0L3N0ZGVyciBpZiB0aGUgbG9nIGxldmVsIGlzIHNldCB0byBpbmNsdWRlIHRoZSBnaXZlbiBsZXZlbC5cbiAgICAgKiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWwgaXMgYFwiaW5mb1wiYC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gYWJzdHJhY3Rpb24gb3ZlciBgY29uc29sZS5sb2dgIGFuZCB3aWxsIHRyeSB0byB1c2UgdGhlIGNvcnJlY3RcbiAgICAgKiBtZXRob2QgZm9yIHRoZSBnaXZlbiBsb2cgbGV2ZWwuICBGb3IgZXhhbXBsZSwgYGxvZyhcImVycm9yXCIsIFwiZm9vXCIpYCB3aWxsXG4gICAgICogY2FsbCBgY29uc29sZS5lcnJvcihcImZvb1wiKWAuXG4gICAgICovXG4gICAgbG9nKGxldmVsLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGxvZ0xldmVscyA9IFtcbiAgICAgICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgICAgIFwiaW5mb1wiLFxuICAgICAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICBcImZhdGFsXCIsXG4gICAgICAgICAgICBcInNpbGVudFwiLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBsb2dMZXZlbFNldHRpbmcgPSBsb2dMZXZlbHMuaW5kZXhPZih0aGlzLmxvZ0xldmVsKTtcbiAgICAgICAgY29uc3QgY3VycmVudExldmVsID0gbG9nTGV2ZWxzLmluZGV4T2YobGV2ZWwpO1xuICAgICAgICBpZiAoY3VycmVudExldmVsID49IGxvZ0xldmVsU2V0dGluZykge1xuICAgICAgICAgICAgbGV0IGxvZ2dlciA9IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25zb2xlLCBsZXZlbCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIgPSBjb25zb2xlW2xldmVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlcihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9ICR7bGV2ZWx9IC1gLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdENvbW1IYW5kbGVyID0gSW5uZ2VzdENvbW1IYW5kbGVyO1xuY2xhc3MgUmVxdWVzdFNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Ioc2lnKSB7XG4gICAgICAgIF9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2lnKTtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBwYXJhbXMuZ2V0KFwidFwiKSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHBhcmFtcy5nZXQoXCJzXCIpIHx8IFwiXCI7XG4gICAgICAgIGlmICghdGhpcy50aW1lc3RhbXAgfHwgIXRoaXMuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHtjb25zdHNfanNfMS5oZWFkZXJLZXlzLlNpZ25hdHVyZX0gcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFeHBpcmVkKGFsbG93RXhwaXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgICAgaWYgKGFsbG93RXhwaXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IERhdGUubm93KCkgLSBuZXcgRGF0ZShwYXJzZUludCh0aGlzLnRpbWVzdGFtcCkgKiAxMDAwKS52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiBkZWx0YSA+IDEwMDAgKiA2MCAqIDU7XG4gICAgfVxuICAgIHZlcmlmeVNpZ25hdHVyZSh7IGJvZHksIHNpZ25pbmdLZXksIHNpZ25pbmdLZXlGYWxsYmFjaywgYWxsb3dFeHBpcmVkU2lnbmF0dXJlcywgfSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUmVxdWVzdFNpZ25hdHVyZV9pbnN0YW5jZXMsIFwibVwiLCBfUmVxdWVzdFNpZ25hdHVyZV92ZXJpZnlTaWduYXR1cmUpLmNhbGwodGhpcywgeyBib2R5LCBzaWduaW5nS2V5LCBhbGxvd0V4cGlyZWRTaWduYXR1cmVzIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ25pbmdLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCFzaWduaW5nS2V5RmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcywgXCJtXCIsIF9SZXF1ZXN0U2lnbmF0dXJlX3ZlcmlmeVNpZ25hdHVyZSkuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBzaWduaW5nS2V5OiBzaWduaW5nS2V5RmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgYWxsb3dFeHBpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ25pbmdLZXlGYWxsYmFjaztcbiAgICAgICAgfVxuICAgIH1cbn1cbl9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9SZXF1ZXN0U2lnbmF0dXJlX3ZlcmlmeVNpZ25hdHVyZSA9IGZ1bmN0aW9uIF9SZXF1ZXN0U2lnbmF0dXJlX3ZlcmlmeVNpZ25hdHVyZSh7IGJvZHksIHNpZ25pbmdLZXksIGFsbG93RXhwaXJlZFNpZ25hdHVyZXMsIH0pIHtcbiAgICBpZiAodGhpcy5oYXNFeHBpcmVkKGFsbG93RXhwaXJlZFNpZ25hdHVyZXMpKSB7XG4gICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIGhhcyBleHBpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBtYWMgPSAoMCwgbmV0X2pzXzEuc2lnbkRhdGFXaXRoS2V5KShib2R5LCBzaWduaW5nS2V5LCB0aGlzLnRpbWVzdGFtcCk7XG4gICAgaWYgKG1hYyAhPT0gdGhpcy5zaWduYXR1cmUpIHtcbiAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hdHVyZVwiKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZ2VzdENvbW1IYW5kbGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestCommHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestFunction.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/components/InngestFunction.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestFunction = void 0;\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst v0_js_1 = __webpack_require__(/*! ./execution/v0.js */ \"(rsc)/./node_modules/inngest/components/execution/v0.js\");\nconst v1_js_1 = __webpack_require__(/*! ./execution/v1.js */ \"(rsc)/./node_modules/inngest/components/execution/v1.js\");\nconst v2_js_1 = __webpack_require__(/*! ./execution/v2.js */ \"(rsc)/./node_modules/inngest/components/execution/v2.js\");\n/**\n * A stateless Inngest function, wrapping up function configuration and any\n * in-memory steps to run when triggered.\n *\n * This function can be \"registered\" to create a handler that Inngest can\n * trigger remotely.\n *\n * @public\n */\nclass InngestFunction {\n    /**\n     * A stateless Inngest function, wrapping up function configuration and any\n     * in-memory steps to run when triggered.\n     *\n     * This function can be \"registered\" to create a handler that Inngest can\n     * trigger remotely.\n     */\n    constructor(client, \n    /**\n     * Options\n     */\n    opts, fn) {\n        this.client = client;\n        this.opts = opts;\n        this.fn = fn;\n        this.onFailureFn = this.opts.onFailure;\n        this.middleware = this.client[\"initializeMiddleware\"](this.opts.middleware, { registerInput: { fn: this }, prefixStack: this.client[\"middleware\"] });\n    }\n    /**\n     * The generated or given ID for this function.\n     */\n    id(prefix) {\n        return [prefix, this.opts.id].filter(Boolean).join(\"-\");\n    }\n    /**\n     * The generated or given ID for this function, prefixed with the app ID. This\n     * is used for routing invokes and identifying the function across apps.\n     */\n    get absoluteId() {\n        return this.id(this.client.id);\n    }\n    /**\n     * The name of this function as it will appear in the Inngest Cloud UI.\n     */\n    get name() {\n        return this.opts.name || this.id();\n    }\n    /**\n     * The description of this function.\n     */\n    get description() {\n        return this.opts.description;\n    }\n    /**\n     * Retrieve the Inngest config for this function.\n     */\n    getConfig({ baseUrl, appPrefix, isConnect, }) {\n        var _a, _b;\n        const fnId = this.id(appPrefix);\n        const stepUrl = new URL(baseUrl.href);\n        stepUrl.searchParams.set(consts_js_1.queryKeys.FnId, fnId);\n        stepUrl.searchParams.set(consts_js_1.queryKeys.StepId, InngestFunction.stepId);\n        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority, singleton, } = this.opts;\n        /**\n         * Convert retries into the format required when defining function\n         * configuration.\n         */\n        const retries = typeof attempts === \"undefined\" ? undefined : { attempts };\n        const fn = {\n            id: fnId,\n            name: this.name,\n            triggers: ((_a = this.opts.triggers) !== null && _a !== void 0 ? _a : []).map((trigger) => {\n                if (\"event\" in trigger) {\n                    return {\n                        event: trigger.event,\n                        expression: trigger.if,\n                    };\n                }\n                return {\n                    cron: trigger.cron,\n                };\n            }),\n            steps: {\n                [InngestFunction.stepId]: {\n                    id: InngestFunction.stepId,\n                    name: InngestFunction.stepId,\n                    runtime: {\n                        type: isConnect ? \"ws\" : \"http\",\n                        url: stepUrl.href,\n                    },\n                    retries,\n                },\n            },\n            idempotency,\n            batchEvents,\n            rateLimit,\n            throttle,\n            concurrency,\n            debounce,\n            priority,\n            timeouts,\n            singleton,\n        };\n        if (cancelOn) {\n            fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {\n                const ret = {\n                    event,\n                };\n                if (timeout) {\n                    ret.timeout = (0, strings_js_1.timeStr)(timeout);\n                }\n                if (match) {\n                    ret.if = `event.${match} == async.${match}`;\n                }\n                else if (ifStr) {\n                    ret.if = ifStr;\n                }\n                return ret;\n            }, []);\n        }\n        const config = [fn];\n        if (this.onFailureFn) {\n            const id = `${fn.id}${InngestFunction.failureSuffix}`;\n            const name = `${(_b = fn.name) !== null && _b !== void 0 ? _b : fn.id} (failure)`;\n            const failureStepUrl = new URL(stepUrl.href);\n            failureStepUrl.searchParams.set(consts_js_1.queryKeys.FnId, id);\n            config.push({\n                id,\n                name,\n                triggers: [\n                    {\n                        event: consts_js_1.internalEvents.FunctionFailed,\n                        expression: `event.data.function_id == '${fnId}'`,\n                    },\n                ],\n                steps: {\n                    [InngestFunction.stepId]: {\n                        id: InngestFunction.stepId,\n                        name: InngestFunction.stepId,\n                        runtime: {\n                            type: \"http\",\n                            url: failureStepUrl.href,\n                        },\n                        retries: { attempts: 1 },\n                    },\n                },\n            });\n        }\n        return config;\n    }\n    createExecution(opts) {\n        const options = Object.assign({ fn: this }, opts.partialOptions);\n        const versionHandlers = {\n            [InngestExecution_js_1.ExecutionVersion.V2]: () => (0, v2_js_1.createV2InngestExecution)(options),\n            [InngestExecution_js_1.ExecutionVersion.V1]: () => (0, v1_js_1.createV1InngestExecution)(options),\n            [InngestExecution_js_1.ExecutionVersion.V0]: () => (0, v0_js_1.createV0InngestExecution)(options),\n        };\n        return versionHandlers[opts.version]();\n    }\n    shouldOptimizeParallelism() {\n        var _a, _b;\n        // TODO We should check the commhandler's client instead of this one?\n        return ((_b = (_a = this.opts.optimizeParallelism) !== null && _a !== void 0 ? _a : this.client[\"options\"].optimizeParallelism) !== null && _b !== void 0 ? _b : false);\n    }\n}\nexports.InngestFunction = InngestFunction;\nInngestFunction.stepId = \"step\";\nInngestFunction.failureSuffix = \"-failure\";\n//# sourceMappingURL=InngestFunction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBaUM7QUFDdkUsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixpQkFBaUIsVUFBVSwwQ0FBMEM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvSUFBb0k7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU8sV0FBVyxNQUFNO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sRUFBRSw4QkFBOEI7QUFDaEUsNEJBQTRCLHVEQUF1RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsbUNBQW1DLGFBQWE7QUFDaEQscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Jbm5nZXN0RnVuY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklubmdlc3RGdW5jdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyaW5ncy5qc1wiKTtcbmNvbnN0IElubmdlc3RFeGVjdXRpb25fanNfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCIpO1xuY29uc3QgdjBfanNfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGlvbi92MC5qc1wiKTtcbmNvbnN0IHYxX2pzXzEgPSByZXF1aXJlKFwiLi9leGVjdXRpb24vdjEuanNcIik7XG5jb25zdCB2Ml9qc18xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uL3YyLmpzXCIpO1xuLyoqXG4gKiBBIHN0YXRlbGVzcyBJbm5nZXN0IGZ1bmN0aW9uLCB3cmFwcGluZyB1cCBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGFuZCBhbnlcbiAqIGluLW1lbW9yeSBzdGVwcyB0byBydW4gd2hlbiB0cmlnZ2VyZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgXCJyZWdpc3RlcmVkXCIgdG8gY3JlYXRlIGEgaGFuZGxlciB0aGF0IElubmdlc3QgY2FuXG4gKiB0cmlnZ2VyIHJlbW90ZWx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSW5uZ2VzdEZ1bmN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBIHN0YXRlbGVzcyBJbm5nZXN0IGZ1bmN0aW9uLCB3cmFwcGluZyB1cCBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGFuZCBhbnlcbiAgICAgKiBpbi1tZW1vcnkgc3RlcHMgdG8gcnVuIHdoZW4gdHJpZ2dlcmVkLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgXCJyZWdpc3RlcmVkXCIgdG8gY3JlYXRlIGEgaGFuZGxlciB0aGF0IElubmdlc3QgY2FuXG4gICAgICogdHJpZ2dlciByZW1vdGVseS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIFxuICAgIC8qKlxuICAgICAqIE9wdGlvbnNcbiAgICAgKi9cbiAgICBvcHRzLCBmbikge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLm9uRmFpbHVyZUZuID0gdGhpcy5vcHRzLm9uRmFpbHVyZTtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlID0gdGhpcy5jbGllbnRbXCJpbml0aWFsaXplTWlkZGxld2FyZVwiXSh0aGlzLm9wdHMubWlkZGxld2FyZSwgeyByZWdpc3RlcklucHV0OiB7IGZuOiB0aGlzIH0sIHByZWZpeFN0YWNrOiB0aGlzLmNsaWVudFtcIm1pZGRsZXdhcmVcIl0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBnZW5lcmF0ZWQgb3IgZ2l2ZW4gSUQgZm9yIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgaWQocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBbcHJlZml4LCB0aGlzLm9wdHMuaWRdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGdlbmVyYXRlZCBvciBnaXZlbiBJRCBmb3IgdGhpcyBmdW5jdGlvbiwgcHJlZml4ZWQgd2l0aCB0aGUgYXBwIElELiBUaGlzXG4gICAgICogaXMgdXNlZCBmb3Igcm91dGluZyBpbnZva2VzIGFuZCBpZGVudGlmeWluZyB0aGUgZnVuY3Rpb24gYWNyb3NzIGFwcHMuXG4gICAgICovXG4gICAgZ2V0IGFic29sdXRlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkKHRoaXMuY2xpZW50LmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBmdW5jdGlvbiBhcyBpdCB3aWxsIGFwcGVhciBpbiB0aGUgSW5uZ2VzdCBDbG91ZCBVSS5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5uYW1lIHx8IHRoaXMuaWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgSW5uZ2VzdCBjb25maWcgZm9yIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZ2V0Q29uZmlnKHsgYmFzZVVybCwgYXBwUHJlZml4LCBpc0Nvbm5lY3QsIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZm5JZCA9IHRoaXMuaWQoYXBwUHJlZml4KTtcbiAgICAgICAgY29uc3Qgc3RlcFVybCA9IG5ldyBVUkwoYmFzZVVybC5ocmVmKTtcbiAgICAgICAgc3RlcFVybC5zZWFyY2hQYXJhbXMuc2V0KGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5GbklkLCBmbklkKTtcbiAgICAgICAgc3RlcFVybC5zZWFyY2hQYXJhbXMuc2V0KGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5TdGVwSWQsIElubmdlc3RGdW5jdGlvbi5zdGVwSWQpO1xuICAgICAgICBjb25zdCB7IHJldHJpZXM6IGF0dGVtcHRzLCBjYW5jZWxPbiwgaWRlbXBvdGVuY3ksIGJhdGNoRXZlbnRzLCByYXRlTGltaXQsIHRocm90dGxlLCBjb25jdXJyZW5jeSwgZGVib3VuY2UsIHRpbWVvdXRzLCBwcmlvcml0eSwgc2luZ2xldG9uLCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCByZXRyaWVzIGludG8gdGhlIGZvcm1hdCByZXF1aXJlZCB3aGVuIGRlZmluaW5nIGZ1bmN0aW9uXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXRyaWVzID0gdHlwZW9mIGF0dGVtcHRzID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkIDogeyBhdHRlbXB0cyB9O1xuICAgICAgICBjb25zdCBmbiA9IHtcbiAgICAgICAgICAgIGlkOiBmbklkLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgdHJpZ2dlcnM6ICgoX2EgPSB0aGlzLm9wdHMudHJpZ2dlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5tYXAoKHRyaWdnZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJldmVudFwiIGluIHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0cmlnZ2VyLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogdHJpZ2dlci5pZixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvbjogdHJpZ2dlci5jcm9uLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHN0ZXBzOiB7XG4gICAgICAgICAgICAgICAgW0lubmdlc3RGdW5jdGlvbi5zdGVwSWRdOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBJbm5nZXN0RnVuY3Rpb24uc3RlcElkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBJbm5nZXN0RnVuY3Rpb24uc3RlcElkLFxuICAgICAgICAgICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpc0Nvbm5lY3QgPyBcIndzXCIgOiBcImh0dHBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogc3RlcFVybC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXRyaWVzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRlbXBvdGVuY3ksXG4gICAgICAgICAgICBiYXRjaEV2ZW50cyxcbiAgICAgICAgICAgIHJhdGVMaW1pdCxcbiAgICAgICAgICAgIHRocm90dGxlLFxuICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICBkZWJvdW5jZSxcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgdGltZW91dHMsXG4gICAgICAgICAgICBzaW5nbGV0b24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjYW5jZWxPbikge1xuICAgICAgICAgICAgZm4uY2FuY2VsID0gY2FuY2VsT24ubWFwKCh7IGV2ZW50LCB0aW1lb3V0LCBpZjogaWZTdHIsIG1hdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnRpbWVvdXQgPSAoMCwgc3RyaW5nc19qc18xLnRpbWVTdHIpKHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmlmID0gYGV2ZW50LiR7bWF0Y2h9ID09IGFzeW5jLiR7bWF0Y2h9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaWZTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmlmID0gaWZTdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gW2ZuXTtcbiAgICAgICAgaWYgKHRoaXMub25GYWlsdXJlRm4pIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYCR7Zm4uaWR9JHtJbm5nZXN0RnVuY3Rpb24uZmFpbHVyZVN1ZmZpeH1gO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAkeyhfYiA9IGZuLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZuLmlkfSAoZmFpbHVyZSlgO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZVN0ZXBVcmwgPSBuZXcgVVJMKHN0ZXBVcmwuaHJlZik7XG4gICAgICAgICAgICBmYWlsdXJlU3RlcFVybC5zZWFyY2hQYXJhbXMuc2V0KGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5GbklkLCBpZCk7XG4gICAgICAgICAgICBjb25maWcucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogY29uc3RzX2pzXzEuaW50ZXJuYWxFdmVudHMuRnVuY3Rpb25GYWlsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBgZXZlbnQuZGF0YS5mdW5jdGlvbl9pZCA9PSAnJHtmbklkfSdgLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc3RlcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgW0lubmdlc3RGdW5jdGlvbi5zdGVwSWRdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogSW5uZ2VzdEZ1bmN0aW9uLnN0ZXBJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IElubmdlc3RGdW5jdGlvbi5zdGVwSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJodHRwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBmYWlsdXJlU3RlcFVybC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZXM6IHsgYXR0ZW1wdHM6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgY3JlYXRlRXhlY3V0aW9uKG9wdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBmbjogdGhpcyB9LCBvcHRzLnBhcnRpYWxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbkhhbmRsZXJzID0ge1xuICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYyXTogKCkgPT4gKDAsIHYyX2pzXzEuY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uKShvcHRpb25zKSxcbiAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMV06ICgpID0+ICgwLCB2MV9qc18xLmNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbikob3B0aW9ucyksXG4gICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjBdOiAoKSA9PiAoMCwgdjBfanNfMS5jcmVhdGVWMElubmdlc3RFeGVjdXRpb24pKG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdmVyc2lvbkhhbmRsZXJzW29wdHMudmVyc2lvbl0oKTtcbiAgICB9XG4gICAgc2hvdWxkT3B0aW1pemVQYXJhbGxlbGlzbSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gVE9ETyBXZSBzaG91bGQgY2hlY2sgdGhlIGNvbW1oYW5kbGVyJ3MgY2xpZW50IGluc3RlYWQgb2YgdGhpcyBvbmU/XG4gICAgICAgIHJldHVybiAoKF9iID0gKF9hID0gdGhpcy5vcHRzLm9wdGltaXplUGFyYWxsZWxpc20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY2xpZW50W1wib3B0aW9uc1wiXS5vcHRpbWl6ZVBhcmFsbGVsaXNtKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0RnVuY3Rpb24gPSBJbm5nZXN0RnVuY3Rpb247XG5Jbm5nZXN0RnVuY3Rpb24uc3RlcElkID0gXCJzdGVwXCI7XG5Jbm5nZXN0RnVuY3Rpb24uZmFpbHVyZVN1ZmZpeCA9IFwiLWZhaWx1cmVcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestFunction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestFunctionReference.js":
/*!*********************************************************************!*\
  !*** ./node_modules/inngest/components/InngestFunctionReference.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.referenceFunction = exports.InngestFunctionReference = void 0;\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nclass InngestFunctionReference {\n    constructor(opts) {\n        this.opts = opts;\n    }\n}\nexports.InngestFunctionReference = InngestFunctionReference;\n/**\n * Create a reference to an `InngestFunction` that can be used to represent both\n * local and remote functions without pulling in the full function definition\n * (i.e. dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * @public\n */\nconst referenceFunction = ({ functionId, appId, }) => {\n    return new InngestFunctionReference({\n        functionId,\n        appId,\n    });\n};\nexports.referenceFunction = referenceFunction;\n//# sourceMappingURL=InngestFunctionReference.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWZlcmVuY2VGdW5jdGlvbiA9IGV4cG9ydHMuSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlID0gdm9pZCAwO1xuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhbiBgSW5uZ2VzdEZ1bmN0aW9uYCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBib3RoIGxvY2FsXG4gKiBhbmQgcmVtb3RlIGZ1bmN0aW9ucyB3aXRob3V0IHB1bGxpbmcgaW4gdGhlIGZ1bGwgZnVuY3Rpb24gZGVmaW5pdGlvbiAoaS5lLlxuICogZGVwZW5kZW5jaWVzKS5cbiAqXG4gKiBUaGVzZSByZWZlcmVuY2VzIGNhbiBiZSBpbnZva2VkIGluIHRoZSBzYW1lIG1hbm5lciBhcyBhIHJlZ3VsYXJcbiAqIGBJbm5nZXN0RnVuY3Rpb25gLlxuICpcbiAqIFRvIGNyZWF0ZSBhIHJlZmVyZW5jZSBmdW5jdGlvbiwgdXNlIHRoZSB7QGxpbmsgcmVmZXJlbmNlRnVuY3Rpb259IGhlbHBlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIElubmdlc3RGdW5jdGlvblJlZmVyZW5jZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlID0gSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlO1xuLyoqXG4gKiBDcmVhdGUgYSByZWZlcmVuY2UgdG8gYW4gYElubmdlc3RGdW5jdGlvbmAgdGhhdCBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYm90aFxuICogbG9jYWwgYW5kIHJlbW90ZSBmdW5jdGlvbnMgd2l0aG91dCBwdWxsaW5nIGluIHRoZSBmdWxsIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAqIChpLmUuIGRlcGVuZGVuY2llcykuXG4gKlxuICogVGhlc2UgcmVmZXJlbmNlcyBjYW4gYmUgaW52b2tlZCBpbiB0aGUgc2FtZSBtYW5uZXIgYXMgYSByZWd1bGFyXG4gKiBgSW5uZ2VzdEZ1bmN0aW9uYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHJlZmVyZW5jZUZ1bmN0aW9uID0gKHsgZnVuY3Rpb25JZCwgYXBwSWQsIH0pID0+IHtcbiAgICByZXR1cm4gbmV3IElubmdlc3RGdW5jdGlvblJlZmVyZW5jZSh7XG4gICAgICAgIGZ1bmN0aW9uSWQsXG4gICAgICAgIGFwcElkLFxuICAgIH0pO1xufTtcbmV4cG9ydHMucmVmZXJlbmNlRnVuY3Rpb24gPSByZWZlcmVuY2VGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestMiddleware.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/components/InngestMiddleware.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getHookStack = exports.InngestMiddleware = void 0;\nconst functions_js_1 = __webpack_require__(/*! ../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\n/**\n * A middleware that can be registered with Inngest to hook into various\n * lifecycles of the SDK and affect input and output of Inngest functionality.\n *\n * See {@link https://innge.st/middleware}\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   middleware: [\n *     new InngestMiddleware({\n *       name: \"My Middleware\",\n *       init: () => {\n *         // ...\n *       }\n *     })\n *   ]\n * });\n * ```\n *\n * @public\n */\nclass InngestMiddleware {\n    constructor({ name, init }) {\n        this.name = name;\n        this.init = init;\n    }\n}\nexports.InngestMiddleware = InngestMiddleware;\n/**\n * Given some middleware and an entrypoint, runs the initializer for the given\n * `key` and returns functions that will pass arguments through a stack of each\n * given hook in a middleware's lifecycle.\n *\n * Lets the middleware initialize before starting.\n */\nconst getHookStack = async (\n/**\n * The stack of middleware that will be used to run hooks.\n */\nmiddleware, \n/**\n * The hook type to initialize.\n */\nkey, \n/**\n * Arguments for the initial hook.\n */\narg, transforms) => {\n    // Wait for middleware to initialize\n    const mwStack = await middleware;\n    // Step through each middleware and get the hook for the given key\n    const keyFns = mwStack.reduce((acc, mw) => {\n        const fn = mw[key];\n        if (fn) {\n            return [...acc, fn];\n        }\n        return acc;\n    }, []);\n    // Run each hook found in sequence and collect the results\n    const hooksRegistered = await keyFns.reduce(async (acc, fn) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return [...(await acc), await fn(arg)];\n    }, Promise.resolve([]));\n    // Prepare the return object - mutating this instead of using reduce as it\n    // results in cleaner code.\n    const ret = {};\n    // Step through each hook result and create a waterfall joining each key\n    for (const hook of hooksRegistered) {\n        const hookKeys = Object.keys(hook);\n        for (const key of hookKeys) {\n            let fns = [hook[key]];\n            const existingWaterfall = ret[key];\n            if (existingWaterfall) {\n                fns = [existingWaterfall, hook[key]];\n            }\n            const transform = transforms[key];\n            ret[key] = (0, functions_js_1.waterfall)(fns, transform);\n        }\n    }\n    // Cache each function in the stack to ensure each can only be called once\n    for (const k of Object.keys(ret)) {\n        const key = k;\n        ret[key] = (0, functions_js_1.cacheFn)(ret[key]);\n    }\n    return ret;\n};\nexports.getHookStack = getHookStack;\n//# sourceMappingURL=InngestMiddleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RNaWRkbGV3YXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHlCQUF5QjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvSW5uZ2VzdE1pZGRsZXdhcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEhvb2tTdGFjayA9IGV4cG9ydHMuSW5uZ2VzdE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBmdW5jdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Z1bmN0aW9ucy5qc1wiKTtcbi8qKlxuICogQSBtaWRkbGV3YXJlIHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCBJbm5nZXN0IHRvIGhvb2sgaW50byB2YXJpb3VzXG4gKiBsaWZlY3ljbGVzIG9mIHRoZSBTREsgYW5kIGFmZmVjdCBpbnB1dCBhbmQgb3V0cHV0IG9mIElubmdlc3QgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vaW5uZ2Uuc3QvbWlkZGxld2FyZX1cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBleHBvcnQgY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAqICAgbWlkZGxld2FyZTogW1xuICogICAgIG5ldyBJbm5nZXN0TWlkZGxld2FyZSh7XG4gKiAgICAgICBuYW1lOiBcIk15IE1pZGRsZXdhcmVcIixcbiAqICAgICAgIGluaXQ6ICgpID0+IHtcbiAqICAgICAgICAgLy8gLi4uXG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqICAgXVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIElubmdlc3RNaWRkbGV3YXJlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGluaXQgfSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdE1pZGRsZXdhcmUgPSBJbm5nZXN0TWlkZGxld2FyZTtcbi8qKlxuICogR2l2ZW4gc29tZSBtaWRkbGV3YXJlIGFuZCBhbiBlbnRyeXBvaW50LCBydW5zIHRoZSBpbml0aWFsaXplciBmb3IgdGhlIGdpdmVuXG4gKiBga2V5YCBhbmQgcmV0dXJucyBmdW5jdGlvbnMgdGhhdCB3aWxsIHBhc3MgYXJndW1lbnRzIHRocm91Z2ggYSBzdGFjayBvZiBlYWNoXG4gKiBnaXZlbiBob29rIGluIGEgbWlkZGxld2FyZSdzIGxpZmVjeWNsZS5cbiAqXG4gKiBMZXRzIHRoZSBtaWRkbGV3YXJlIGluaXRpYWxpemUgYmVmb3JlIHN0YXJ0aW5nLlxuICovXG5jb25zdCBnZXRIb29rU3RhY2sgPSBhc3luYyAoXG4vKipcbiAqIFRoZSBzdGFjayBvZiBtaWRkbGV3YXJlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJ1biBob29rcy5cbiAqL1xubWlkZGxld2FyZSwgXG4vKipcbiAqIFRoZSBob29rIHR5cGUgdG8gaW5pdGlhbGl6ZS5cbiAqL1xua2V5LCBcbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgaW5pdGlhbCBob29rLlxuICovXG5hcmcsIHRyYW5zZm9ybXMpID0+IHtcbiAgICAvLyBXYWl0IGZvciBtaWRkbGV3YXJlIHRvIGluaXRpYWxpemVcbiAgICBjb25zdCBtd1N0YWNrID0gYXdhaXQgbWlkZGxld2FyZTtcbiAgICAvLyBTdGVwIHRocm91Z2ggZWFjaCBtaWRkbGV3YXJlIGFuZCBnZXQgdGhlIGhvb2sgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICBjb25zdCBrZXlGbnMgPSBtd1N0YWNrLnJlZHVjZSgoYWNjLCBtdykgPT4ge1xuICAgICAgICBjb25zdCBmbiA9IG13W2tleV07XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIGZuXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICAvLyBSdW4gZWFjaCBob29rIGZvdW5kIGluIHNlcXVlbmNlIGFuZCBjb2xsZWN0IHRoZSByZXN1bHRzXG4gICAgY29uc3QgaG9va3NSZWdpc3RlcmVkID0gYXdhaXQga2V5Rm5zLnJlZHVjZShhc3luYyAoYWNjLCBmbikgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIFsuLi4oYXdhaXQgYWNjKSwgYXdhaXQgZm4oYXJnKV07XG4gICAgfSwgUHJvbWlzZS5yZXNvbHZlKFtdKSk7XG4gICAgLy8gUHJlcGFyZSB0aGUgcmV0dXJuIG9iamVjdCAtIG11dGF0aW5nIHRoaXMgaW5zdGVhZCBvZiB1c2luZyByZWR1Y2UgYXMgaXRcbiAgICAvLyByZXN1bHRzIGluIGNsZWFuZXIgY29kZS5cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICAvLyBTdGVwIHRocm91Z2ggZWFjaCBob29rIHJlc3VsdCBhbmQgY3JlYXRlIGEgd2F0ZXJmYWxsIGpvaW5pbmcgZWFjaCBrZXlcbiAgICBmb3IgKGNvbnN0IGhvb2sgb2YgaG9va3NSZWdpc3RlcmVkKSB7XG4gICAgICAgIGNvbnN0IGhvb2tLZXlzID0gT2JqZWN0LmtleXMoaG9vayk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGhvb2tLZXlzKSB7XG4gICAgICAgICAgICBsZXQgZm5zID0gW2hvb2tba2V5XV07XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1dhdGVyZmFsbCA9IHJldFtrZXldO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nV2F0ZXJmYWxsKSB7XG4gICAgICAgICAgICAgICAgZm5zID0gW2V4aXN0aW5nV2F0ZXJmYWxsLCBob29rW2tleV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1trZXldO1xuICAgICAgICAgICAgcmV0W2tleV0gPSAoMCwgZnVuY3Rpb25zX2pzXzEud2F0ZXJmYWxsKShmbnMsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FjaGUgZWFjaCBmdW5jdGlvbiBpbiB0aGUgc3RhY2sgdG8gZW5zdXJlIGVhY2ggY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMocmV0KSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrO1xuICAgICAgICByZXRba2V5XSA9ICgwLCBmdW5jdGlvbnNfanNfMS5jYWNoZUZuKShyZXRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy5nZXRIb29rU3RhY2sgPSBnZXRIb29rU3RhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0TWlkZGxld2FyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestMiddleware.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestStepTools.js":
/*!*************************************************************!*\
  !*** ./node_modules/inngest/components/InngestStepTools.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.invokePayloadSchema = exports.gatewaySymbol = exports.createStepTools = exports.STEP_INDEXING_SUFFIX = exports.getStepOptions = void 0;\nconst ai_1 = __webpack_require__(/*! @inngest/ai */ \"(rsc)/./node_modules/@inngest/ai/dist/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst Temporal = __importStar(__webpack_require__(/*! ../helpers/temporal.js */ \"(rsc)/./node_modules/inngest/helpers/temporal.js\"));\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst Fetch_js_1 = __webpack_require__(/*! ./Fetch.js */ \"(rsc)/./node_modules/inngest/components/Fetch.js\");\nconst InngestFunction_js_1 = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\nconst InngestFunctionReference_js_1 = __webpack_require__(/*! ./InngestFunctionReference.js */ \"(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\");\nconst getStepOptions = (options) => {\n    if (typeof options === \"string\") {\n        return { id: options };\n    }\n    return options;\n};\nexports.getStepOptions = getStepOptions;\n/**\n * Suffix used to namespace steps that are automatically indexed.\n */\nexports.STEP_INDEXING_SUFFIX = \":\";\n/**\n * Create a new set of step function tools ready to be used in a step function.\n * This function should be run and a fresh set of tools provided every time a\n * function is run.\n *\n * An op stack (function state) is passed in as well as some mutable properties\n * that the tools can use to submit a new op.\n */\nconst createStepTools = (client, execution, stepHandler) => {\n    /**\n     * A local helper used to create tools that can be used to submit an op.\n     *\n     * When using this function, a generic type should be provided which is the\n     * function signature exposed to the user.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const createTool = (\n    /**\n     * A function that returns an ID for this op. This is used to ensure that\n     * the op stack is correctly filled, submitted, and retrieved with the same\n     * ID.\n     *\n     * It is passed the arguments passed by the user.\n     *\n     * Most simple tools will likely only need to define this.\n     */\n    matchOp, opts) => {\n        return (async (...args) => {\n            const parsedArgs = args;\n            return stepHandler({ args: parsedArgs, matchOp, opts });\n        });\n    };\n    /**\n     * Create a new step run tool that can be used to run a step function using\n     * `step.run()` as a shim.\n     */\n    const createStepRun = (\n    /**\n     * The sub-type of this step tool, exposed via `opts.type` when the op is\n     * reported.\n     */\n    type) => {\n        return createTool(({ id, name }, _fn, ...input) => {\n            const opts = Object.assign(Object.assign({}, (input.length ? { input } : {})), (type ? { type } : {}));\n            return Object.assign({ id, op: types_js_1.StepOpCode.StepPlanned, name: id, displayName: name !== null && name !== void 0 ? name : id }, (Object.keys(opts).length ? { opts } : {}));\n        }, {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            fn: (_, fn, ...input) => fn(...input),\n        });\n    };\n    /**\n     * Define the set of tools the user has access to for their step functions.\n     *\n     * Each key is the function name and is expected to run `createTool` and pass\n     * a generic type for that function as it will appear in the user's code.\n     */\n    const tools = {\n        /**\n         * Send one or many events to Inngest. Should always be used in place of\n         * `inngest.send()` to ensure that the event send is successfully retried\n         * and not sent multiple times due to memoisation.\n         *\n         * @example\n         * ```ts\n         * await step.sendEvent(\"emit-user-creation\", {\n         *   name: \"app/user.created\",\n         *   data: { id: 123 },\n         * });\n         *\n         * await step.sendEvent(\"emit-user-updates\", [\n         *   {\n         *     name: \"app/user.created\",\n         *     data: { id: 123 },\n         *   },\n         *   {\n         *     name: \"app/user.feed.created\",\n         *     data: { id: 123 },\n         *   },\n         * ]);\n         * ```\n         *\n         * Returns a promise that will resolve once the event has been sent.\n         */\n        sendEvent: createTool(({ id, name }) => {\n            return {\n                id,\n                op: types_js_1.StepOpCode.StepPlanned,\n                name: \"sendEvent\",\n                displayName: name !== null && name !== void 0 ? name : id,\n            };\n        }, {\n            fn: (idOrOptions, payload) => {\n                return client[\"_send\"]({\n                    payload,\n                    headers: execution[\"options\"][\"headers\"],\n                });\n            },\n        }),\n        /**\n         * EXPERIMENTAL: This API is not yet stable and may change in the future\n         * without a major version bump.\n         *\n         * Wait for a particular signal to be received before continuing. When the\n         * signal is received, its data will be returned.\n         */\n        waitForSignal: createTool(({ id, name }, opts) => {\n            // TODO Should support Temporal.DurationLike, Temporal.InstantLike,\n            // Temporal.ZonedDateTimeLike\n            return {\n                id,\n                op: types_js_1.StepOpCode.WaitForSignal,\n                name: opts.signal,\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts: {\n                    signal: opts.signal,\n                    timeout: (0, strings_js_1.timeStr)(opts.timeout),\n                    conflict: opts.onConflict,\n                },\n            };\n        }),\n        /**\n         * Send a Signal to Inngest.\n         */\n        sendSignal: createTool(({ id, name }, opts) => {\n            return {\n                id,\n                op: types_js_1.StepOpCode.StepPlanned,\n                name: \"sendSignal\",\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts: {\n                    type: \"step.sendSignal\",\n                    signal: opts.signal,\n                },\n            };\n        }, {\n            fn: (_idOrOptions, opts) => {\n                return client[\"_sendSignal\"]({\n                    signal: opts.signal,\n                    data: opts.data,\n                    headers: execution[\"options\"][\"headers\"],\n                });\n            },\n        }),\n        /**\n         * Wait for a particular event to be received before continuing. When the\n         * event is received, it will be returned.\n         *\n         * You can also provide options to control the particular event that is\n         * received, for example to ensure that a user ID matches between two\n         * events, or to only wait a maximum amount of time before giving up and\n         * returning `null` instead of any event data.\n         */\n        waitForEvent: createTool(({ id, name }, \n        /**\n         * Options to control the event we're waiting for.\n         */\n        opts) => {\n            const matchOpts = {\n                timeout: (0, strings_js_1.timeStr)(typeof opts === \"string\" ? opts : opts.timeout),\n            };\n            if (typeof opts !== \"string\") {\n                if (opts === null || opts === void 0 ? void 0 : opts.match) {\n                    matchOpts.if = `event.${opts.match} == async.${opts.match}`;\n                }\n                else if (opts === null || opts === void 0 ? void 0 : opts.if) {\n                    matchOpts.if = opts.if;\n                }\n            }\n            return {\n                id,\n                op: types_js_1.StepOpCode.WaitForEvent,\n                name: opts.event,\n                opts: matchOpts,\n                displayName: name !== null && name !== void 0 ? name : id,\n            };\n        }),\n        /**\n         * Use this tool to run business logic. Each call to `run` will be retried\n         * individually, meaning you can compose complex workflows that safely\n         * retry dependent asynchronous actions.\n         *\n         * The function you pass to `run` will be called only when this \"step\" is to\n         * be executed and can be synchronous or asynchronous.\n         *\n         * In either case, the return value of the function will be the return value\n         * of the `run` tool, meaning you can return and reason about return data\n         * for next steps.\n         */\n        run: createStepRun(),\n        /**\n         * AI tooling for running AI models and other AI-related tasks.\n         */\n        ai: {\n            /**\n             * Use this tool to have Inngest make your AI calls. Useful for agentic workflows.\n             *\n             * Input is also tracked for this tool, meaning you can pass input to the\n             * function and it will be displayed and editable in the UI.\n             */\n            infer: createTool(({ id, name }, options) => {\n                var _a, _b;\n                const modelCopy = Object.assign({}, options.model);\n                // Allow the model to mutate options and body for this call\n                (_b = (_a = options.model).onCall) === null || _b === void 0 ? void 0 : _b.call(_a, modelCopy, options.body);\n                return {\n                    id,\n                    op: types_js_1.StepOpCode.AiGateway,\n                    displayName: name !== null && name !== void 0 ? name : id,\n                    opts: {\n                        type: \"step.ai.infer\",\n                        url: modelCopy.url,\n                        headers: modelCopy.headers,\n                        auth_key: modelCopy.authKey,\n                        format: modelCopy.format,\n                        body: options.body,\n                    },\n                };\n            }),\n            /**\n             * Use this tool to wrap AI models and other AI-related tasks. Each call\n             * to `wrap` will be retried individually, meaning you can compose complex\n             * workflows that safely retry dependent asynchronous actions.\n             *\n             * Input is also tracked for this tool, meaning you can pass input to the\n             * function and it will be displayed and editable in the UI.\n             */\n            wrap: createStepRun(\"step.ai.wrap\"),\n            /**\n             * Models for AI inference and other AI-related tasks.\n             */\n            models: Object.assign({}, ai_1.models),\n        },\n        /**\n         * Wait a specified amount of time before continuing.\n         *\n         * The time to wait can be specified using a `number` of milliseconds or an\n         * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`.\n         *\n         * {@link https://npm.im/ms}\n         *\n         * To wait until a particular date, use `sleepUntil` instead.\n         */\n        sleep: createTool(({ id, name }, time) => {\n            /**\n             * The presence of this operation in the returned stack indicates that the\n             * sleep is over and we should continue execution.\n             */\n            const msTimeStr = (0, strings_js_1.timeStr)(Temporal.isTemporalDuration(time)\n                ? time.total({ unit: \"milliseconds\" })\n                : time);\n            return {\n                id,\n                op: types_js_1.StepOpCode.Sleep,\n                name: msTimeStr,\n                displayName: name !== null && name !== void 0 ? name : id,\n            };\n        }),\n        /**\n         * Wait until a particular date before continuing by passing a `Date`.\n         *\n         * To wait for a particular amount of time from now, always use `sleep`\n         * instead.\n         */\n        sleepUntil: createTool(({ id, name }, time) => {\n            try {\n                const iso = Temporal.getISOString(time);\n                /**\n                 * The presence of this operation in the returned stack indicates that the\n                 * sleep is over and we should continue execution.\n                 */\n                return {\n                    id,\n                    op: types_js_1.StepOpCode.Sleep,\n                    name: iso,\n                    displayName: name !== null && name !== void 0 ? name : id,\n                };\n            }\n            catch (err) {\n                /**\n                 * If we're here, it's because the date is invalid. We'll throw a custom\n                 * error here to standardise this response.\n                 */\n                // TODO PrettyError\n                console.warn(\"Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;\", err);\n                // TODO PrettyError\n                throw new Error(`Invalid \\`Date\\`, date string, \\`Temporal.Instant\\`, or \\`Temporal.ZonedDateTime\\` passed to sleepUntil: ${\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                time}`);\n            }\n        }),\n        /**\n         * Invoke a passed Inngest `function` with the given `data`. Returns the\n         * result of the returned value of the function or `null` if the function\n         * does not return a value.\n         *\n         * A string ID can also be passed to reference functions outside of the\n         * current app.\n         */\n        invoke: createTool(({ id, name }, invokeOpts) => {\n            // Create a discriminated union to operate on based on the input types\n            // available for this tool.\n            const optsSchema = exports.invokePayloadSchema.extend({\n                timeout: zod_1.z.union([zod_1.z.number(), zod_1.z.string(), zod_1.z.date()]).optional(),\n            });\n            const parsedFnOpts = optsSchema\n                .extend({\n                _type: zod_1.z.literal(\"fullId\").optional().default(\"fullId\"),\n                function: zod_1.z.string().min(1),\n            })\n                .or(optsSchema.extend({\n                _type: zod_1.z.literal(\"fnInstance\").optional().default(\"fnInstance\"),\n                function: zod_1.z.instanceof(InngestFunction_js_1.InngestFunction),\n            }))\n                .or(optsSchema.extend({\n                _type: zod_1.z.literal(\"refInstance\").optional().default(\"refInstance\"),\n                function: zod_1.z.instanceof(InngestFunctionReference_js_1.InngestFunctionReference),\n            }))\n                .safeParse(invokeOpts);\n            if (!parsedFnOpts.success) {\n                throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);\n            }\n            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;\n            const payload = { data, user, v };\n            const opts = {\n                payload,\n                function_id: \"\",\n                timeout: typeof timeout === \"undefined\" ? undefined : (0, strings_js_1.timeStr)(timeout),\n            };\n            switch (_type) {\n                case \"fnInstance\":\n                    opts.function_id = fn.id(fn[\"client\"].id);\n                    break;\n                case \"fullId\":\n                    console.warn(`${consts_js_1.logPrefix} Invoking function with \\`function: string\\` is deprecated and will be removed in v4.0.0; use an imported function or \\`referenceFunction()\\` instead. See https://innge.st/ts-referencing-functions`);\n                    opts.function_id = fn;\n                    break;\n                case \"refInstance\":\n                    opts.function_id = [fn.opts.appId || client.id, fn.opts.functionId]\n                        .filter(Boolean)\n                        .join(\"-\");\n                    break;\n            }\n            return {\n                id,\n                op: types_js_1.StepOpCode.InvokeFunction,\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts,\n            };\n        }),\n        /**\n         * `step.fetch` is a Fetch-API-compatible function that can be used to make\n         * any HTTP code durable if it's called within an Inngest function.\n         *\n         * It will gracefully fall back to the global `fetch` if called outside of\n         * this context, and a custom fallback can be set using the `config` method.\n         */\n        fetch: Fetch_js_1.fetch,\n    };\n    // Add an uptyped gateway\n    tools[exports.gatewaySymbol] = createTool(({ id, name }, input, init) => {\n        var _a;\n        const url = input instanceof Request ? input.url : input.toString();\n        const headers = {};\n        if (input instanceof Request) {\n            input.headers.forEach((value, key) => (headers[key] = value));\n        }\n        else if (init === null || init === void 0 ? void 0 : init.headers) {\n            const h = new Headers(init.headers);\n            h.forEach((value, key) => (headers[key] = value));\n        }\n        return {\n            id,\n            op: types_js_1.StepOpCode.Gateway,\n            displayName: name !== null && name !== void 0 ? name : id,\n            opts: {\n                url,\n                method: (_a = init === null || init === void 0 ? void 0 : init.method) !== null && _a !== void 0 ? _a : \"GET\",\n                headers,\n                body: init === null || init === void 0 ? void 0 : init.body,\n            },\n        };\n    });\n    return tools;\n};\nexports.createStepTools = createStepTools;\nexports.gatewaySymbol = Symbol.for(\"inngest.step.gateway\");\n/**\n * The event payload portion of the options for `step.invoke()`. This does not\n * include non-payload options like `timeout` or the function to invoke.\n */\nexports.invokePayloadSchema = zod_1.z.object({\n    data: zod_1.z.record(zod_1.z.any()).optional(),\n    user: zod_1.z.record(zod_1.z.any()).optional(),\n    v: zod_1.z.string().optional(),\n});\n//# sourceMappingURL=InngestStepTools.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RTdGVwVG9vbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCO0FBQ3JJLGFBQWEsbUJBQU8sQ0FBQyxtRUFBYTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCw4QkFBOEIsbUJBQU8sQ0FBQyxnRkFBd0I7QUFDOUQsbUJBQW1CLG1CQUFPLENBQUMsMERBQWE7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQVk7QUFDdkMsNkJBQTZCLG1CQUFPLENBQUMsd0ZBQXNCO0FBQzNELHNDQUFzQyxtQkFBTyxDQUFDLDBHQUErQjtBQUM3RTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUM7QUFDbEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2Qyx1REFBdUQsb0JBQW9CLFFBQVEsSUFBSSxjQUFjLE9BQU8sSUFBSTtBQUNoSCxtQ0FBbUMsZ0hBQWdILGdDQUFnQyxPQUFPLElBQUk7QUFDOUwsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVksV0FBVyxXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0k7QUFDaEk7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxvQkFBb0IsOENBQThDO0FBQ2xFLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUIseUZBQXlGO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Jbm5nZXN0U3RlcFRvb2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludm9rZVBheWxvYWRTY2hlbWEgPSBleHBvcnRzLmdhdGV3YXlTeW1ib2wgPSBleHBvcnRzLmNyZWF0ZVN0ZXBUb29scyA9IGV4cG9ydHMuU1RFUF9JTkRFWElOR19TVUZGSVggPSBleHBvcnRzLmdldFN0ZXBPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgYWlfMSA9IHJlcXVpcmUoXCJAaW5uZ2VzdC9haVwiKTtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyaW5ncy5qc1wiKTtcbmNvbnN0IFRlbXBvcmFsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9oZWxwZXJzL3RlbXBvcmFsLmpzXCIpKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5jb25zdCBGZXRjaF9qc18xID0gcmVxdWlyZShcIi4vRmV0Y2guanNcIik7XG5jb25zdCBJbm5nZXN0RnVuY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL0lubmdlc3RGdW5jdGlvbi5qc1wiKTtcbmNvbnN0IElubmdlc3RGdW5jdGlvblJlZmVyZW5jZV9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlLmpzXCIpO1xuY29uc3QgZ2V0U3RlcE9wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4geyBpZDogb3B0aW9ucyB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5leHBvcnRzLmdldFN0ZXBPcHRpb25zID0gZ2V0U3RlcE9wdGlvbnM7XG4vKipcbiAqIFN1ZmZpeCB1c2VkIHRvIG5hbWVzcGFjZSBzdGVwcyB0aGF0IGFyZSBhdXRvbWF0aWNhbGx5IGluZGV4ZWQuXG4gKi9cbmV4cG9ydHMuU1RFUF9JTkRFWElOR19TVUZGSVggPSBcIjpcIjtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNldCBvZiBzdGVwIGZ1bmN0aW9uIHRvb2xzIHJlYWR5IHRvIGJlIHVzZWQgaW4gYSBzdGVwIGZ1bmN0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgcnVuIGFuZCBhIGZyZXNoIHNldCBvZiB0b29scyBwcm92aWRlZCBldmVyeSB0aW1lIGFcbiAqIGZ1bmN0aW9uIGlzIHJ1bi5cbiAqXG4gKiBBbiBvcCBzdGFjayAoZnVuY3Rpb24gc3RhdGUpIGlzIHBhc3NlZCBpbiBhcyB3ZWxsIGFzIHNvbWUgbXV0YWJsZSBwcm9wZXJ0aWVzXG4gKiB0aGF0IHRoZSB0b29scyBjYW4gdXNlIHRvIHN1Ym1pdCBhIG5ldyBvcC5cbiAqL1xuY29uc3QgY3JlYXRlU3RlcFRvb2xzID0gKGNsaWVudCwgZXhlY3V0aW9uLCBzdGVwSGFuZGxlcikgPT4ge1xuICAgIC8qKlxuICAgICAqIEEgbG9jYWwgaGVscGVyIHVzZWQgdG8gY3JlYXRlIHRvb2xzIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3VibWl0IGFuIG9wLlxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyB0aGlzIGZ1bmN0aW9uLCBhIGdlbmVyaWMgdHlwZSBzaG91bGQgYmUgcHJvdmlkZWQgd2hpY2ggaXMgdGhlXG4gICAgICogZnVuY3Rpb24gc2lnbmF0dXJlIGV4cG9zZWQgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBjcmVhdGVUb29sID0gKFxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIElEIGZvciB0aGlzIG9wLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXRcbiAgICAgKiB0aGUgb3Agc3RhY2sgaXMgY29ycmVjdGx5IGZpbGxlZCwgc3VibWl0dGVkLCBhbmQgcmV0cmlldmVkIHdpdGggdGhlIHNhbWVcbiAgICAgKiBJRC5cbiAgICAgKlxuICAgICAqIEl0IGlzIHBhc3NlZCB0aGUgYXJndW1lbnRzIHBhc3NlZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIE1vc3Qgc2ltcGxlIHRvb2xzIHdpbGwgbGlrZWx5IG9ubHkgbmVlZCB0byBkZWZpbmUgdGhpcy5cbiAgICAgKi9cbiAgICBtYXRjaE9wLCBvcHRzKSA9PiB7XG4gICAgICAgIHJldHVybiAoYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXBIYW5kbGVyKHsgYXJnczogcGFyc2VkQXJncywgbWF0Y2hPcCwgb3B0cyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RlcCBydW4gdG9vbCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJ1biBhIHN0ZXAgZnVuY3Rpb24gdXNpbmdcbiAgICAgKiBgc3RlcC5ydW4oKWAgYXMgYSBzaGltLlxuICAgICAqL1xuICAgIGNvbnN0IGNyZWF0ZVN0ZXBSdW4gPSAoXG4gICAgLyoqXG4gICAgICogVGhlIHN1Yi10eXBlIG9mIHRoaXMgc3RlcCB0b29sLCBleHBvc2VkIHZpYSBgb3B0cy50eXBlYCB3aGVuIHRoZSBvcCBpc1xuICAgICAqIHJlcG9ydGVkLlxuICAgICAqL1xuICAgIHR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgX2ZuLCAuLi5pbnB1dCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGlucHV0Lmxlbmd0aCA/IHsgaW5wdXQgfSA6IHt9KSksICh0eXBlID8geyB0eXBlIH0gOiB7fSkpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBpZCwgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZCwgbmFtZTogaWQsIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCB9LCAoT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID8geyBvcHRzIH0gOiB7fSkpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgZm46IChfLCBmbiwgLi4uaW5wdXQpID0+IGZuKC4uLmlucHV0KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmUgdGhlIHNldCBvZiB0b29scyB0aGUgdXNlciBoYXMgYWNjZXNzIHRvIGZvciB0aGVpciBzdGVwIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEVhY2gga2V5IGlzIHRoZSBmdW5jdGlvbiBuYW1lIGFuZCBpcyBleHBlY3RlZCB0byBydW4gYGNyZWF0ZVRvb2xgIGFuZCBwYXNzXG4gICAgICogYSBnZW5lcmljIHR5cGUgZm9yIHRoYXQgZnVuY3Rpb24gYXMgaXQgd2lsbCBhcHBlYXIgaW4gdGhlIHVzZXIncyBjb2RlLlxuICAgICAqL1xuICAgIGNvbnN0IHRvb2xzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBvbmUgb3IgbWFueSBldmVudHMgdG8gSW5uZ2VzdC4gU2hvdWxkIGFsd2F5cyBiZSB1c2VkIGluIHBsYWNlIG9mXG4gICAgICAgICAqIGBpbm5nZXN0LnNlbmQoKWAgdG8gZW5zdXJlIHRoYXQgdGhlIGV2ZW50IHNlbmQgaXMgc3VjY2Vzc2Z1bGx5IHJldHJpZWRcbiAgICAgICAgICogYW5kIG5vdCBzZW50IG11bHRpcGxlIHRpbWVzIGR1ZSB0byBtZW1vaXNhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogYXdhaXQgc3RlcC5zZW5kRXZlbnQoXCJlbWl0LXVzZXItY3JlYXRpb25cIiwge1xuICAgICAgICAgKiAgIG5hbWU6IFwiYXBwL3VzZXIuY3JlYXRlZFwiLFxuICAgICAgICAgKiAgIGRhdGE6IHsgaWQ6IDEyMyB9LFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogYXdhaXQgc3RlcC5zZW5kRXZlbnQoXCJlbWl0LXVzZXItdXBkYXRlc1wiLCBbXG4gICAgICAgICAqICAge1xuICAgICAgICAgKiAgICAgbmFtZTogXCJhcHAvdXNlci5jcmVhdGVkXCIsXG4gICAgICAgICAqICAgICBkYXRhOiB7IGlkOiAxMjMgfSxcbiAgICAgICAgICogICB9LFxuICAgICAgICAgKiAgIHtcbiAgICAgICAgICogICAgIG5hbWU6IFwiYXBwL3VzZXIuZmVlZC5jcmVhdGVkXCIsXG4gICAgICAgICAqICAgICBkYXRhOiB7IGlkOiAxMjMgfSxcbiAgICAgICAgICogICB9LFxuICAgICAgICAgKiBdKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIGV2ZW50IGhhcyBiZWVuIHNlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBzZW5kRXZlbnQ6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2VuZEV2ZW50XCIsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZm46IChpZE9yT3B0aW9ucywgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRbXCJfc2VuZFwiXSh7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGV4ZWN1dGlvbltcIm9wdGlvbnNcIl1bXCJoZWFkZXJzXCJdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFWFBFUklNRU5UQUw6IFRoaXMgQVBJIGlzIG5vdCB5ZXQgc3RhYmxlIGFuZCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmVcbiAgICAgICAgICogd2l0aG91dCBhIG1ham9yIHZlcnNpb24gYnVtcC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2FpdCBmb3IgYSBwYXJ0aWN1bGFyIHNpZ25hbCB0byBiZSByZWNlaXZlZCBiZWZvcmUgY29udGludWluZy4gV2hlbiB0aGVcbiAgICAgICAgICogc2lnbmFsIGlzIHJlY2VpdmVkLCBpdHMgZGF0YSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgd2FpdEZvclNpZ25hbDogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBvcHRzKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPIFNob3VsZCBzdXBwb3J0IFRlbXBvcmFsLkR1cmF0aW9uTGlrZSwgVGVtcG9yYWwuSW5zdGFudExpa2UsXG4gICAgICAgICAgICAvLyBUZW1wb3JhbC5ab25lZERhdGVUaW1lTGlrZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLldhaXRGb3JTaWduYWwsXG4gICAgICAgICAgICAgICAgbmFtZTogb3B0cy5zaWduYWwsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRzLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogKDAsIHN0cmluZ3NfanNfMS50aW1lU3RyKShvcHRzLnRpbWVvdXQpLFxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdDogb3B0cy5vbkNvbmZsaWN0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgYSBTaWduYWwgdG8gSW5uZ2VzdC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbmRTaWduYWw6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgb3B0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2VuZFNpZ25hbFwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCxcbiAgICAgICAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC5zZW5kU2lnbmFsXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0cy5zaWduYWwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGZuOiAoX2lkT3JPcHRpb25zLCBvcHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFtcIl9zZW5kU2lnbmFsXCJdKHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRzLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogb3B0cy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBleGVjdXRpb25bXCJvcHRpb25zXCJdW1wiaGVhZGVyc1wiXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2FpdCBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IHRvIGJlIHJlY2VpdmVkIGJlZm9yZSBjb250aW51aW5nLiBXaGVuIHRoZVxuICAgICAgICAgKiBldmVudCBpcyByZWNlaXZlZCwgaXQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgb3B0aW9ucyB0byBjb250cm9sIHRoZSBwYXJ0aWN1bGFyIGV2ZW50IHRoYXQgaXNcbiAgICAgICAgICogcmVjZWl2ZWQsIGZvciBleGFtcGxlIHRvIGVuc3VyZSB0aGF0IGEgdXNlciBJRCBtYXRjaGVzIGJldHdlZW4gdHdvXG4gICAgICAgICAqIGV2ZW50cywgb3IgdG8gb25seSB3YWl0IGEgbWF4aW11bSBhbW91bnQgb2YgdGltZSBiZWZvcmUgZ2l2aW5nIHVwIGFuZFxuICAgICAgICAgKiByZXR1cm5pbmcgYG51bGxgIGluc3RlYWQgb2YgYW55IGV2ZW50IGRhdGEuXG4gICAgICAgICAqL1xuICAgICAgICB3YWl0Rm9yRXZlbnQ6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zIHRvIGNvbnRyb2wgdGhlIGV2ZW50IHdlJ3JlIHdhaXRpbmcgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgb3B0cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hPcHRzID0ge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6ICgwLCBzdHJpbmdzX2pzXzEudGltZVN0cikodHlwZW9mIG9wdHMgPT09IFwic3RyaW5nXCIgPyBvcHRzIDogb3B0cy50aW1lb3V0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLm1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoT3B0cy5pZiA9IGBldmVudC4ke29wdHMubWF0Y2h9ID09IGFzeW5jLiR7b3B0cy5tYXRjaH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuaWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hPcHRzLmlmID0gb3B0cy5pZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuV2FpdEZvckV2ZW50LFxuICAgICAgICAgICAgICAgIG5hbWU6IG9wdHMuZXZlbnQsXG4gICAgICAgICAgICAgICAgb3B0czogbWF0Y2hPcHRzLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIHRoaXMgdG9vbCB0byBydW4gYnVzaW5lc3MgbG9naWMuIEVhY2ggY2FsbCB0byBgcnVuYCB3aWxsIGJlIHJldHJpZWRcbiAgICAgICAgICogaW5kaXZpZHVhbGx5LCBtZWFuaW5nIHlvdSBjYW4gY29tcG9zZSBjb21wbGV4IHdvcmtmbG93cyB0aGF0IHNhZmVseVxuICAgICAgICAgKiByZXRyeSBkZXBlbmRlbnQgYXN5bmNocm9ub3VzIGFjdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiB5b3UgcGFzcyB0byBgcnVuYCB3aWxsIGJlIGNhbGxlZCBvbmx5IHdoZW4gdGhpcyBcInN0ZXBcIiBpcyB0b1xuICAgICAgICAgKiBiZSBleGVjdXRlZCBhbmQgY2FuIGJlIHN5bmNocm9ub3VzIG9yIGFzeW5jaHJvbm91cy5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gZWl0aGVyIGNhc2UsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBvZiB0aGUgYHJ1bmAgdG9vbCwgbWVhbmluZyB5b3UgY2FuIHJldHVybiBhbmQgcmVhc29uIGFib3V0IHJldHVybiBkYXRhXG4gICAgICAgICAqIGZvciBuZXh0IHN0ZXBzLlxuICAgICAgICAgKi9cbiAgICAgICAgcnVuOiBjcmVhdGVTdGVwUnVuKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBSSB0b29saW5nIGZvciBydW5uaW5nIEFJIG1vZGVscyBhbmQgb3RoZXIgQUktcmVsYXRlZCB0YXNrcy5cbiAgICAgICAgICovXG4gICAgICAgIGFpOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZSB0aGlzIHRvb2wgdG8gaGF2ZSBJbm5nZXN0IG1ha2UgeW91ciBBSSBjYWxscy4gVXNlZnVsIGZvciBhZ2VudGljIHdvcmtmbG93cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbnB1dCBpcyBhbHNvIHRyYWNrZWQgZm9yIHRoaXMgdG9vbCwgbWVhbmluZyB5b3UgY2FuIHBhc3MgaW5wdXQgdG8gdGhlXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiBhbmQgaXQgd2lsbCBiZSBkaXNwbGF5ZWQgYW5kIGVkaXRhYmxlIGluIHRoZSBVSS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5mZXI6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIG1vZGVsIHRvIG11dGF0ZSBvcHRpb25zIGFuZCBib2R5IGZvciB0aGlzIGNhbGxcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBvcHRpb25zLm1vZGVsKS5vbkNhbGwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBtb2RlbENvcHksIG9wdGlvbnMuYm9keSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuQWlHYXRld2F5LFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC5haS5pbmZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBtb2RlbENvcHkudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogbW9kZWxDb3B5LmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoX2tleTogbW9kZWxDb3B5LmF1dGhLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IG1vZGVsQ29weS5mb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2UgdGhpcyB0b29sIHRvIHdyYXAgQUkgbW9kZWxzIGFuZCBvdGhlciBBSS1yZWxhdGVkIHRhc2tzLiBFYWNoIGNhbGxcbiAgICAgICAgICAgICAqIHRvIGB3cmFwYCB3aWxsIGJlIHJldHJpZWQgaW5kaXZpZHVhbGx5LCBtZWFuaW5nIHlvdSBjYW4gY29tcG9zZSBjb21wbGV4XG4gICAgICAgICAgICAgKiB3b3JrZmxvd3MgdGhhdCBzYWZlbHkgcmV0cnkgZGVwZW5kZW50IGFzeW5jaHJvbm91cyBhY3Rpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIElucHV0IGlzIGFsc28gdHJhY2tlZCBmb3IgdGhpcyB0b29sLCBtZWFuaW5nIHlvdSBjYW4gcGFzcyBpbnB1dCB0byB0aGVcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uIGFuZCBpdCB3aWxsIGJlIGRpc3BsYXllZCBhbmQgZWRpdGFibGUgaW4gdGhlIFVJLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB3cmFwOiBjcmVhdGVTdGVwUnVuKFwic3RlcC5haS53cmFwXCIpLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNb2RlbHMgZm9yIEFJIGluZmVyZW5jZSBhbmQgb3RoZXIgQUktcmVsYXRlZCB0YXNrcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbW9kZWxzOiBPYmplY3QuYXNzaWduKHt9LCBhaV8xLm1vZGVscyksXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYWl0IGEgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdGltZSB0byB3YWl0IGNhbiBiZSBzcGVjaWZpZWQgdXNpbmcgYSBgbnVtYmVyYCBvZiBtaWxsaXNlY29uZHMgb3IgYW5cbiAgICAgICAgICogYG1zYC1jb21wYXRpYmxlIHRpbWUgc3RyaW5nIGxpa2UgYFwiMSBob3VyXCJgLCBgXCIzMCBtaW5zXCJgLCBvciBgXCIyLjVkXCJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9ucG0uaW0vbXN9XG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHdhaXQgdW50aWwgYSBwYXJ0aWN1bGFyIGRhdGUsIHVzZSBgc2xlZXBVbnRpbGAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHNsZWVwOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIHRpbWUpID0+IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHByZXNlbmNlIG9mIHRoaXMgb3BlcmF0aW9uIGluIHRoZSByZXR1cm5lZCBzdGFjayBpbmRpY2F0ZXMgdGhhdCB0aGVcbiAgICAgICAgICAgICAqIHNsZWVwIGlzIG92ZXIgYW5kIHdlIHNob3VsZCBjb250aW51ZSBleGVjdXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG1zVGltZVN0ciA9ICgwLCBzdHJpbmdzX2pzXzEudGltZVN0cikoVGVtcG9yYWwuaXNUZW1wb3JhbER1cmF0aW9uKHRpbWUpXG4gICAgICAgICAgICAgICAgPyB0aW1lLnRvdGFsKHsgdW5pdDogXCJtaWxsaXNlY29uZHNcIiB9KVxuICAgICAgICAgICAgICAgIDogdGltZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU2xlZXAsXG4gICAgICAgICAgICAgICAgbmFtZTogbXNUaW1lU3RyLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2FpdCB1bnRpbCBhIHBhcnRpY3VsYXIgZGF0ZSBiZWZvcmUgY29udGludWluZyBieSBwYXNzaW5nIGEgYERhdGVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyB3YWl0IGZvciBhIHBhcnRpY3VsYXIgYW1vdW50IG9mIHRpbWUgZnJvbSBub3csIGFsd2F5cyB1c2UgYHNsZWVwYFxuICAgICAgICAgKiBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2xlZXBVbnRpbDogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCB0aW1lKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzbyA9IFRlbXBvcmFsLmdldElTT1N0cmluZyh0aW1lKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyBvcGVyYXRpb24gaW4gdGhlIHJldHVybmVkIHN0YWNrIGluZGljYXRlcyB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAqIHNsZWVwIGlzIG92ZXIgYW5kIHdlIHNob3VsZCBjb250aW51ZSBleGVjdXRpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU2xlZXAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGlzbyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgd2UncmUgaGVyZSwgaXQncyBiZWNhdXNlIHRoZSBkYXRlIGlzIGludmFsaWQuIFdlJ2xsIHRocm93IGEgY3VzdG9tXG4gICAgICAgICAgICAgICAgICogZXJyb3IgaGVyZSB0byBzdGFuZGFyZGlzZSB0aGlzIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIGBEYXRlYCwgZGF0ZSBzdHJpbmcsIGBUZW1wb3JhbC5JbnN0YW50YCwgb3IgYFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVgIHBhc3NlZCB0byBzbGVlcFVudGlsO1wiLCBlcnIpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXFxgRGF0ZVxcYCwgZGF0ZSBzdHJpbmcsIFxcYFRlbXBvcmFsLkluc3RhbnRcXGAsIG9yIFxcYFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVcXGAgcGFzc2VkIHRvIHNsZWVwVW50aWw6ICR7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB0aW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludm9rZSBhIHBhc3NlZCBJbm5nZXN0IGBmdW5jdGlvbmAgd2l0aCB0aGUgZ2l2ZW4gYGRhdGFgLiBSZXR1cm5zIHRoZVxuICAgICAgICAgKiByZXN1bHQgb2YgdGhlIHJldHVybmVkIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBvciBgbnVsbGAgaWYgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAqIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHN0cmluZyBJRCBjYW4gYWxzbyBiZSBwYXNzZWQgdG8gcmVmZXJlbmNlIGZ1bmN0aW9ucyBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAgKiBjdXJyZW50IGFwcC5cbiAgICAgICAgICovXG4gICAgICAgIGludm9rZTogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBpbnZva2VPcHRzKSA9PiB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBkaXNjcmltaW5hdGVkIHVuaW9uIHRvIG9wZXJhdGUgb24gYmFzZWQgb24gdGhlIGlucHV0IHR5cGVzXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUgZm9yIHRoaXMgdG9vbC5cbiAgICAgICAgICAgIGNvbnN0IG9wdHNTY2hlbWEgPSBleHBvcnRzLmludm9rZVBheWxvYWRTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB6b2RfMS56LnVuaW9uKFt6b2RfMS56Lm51bWJlcigpLCB6b2RfMS56LnN0cmluZygpLCB6b2RfMS56LmRhdGUoKV0pLm9wdGlvbmFsKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEZuT3B0cyA9IG9wdHNTY2hlbWFcbiAgICAgICAgICAgICAgICAuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBfdHlwZTogem9kXzEuei5saXRlcmFsKFwiZnVsbElkXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcImZ1bGxJZFwiKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogem9kXzEuei5zdHJpbmcoKS5taW4oMSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vcihvcHRzU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgX3R5cGU6IHpvZF8xLnoubGl0ZXJhbChcImZuSW5zdGFuY2VcIikub3B0aW9uYWwoKS5kZWZhdWx0KFwiZm5JbnN0YW5jZVwiKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogem9kXzEuei5pbnN0YW5jZW9mKElubmdlc3RGdW5jdGlvbl9qc18xLklubmdlc3RGdW5jdGlvbiksXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAub3Iob3B0c1NjaGVtYS5leHRlbmQoe1xuICAgICAgICAgICAgICAgIF90eXBlOiB6b2RfMS56LmxpdGVyYWwoXCJyZWZJbnN0YW5jZVwiKS5vcHRpb25hbCgpLmRlZmF1bHQoXCJyZWZJbnN0YW5jZVwiKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogem9kXzEuei5pbnN0YW5jZW9mKElubmdlc3RGdW5jdGlvblJlZmVyZW5jZV9qc18xLklubmdlc3RGdW5jdGlvblJlZmVyZW5jZSksXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAuc2FmZVBhcnNlKGludm9rZU9wdHMpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZWRGbk9wdHMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnZvY2F0aW9uIG9wdGlvbnMgcGFzc2VkIHRvIGludm9rZTsgbXVzdCBpbmNsdWRlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGZ1bmN0aW9uSWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IF90eXBlLCBmdW5jdGlvbjogZm4sIGRhdGEsIHVzZXIsIHYsIHRpbWVvdXQgfSA9IHBhcnNlZEZuT3B0cy5kYXRhO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHsgZGF0YSwgdXNlciwgdiB9O1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uX2lkOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkIDogKDAsIHN0cmluZ3NfanNfMS50aW1lU3RyKSh0aW1lb3V0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZuSW5zdGFuY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5mdW5jdGlvbl9pZCA9IGZuLmlkKGZuW1wiY2xpZW50XCJdLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bGxJZFwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y29uc3RzX2pzXzEubG9nUHJlZml4fSBJbnZva2luZyBmdW5jdGlvbiB3aXRoIFxcYGZ1bmN0aW9uOiBzdHJpbmdcXGAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY0LjAuMDsgdXNlIGFuIGltcG9ydGVkIGZ1bmN0aW9uIG9yIFxcYHJlZmVyZW5jZUZ1bmN0aW9uKClcXGAgaW5zdGVhZC4gU2VlIGh0dHBzOi8vaW5uZ2Uuc3QvdHMtcmVmZXJlbmNpbmctZnVuY3Rpb25zYCk7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZnVuY3Rpb25faWQgPSBmbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlZkluc3RhbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZnVuY3Rpb25faWQgPSBbZm4ub3B0cy5hcHBJZCB8fCBjbGllbnQuaWQsIGZuLm9wdHMuZnVuY3Rpb25JZF1cbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiLVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuSW52b2tlRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBzdGVwLmZldGNoYCBpcyBhIEZldGNoLUFQSS1jb21wYXRpYmxlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZVxuICAgICAgICAgKiBhbnkgSFRUUCBjb2RlIGR1cmFibGUgaWYgaXQncyBjYWxsZWQgd2l0aGluIGFuIElubmdlc3QgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHdpbGwgZ3JhY2VmdWxseSBmYWxsIGJhY2sgdG8gdGhlIGdsb2JhbCBgZmV0Y2hgIGlmIGNhbGxlZCBvdXRzaWRlIG9mXG4gICAgICAgICAqIHRoaXMgY29udGV4dCwgYW5kIGEgY3VzdG9tIGZhbGxiYWNrIGNhbiBiZSBzZXQgdXNpbmcgdGhlIGBjb25maWdgIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIGZldGNoOiBGZXRjaF9qc18xLmZldGNoLFxuICAgIH07XG4gICAgLy8gQWRkIGFuIHVwdHlwZWQgZ2F0ZXdheVxuICAgIHRvb2xzW2V4cG9ydHMuZ2F0ZXdheVN5bWJvbF0gPSBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIGlucHV0LCBpbml0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdXJsID0gaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gaW5wdXQudXJsIDogaW5wdXQudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgICAgICBpbnB1dC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IChoZWFkZXJzW2tleV0gPSB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKTtcbiAgICAgICAgICAgIGguZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gKGhlYWRlcnNba2V5XSA9IHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5HYXRld2F5LFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChfYSA9IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5tZXRob2QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuYm9keSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvb2xzO1xufTtcbmV4cG9ydHMuY3JlYXRlU3RlcFRvb2xzID0gY3JlYXRlU3RlcFRvb2xzO1xuZXhwb3J0cy5nYXRld2F5U3ltYm9sID0gU3ltYm9sLmZvcihcImlubmdlc3Quc3RlcC5nYXRld2F5XCIpO1xuLyoqXG4gKiBUaGUgZXZlbnQgcGF5bG9hZCBwb3J0aW9uIG9mIHRoZSBvcHRpb25zIGZvciBgc3RlcC5pbnZva2UoKWAuIFRoaXMgZG9lcyBub3RcbiAqIGluY2x1ZGUgbm9uLXBheWxvYWQgb3B0aW9ucyBsaWtlIGB0aW1lb3V0YCBvciB0aGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICovXG5leHBvcnRzLmludm9rZVBheWxvYWRTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgZGF0YTogem9kXzEuei5yZWNvcmQoem9kXzEuei5hbnkoKSkub3B0aW9uYWwoKSxcbiAgICB1c2VyOiB6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKS5vcHRpb25hbCgpLFxuICAgIHY6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZ2VzdFN0ZXBUb29scy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestStepTools.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/NonRetriableError.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/components/NonRetriableError.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NonRetriableError = void 0;\n/**\n * An error that, when thrown, indicates to Inngest that the function should\n * cease all execution and not retry.\n *\n * A `message` must be provided, and an optional `cause` can be provided to\n * provide more context to the error.\n *\n * @public\n */\nclass NonRetriableError extends Error {\n    constructor(message, options) {\n        super(message);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.cause = options === null || options === void 0 ? void 0 : options.cause;\n        this.name = \"NonRetriableError\";\n    }\n}\nexports.NonRetriableError = NonRetriableError;\n//# sourceMappingURL=NonRetriableError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvTm9uUmV0cmlhYmxlRXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vblJldHJpYWJsZUVycm9yID0gdm9pZCAwO1xuLyoqXG4gKiBBbiBlcnJvciB0aGF0LCB3aGVuIHRocm93biwgaW5kaWNhdGVzIHRvIElubmdlc3QgdGhhdCB0aGUgZnVuY3Rpb24gc2hvdWxkXG4gKiBjZWFzZSBhbGwgZXhlY3V0aW9uIGFuZCBub3QgcmV0cnkuXG4gKlxuICogQSBgbWVzc2FnZWAgbXVzdCBiZSBwcm92aWRlZCwgYW5kIGFuIG9wdGlvbmFsIGBjYXVzZWAgY2FuIGJlIHByb3ZpZGVkIHRvXG4gKiBwcm92aWRlIG1vcmUgY29udGV4dCB0byB0aGUgZXJyb3IuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBOb25SZXRyaWFibGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2F1c2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTm9uUmV0cmlhYmxlRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLk5vblJldHJpYWJsZUVycm9yID0gTm9uUmV0cmlhYmxlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob25SZXRyaWFibGVFcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/NonRetriableError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/RetryAfterError.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/components/RetryAfterError.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RetryAfterError = void 0;\nconst ms_1 = __importDefault(__webpack_require__(/*! ms */ \"(rsc)/./node_modules/inngest/node_modules/ms/index.js\"));\n/**\n * An error that, when thrown, indicates to Inngest that the function should be\n * retried after a given amount of time.\n *\n * A `message` must be provided, as well as a `retryAfter` parameter, which can\n * be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.\n *\n * An optional `cause` can be provided to provide more context to the error.\n *\n * @public\n */\nclass RetryAfterError extends Error {\n    constructor(message, \n    /**\n     * The time after which the function should be retried. Represents either a\n     * number of milliseconds or a RFC3339 date.\n     */\n    retryAfter, options) {\n        super(message);\n        if (retryAfter instanceof Date) {\n            this.retryAfter = retryAfter.toISOString();\n        }\n        else {\n            const seconds = `${Math.ceil((typeof retryAfter === \"string\" ? (0, ms_1.default)(retryAfter) : retryAfter) / 1000)}`;\n            if (!isFinite(Number(seconds))) {\n                throw new Error(\"retryAfter must be a number of milliseconds, a ms-compatible string, or a Date\");\n            }\n            this.retryAfter = seconds;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.cause = options === null || options === void 0 ? void 0 : options.cause;\n    }\n}\nexports.RetryAfterError = RetryAfterError;\n//# sourceMappingURL=RetryAfterError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1JldHJ5QWZ0ZXJFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2Qiw2QkFBNkIsbUJBQU8sQ0FBQyxpRUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdHQUFnRztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9SZXRyeUFmdGVyRXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJldHJ5QWZ0ZXJFcnJvciA9IHZvaWQgMDtcbmNvbnN0IG1zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1zXCIpKTtcbi8qKlxuICogQW4gZXJyb3IgdGhhdCwgd2hlbiB0aHJvd24sIGluZGljYXRlcyB0byBJbm5nZXN0IHRoYXQgdGhlIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogcmV0cmllZCBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLlxuICpcbiAqIEEgYG1lc3NhZ2VgIG11c3QgYmUgcHJvdmlkZWQsIGFzIHdlbGwgYXMgYSBgcmV0cnlBZnRlcmAgcGFyYW1ldGVyLCB3aGljaCBjYW5cbiAqIGJlIGEgYG51bWJlcmAgb2YgbWlsbGlzZWNvbmRzLCBhbiBgbXNgLWNvbXBhdGlibGUgdGltZSBzdHJpbmcsIG9yIGEgYERhdGVgLlxuICpcbiAqIEFuIG9wdGlvbmFsIGBjYXVzZWAgY2FuIGJlIHByb3ZpZGVkIHRvIHByb3ZpZGUgbW9yZSBjb250ZXh0IHRvIHRoZSBlcnJvci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFJldHJ5QWZ0ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBhZnRlciB3aGljaCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIHJldHJpZWQuIFJlcHJlc2VudHMgZWl0aGVyIGFcbiAgICAgKiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIGEgUkZDMzMzOSBkYXRlLlxuICAgICAqL1xuICAgIHJldHJ5QWZ0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXRyeUFmdGVyID0gcmV0cnlBZnRlci50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IGAke01hdGguY2VpbCgodHlwZW9mIHJldHJ5QWZ0ZXIgPT09IFwic3RyaW5nXCIgPyAoMCwgbXNfMS5kZWZhdWx0KShyZXRyeUFmdGVyKSA6IHJldHJ5QWZ0ZXIpIC8gMTAwMCl9YDtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoTnVtYmVyKHNlY29uZHMpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJldHJ5QWZ0ZXIgbXVzdCBiZSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGEgbXMtY29tcGF0aWJsZSBzdHJpbmcsIG9yIGEgRGF0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmV0cnlBZnRlciA9IHNlY29uZHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhdXNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUmV0cnlBZnRlckVycm9yID0gUmV0cnlBZnRlckVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmV0cnlBZnRlckVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/RetryAfterError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/StepError.js":
/*!******************************************************!*\
  !*** ./node_modules/inngest/components/StepError.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StepError = void 0;\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/**\n * An error that represents a step exhausting all retries and failing. This is\n * thrown by an Inngest step if it fails.\n *\n * It's synonymous with an `Error`, with the addition of the `stepId` that\n * failed.\n *\n * @public\n */\nclass StepError extends Error {\n    constructor(\n    /**\n     * The ID of the step that failed.\n     */\n    stepId, err) {\n        var _a;\n        const parsedErr = types_js_1.jsonErrorSchema.parse(err);\n        super(parsedErr.message);\n        this.stepId = stepId;\n        this.name = parsedErr.name;\n        this.stepId = stepId;\n        // Don't show the internal stack trace if we don't have one.\n        this.stack = (_a = parsedErr.stack) !== null && _a !== void 0 ? _a : undefined;\n        // Try setting the cause if we have one\n        this.cause = parsedErr.cause\n            ? (0, errors_js_1.deserializeError)(parsedErr.cause, true)\n            : undefined;\n    }\n}\nexports.StepError = StepError;\n//# sourceMappingURL=StepError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1N0ZXBFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9TdGVwRXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0ZXBFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZXJyb3JzLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbi8qKlxuICogQW4gZXJyb3IgdGhhdCByZXByZXNlbnRzIGEgc3RlcCBleGhhdXN0aW5nIGFsbCByZXRyaWVzIGFuZCBmYWlsaW5nLiBUaGlzIGlzXG4gKiB0aHJvd24gYnkgYW4gSW5uZ2VzdCBzdGVwIGlmIGl0IGZhaWxzLlxuICpcbiAqIEl0J3Mgc3lub255bW91cyB3aXRoIGFuIGBFcnJvcmAsIHdpdGggdGhlIGFkZGl0aW9uIG9mIHRoZSBgc3RlcElkYCB0aGF0XG4gKiBmYWlsZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBTdGVwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoZSBzdGVwIHRoYXQgZmFpbGVkLlxuICAgICAqL1xuICAgIHN0ZXBJZCwgZXJyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcGFyc2VkRXJyID0gdHlwZXNfanNfMS5qc29uRXJyb3JTY2hlbWEucGFyc2UoZXJyKTtcbiAgICAgICAgc3VwZXIocGFyc2VkRXJyLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN0ZXBJZCA9IHN0ZXBJZDtcbiAgICAgICAgdGhpcy5uYW1lID0gcGFyc2VkRXJyLm5hbWU7XG4gICAgICAgIHRoaXMuc3RlcElkID0gc3RlcElkO1xuICAgICAgICAvLyBEb24ndCBzaG93IHRoZSBpbnRlcm5hbCBzdGFjayB0cmFjZSBpZiB3ZSBkb24ndCBoYXZlIG9uZS5cbiAgICAgICAgdGhpcy5zdGFjayA9IChfYSA9IHBhcnNlZEVyci5zdGFjaykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgc2V0dGluZyB0aGUgY2F1c2UgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgdGhpcy5jYXVzZSA9IHBhcnNlZEVyci5jYXVzZVxuICAgICAgICAgICAgPyAoMCwgZXJyb3JzX2pzXzEuZGVzZXJpYWxpemVFcnJvcikocGFyc2VkRXJyLmNhdXNlLCB0cnVlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdGVwRXJyb3IgPSBTdGVwRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGVwRXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/StepError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/InngestExecution.js":
/*!***********************************************************************!*\
  !*** ./node_modules/inngest/components/execution/InngestExecution.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestExecution = exports.PREFERRED_EXECUTION_VERSION = exports.ExecutionVersion = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/inngest/node_modules/debug/src/index.js\"));\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/**\n * The execution models the SDK is aware of.\n *\n * This is used in a number of places to ensure all execution versions are\n * accounted for for a given operation.\n */\nvar ExecutionVersion;\n(function (ExecutionVersion) {\n    ExecutionVersion[ExecutionVersion[\"V0\"] = 0] = \"V0\";\n    ExecutionVersion[ExecutionVersion[\"V1\"] = 1] = \"V1\";\n    ExecutionVersion[ExecutionVersion[\"V2\"] = 2] = \"V2\";\n})(ExecutionVersion || (exports.ExecutionVersion = ExecutionVersion = {}));\n/**\n * The preferred execution version that will be used by the SDK when handling\n * brand new runs where the Executor is allowing us to choose.\n *\n * Changing this should not ever be a breaking change, as this will only change\n * new runs, not existing ones.\n */\nexports.PREFERRED_EXECUTION_VERSION = ExecutionVersion.V1;\nclass InngestExecution {\n    constructor(options) {\n        this.options = options;\n        this.debug = (0, debug_1.default)(`${consts_js_1.debugPrefix}:${this.options.runId}`);\n    }\n}\nexports.InngestExecution = InngestExecution;\n//# sourceMappingURL=InngestExecution.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQUcsd0JBQXdCO0FBQ3pGLGdDQUFnQyxtQkFBTyxDQUFDLDJFQUFPO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsd0JBQXdCLHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzNGO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5uZ2VzdEV4ZWN1dGlvbiA9IGV4cG9ydHMuUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OID0gZXhwb3J0cy5FeGVjdXRpb25WZXJzaW9uID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9jb25zdHMuanNcIik7XG4vKipcbiAqIFRoZSBleGVjdXRpb24gbW9kZWxzIHRoZSBTREsgaXMgYXdhcmUgb2YuXG4gKlxuICogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHBsYWNlcyB0byBlbnN1cmUgYWxsIGV4ZWN1dGlvbiB2ZXJzaW9ucyBhcmVcbiAqIGFjY291bnRlZCBmb3IgZm9yIGEgZ2l2ZW4gb3BlcmF0aW9uLlxuICovXG52YXIgRXhlY3V0aW9uVmVyc2lvbjtcbihmdW5jdGlvbiAoRXhlY3V0aW9uVmVyc2lvbikge1xuICAgIEV4ZWN1dGlvblZlcnNpb25bRXhlY3V0aW9uVmVyc2lvbltcIlYwXCJdID0gMF0gPSBcIlYwXCI7XG4gICAgRXhlY3V0aW9uVmVyc2lvbltFeGVjdXRpb25WZXJzaW9uW1wiVjFcIl0gPSAxXSA9IFwiVjFcIjtcbiAgICBFeGVjdXRpb25WZXJzaW9uW0V4ZWN1dGlvblZlcnNpb25bXCJWMlwiXSA9IDJdID0gXCJWMlwiO1xufSkoRXhlY3V0aW9uVmVyc2lvbiB8fCAoZXhwb3J0cy5FeGVjdXRpb25WZXJzaW9uID0gRXhlY3V0aW9uVmVyc2lvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBwcmVmZXJyZWQgZXhlY3V0aW9uIHZlcnNpb24gdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIFNESyB3aGVuIGhhbmRsaW5nXG4gKiBicmFuZCBuZXcgcnVucyB3aGVyZSB0aGUgRXhlY3V0b3IgaXMgYWxsb3dpbmcgdXMgdG8gY2hvb3NlLlxuICpcbiAqIENoYW5naW5nIHRoaXMgc2hvdWxkIG5vdCBldmVyIGJlIGEgYnJlYWtpbmcgY2hhbmdlLCBhcyB0aGlzIHdpbGwgb25seSBjaGFuZ2VcbiAqIG5ldyBydW5zLCBub3QgZXhpc3Rpbmcgb25lcy5cbiAqL1xuZXhwb3J0cy5QUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT04gPSBFeGVjdXRpb25WZXJzaW9uLlYxO1xuY2xhc3MgSW5uZ2VzdEV4ZWN1dGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7Y29uc3RzX2pzXzEuZGVidWdQcmVmaXh9OiR7dGhpcy5vcHRpb25zLnJ1bklkfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZ2VzdEV4ZWN1dGlvbiA9IElubmdlc3RFeGVjdXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0RXhlY3V0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/als.js":
/*!**********************************************************!*\
  !*** ./node_modules/inngest/components/execution/als.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAsyncLocalStorage = exports.getAsyncCtx = void 0;\n/**\n * A local-only symbol used as a key in global state to store the async local\n * storage instance.\n */\nconst alsSymbol = Symbol.for(\"inngest:als\");\n/**\n * Retrieve the async context for the current execution.\n */\nconst getAsyncCtx = async () => {\n    return (0, exports.getAsyncLocalStorage)().then((als) => als.getStore());\n};\nexports.getAsyncCtx = getAsyncCtx;\n/**\n * Get a singleton instance of `AsyncLocalStorage` used to store and retrieve\n * async context for the current execution.\n */\nconst getAsyncLocalStorage = async () => {\n    var _a;\n    var _b;\n    (_a = (_b = globalThis)[alsSymbol]) !== null && _a !== void 0 ? _a : (_b[alsSymbol] = new Promise(\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    async (resolve) => {\n        try {\n            // Obscure this import to keep bundlers from bundling it.\n            const dynamicImport = (path) => {\n                const safePath = path.split(\"/\").join(\"/\");\n                return Promise.resolve(`${safePath}`).then(s => __importStar(__webpack_require__(\"(rsc)/./node_modules/inngest/components/execution sync recursive\")(s)));\n            };\n            const { AsyncLocalStorage } = \n            // eslint-disable-next-line @typescript-eslint/consistent-type-imports\n            await dynamicImport(\"node:async_hooks\");\n            resolve(new AsyncLocalStorage());\n        }\n        catch (err) {\n            console.warn(\"node:async_hooks is not supported in this runtime. Experimental async context is disabled.\");\n            resolve({\n                getStore: () => undefined,\n                run: (_, fn) => fn(),\n            });\n        }\n    }));\n    return globalThis[alsSymbol];\n};\nexports.getAsyncLocalStorage = getAsyncLocalStorage;\n//# sourceMappingURL=als.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9hbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTLDBCQUEwQix3RkFBUSxDQUFDLENBQUM7QUFDdkY7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL2Fscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRBc3luY0xvY2FsU3RvcmFnZSA9IGV4cG9ydHMuZ2V0QXN5bmNDdHggPSB2b2lkIDA7XG4vKipcbiAqIEEgbG9jYWwtb25seSBzeW1ib2wgdXNlZCBhcyBhIGtleSBpbiBnbG9iYWwgc3RhdGUgdG8gc3RvcmUgdGhlIGFzeW5jIGxvY2FsXG4gKiBzdG9yYWdlIGluc3RhbmNlLlxuICovXG5jb25zdCBhbHNTeW1ib2wgPSBTeW1ib2wuZm9yKFwiaW5uZ2VzdDphbHNcIik7XG4vKipcbiAqIFJldHJpZXZlIHRoZSBhc3luYyBjb250ZXh0IGZvciB0aGUgY3VycmVudCBleGVjdXRpb24uXG4gKi9cbmNvbnN0IGdldEFzeW5jQ3R4ID0gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5nZXRBc3luY0xvY2FsU3RvcmFnZSkoKS50aGVuKChhbHMpID0+IGFscy5nZXRTdG9yZSgpKTtcbn07XG5leHBvcnRzLmdldEFzeW5jQ3R4ID0gZ2V0QXN5bmNDdHg7XG4vKipcbiAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBgQXN5bmNMb2NhbFN0b3JhZ2VgIHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlXG4gKiBhc3luYyBjb250ZXh0IGZvciB0aGUgY3VycmVudCBleGVjdXRpb24uXG4gKi9cbmNvbnN0IGdldEFzeW5jTG9jYWxTdG9yYWdlID0gYXN5bmMgKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2I7XG4gICAgKF9hID0gKF9iID0gZ2xvYmFsVGhpcylbYWxzU3ltYm9sXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iW2Fsc1N5bWJvbF0gPSBuZXcgUHJvbWlzZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXMsIG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3JcbiAgICBhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gT2JzY3VyZSB0aGlzIGltcG9ydCB0byBrZWVwIGJ1bmRsZXJzIGZyb20gYnVuZGxpbmcgaXQuXG4gICAgICAgICAgICBjb25zdCBkeW5hbWljSW1wb3J0ID0gKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYWZlUGF0aCA9IHBhdGguc3BsaXQoXCIvXCIpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYCR7c2FmZVBhdGh9YCkudGhlbihzID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKHMpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgeyBBc3luY0xvY2FsU3RvcmFnZSB9ID0gXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1pbXBvcnRzXG4gICAgICAgICAgICBhd2FpdCBkeW5hbWljSW1wb3J0KFwibm9kZTphc3luY19ob29rc1wiKTtcbiAgICAgICAgICAgIHJlc29sdmUobmV3IEFzeW5jTG9jYWxTdG9yYWdlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIm5vZGU6YXN5bmNfaG9va3MgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIHJ1bnRpbWUuIEV4cGVyaW1lbnRhbCBhc3luYyBjb250ZXh0IGlzIGRpc2FibGVkLlwiKTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGdldFN0b3JlOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcnVuOiAoXywgZm4pID0+IGZuKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gZ2xvYmFsVGhpc1thbHNTeW1ib2xdO1xufTtcbmV4cG9ydHMuZ2V0QXN5bmNMb2NhbFN0b3JhZ2UgPSBnZXRBc3luY0xvY2FsU3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/als.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/access.js":
/*!******************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/access.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * A file used to access client processors safely without also importing any\n * otel-specific libraries. Useful for ensuring that the otel libraries can be\n * tree-shaken if they're not used directly by the user.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clientProcessorMap = void 0;\n/**\n * A map of Inngest clients to their OTel span processors. This is used to\n * ensure that we only create one span processor per client, and that we can\n * access the span processor from the client without exposing the OTel\n * libraries to the user.\n */\nexports.clientProcessorMap = new WeakMap();\n//# sourceMappingURL=access.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2FjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2FjY2Vzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQSBmaWxlIHVzZWQgdG8gYWNjZXNzIGNsaWVudCBwcm9jZXNzb3JzIHNhZmVseSB3aXRob3V0IGFsc28gaW1wb3J0aW5nIGFueVxuICogb3RlbC1zcGVjaWZpYyBsaWJyYXJpZXMuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCB0aGUgb3RlbCBsaWJyYXJpZXMgY2FuIGJlXG4gKiB0cmVlLXNoYWtlbiBpZiB0aGV5J3JlIG5vdCB1c2VkIGRpcmVjdGx5IGJ5IHRoZSB1c2VyLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNsaWVudFByb2Nlc3Nvck1hcCA9IHZvaWQgMDtcbi8qKlxuICogQSBtYXAgb2YgSW5uZ2VzdCBjbGllbnRzIHRvIHRoZWlyIE9UZWwgc3BhbiBwcm9jZXNzb3JzLiBUaGlzIGlzIHVzZWQgdG9cbiAqIGVuc3VyZSB0aGF0IHdlIG9ubHkgY3JlYXRlIG9uZSBzcGFuIHByb2Nlc3NvciBwZXIgY2xpZW50LCBhbmQgdGhhdCB3ZSBjYW5cbiAqIGFjY2VzcyB0aGUgc3BhbiBwcm9jZXNzb3IgZnJvbSB0aGUgY2xpZW50IHdpdGhvdXQgZXhwb3NpbmcgdGhlIE9UZWxcbiAqIGxpYnJhcmllcyB0byB0aGUgdXNlci5cbiAqL1xuZXhwb3J0cy5jbGllbnRQcm9jZXNzb3JNYXAgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/access.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v0.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v0.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.V0InngestExecution = exports.createV0InngestExecution = void 0;\nconst canonicalize_1 = __importDefault(__webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\"));\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst createV0InngestExecution = (options) => {\n    return new V0InngestExecution(options);\n};\nexports.createV0InngestExecution = createV0InngestExecution;\nclass V0InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n    }\n    start() {\n        var _a;\n        this.debug(\"starting V0 execution\");\n        return ((_a = this.execution) !== null && _a !== void 0 ? _a : (this.execution = this._start().then((result) => {\n            this.debug(\"result:\", result);\n            return result;\n        })));\n    }\n    async _start() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n        this.state.hooks = await this.initializeMiddleware();\n        try {\n            await this.transformInput();\n            await ((_b = (_a = this.state.hooks).beforeMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {\n                await ((_d = (_c = this.state.hooks).afterMemoization) === null || _d === void 0 ? void 0 : _d.call(_c));\n                await ((_f = (_e = this.state.hooks).beforeExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            }\n            const userFnPromise = (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg));\n            let pos = -1;\n            do {\n                if (pos >= 0) {\n                    if (!this.options.requestedRunStep &&\n                        pos === this.state.opStack.length - 1) {\n                        await ((_h = (_g = this.state.hooks).afterMemoization) === null || _h === void 0 ? void 0 : _h.call(_g));\n                        await ((_k = (_j = this.state.hooks).beforeExecution) === null || _k === void 0 ? void 0 : _k.call(_j));\n                    }\n                    this.state.tickOps = {};\n                    const incomingOp = this.state.opStack[pos];\n                    this.state.currentOp = this.state.allFoundOps[incomingOp.id];\n                    if (!this.state.currentOp) {\n                        /**\n                         * We're trying to resume the function, but we can't find where to go.\n                         *\n                         * This means that either the function has changed or there are async\n                         * actions in-between steps that we haven't noticed in previous\n                         * executions.\n                         *\n                         * Whichever the case, this is bad and we can't continue in this\n                         * undefined state.\n                         */\n                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({\n                            whatHappened: \" Your function was stopped from running\",\n                            why: \"We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.\",\n                            consequences: \"Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!\",\n                            toFixNow: \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n                            otherwise: \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n                            stack: true,\n                            code: errors_js_1.ErrCode.NON_DETERMINISTIC_FUNCTION,\n                        }));\n                    }\n                    this.state.currentOp.fulfilled = true;\n                    if (typeof incomingOp.data !== \"undefined\") {\n                        this.state.currentOp.resolve(incomingOp.data);\n                    }\n                    else {\n                        this.state.currentOp.reject(incomingOp.error);\n                    }\n                }\n                await (0, promises_js_1.resolveAfterPending)();\n                this.state.reset();\n                pos++;\n            } while (pos < this.state.opStack.length);\n            await ((_m = (_l = this.state.hooks).afterMemoization) === null || _m === void 0 ? void 0 : _m.call(_l));\n            const discoveredOps = Object.values(this.state.tickOps).map(tickOpToOutgoing);\n            const runStep = this.options.requestedRunStep ||\n                this.getEarlyExecRunStep(discoveredOps);\n            if (runStep) {\n                const userFnOp = this.state.allFoundOps[runStep];\n                const stepToRun = userFnOp === null || userFnOp === void 0 ? void 0 : userFnOp.fn;\n                if (!stepToRun) {\n                    throw new Error(`Bad stack; executor requesting to run unknown step \"${runStep}\"`);\n                }\n                const outgoingUserFnOp = Object.assign(Object.assign({}, tickOpToOutgoing(userFnOp)), { op: types_js_1.StepOpCode.Step });\n                await ((_p = (_o = this.state.hooks).beforeExecution) === null || _p === void 0 ? void 0 : _p.call(_o));\n                this.state.executingStep = true;\n                const result = await (0, promises_js_1.runAsPromise)(stepToRun)\n                    .finally(() => {\n                    this.state.executingStep = false;\n                })\n                    .catch(async (error) => {\n                    return await this.transformOutput({ error }, outgoingUserFnOp);\n                })\n                    .then(async (data) => {\n                    var _a, _b;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    return await this.transformOutput({ data }, outgoingUserFnOp);\n                });\n                const { type: _type } = result, rest = __rest(result, [\"type\"]);\n                return {\n                    type: \"step-ran\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    step: Object.assign(Object.assign({}, outgoingUserFnOp), rest),\n                };\n            }\n            if (!discoveredOps.length) {\n                const fnRet = await Promise.race([\n                    userFnPromise.then((data) => ({ type: \"complete\", data })),\n                    (0, promises_js_1.resolveNextTick)().then(() => ({ type: \"incomplete\" })),\n                ]);\n                if (fnRet.type === \"complete\") {\n                    await ((_r = (_q = this.state.hooks).afterExecution) === null || _r === void 0 ? void 0 : _r.call(_q));\n                    const allOpsFulfilled = Object.values(this.state.allFoundOps).every((op) => {\n                        return op.fulfilled;\n                    });\n                    if (allOpsFulfilled) {\n                        return await this.transformOutput({ data: fnRet.data });\n                    }\n                }\n                else if (!this.state.hasUsedTools) {\n                    this.state.nonStepFnDetected = true;\n                    const data = await userFnPromise;\n                    await ((_t = (_s = this.state.hooks).afterExecution) === null || _t === void 0 ? void 0 : _t.call(_s));\n                    return await this.transformOutput({ data });\n                }\n                else {\n                    const hasOpsPending = Object.values(this.state.allFoundOps).some((op) => {\n                        return op.fulfilled === false;\n                    });\n                    if (!hasOpsPending) {\n                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION));\n                    }\n                }\n            }\n            await ((_v = (_u = this.state.hooks).afterExecution) === null || _v === void 0 ? void 0 : _v.call(_u));\n            return {\n                type: \"steps-found\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                steps: discoveredOps,\n            };\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            await ((_x = (_w = this.state.hooks).beforeResponse) === null || _x === void 0 ? void 0 : _x.call(_w));\n        }\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n    createExecutionState() {\n        const state = {\n            allFoundOps: {},\n            tickOps: {},\n            tickOpHashes: {},\n            currentOp: undefined,\n            hasUsedTools: false,\n            reset: () => {\n                state.tickOpHashes = {};\n                state.allFoundOps = Object.assign(Object.assign({}, state.allFoundOps), state.tickOps);\n            },\n            nonStepFnDetected: false,\n            executingStep: false,\n            opStack: this.options.stepCompletionOrder.reduce((acc, stepId) => {\n                const stepState = this.options.stepState[stepId];\n                if (!stepState) {\n                    return acc;\n                }\n                return [...acc, stepState];\n            }, []),\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(Object.entries(this.state.allFoundOps).map(([id, op]) => [\n            id,\n            {\n                id: op.id,\n                rawArgs: op.rawArgs,\n                data: op.data,\n                error: op.error,\n                fulfilled: op.fulfilled,\n                seen: true,\n            },\n        ]));\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        // TODO: Review; inferred types results in an `any` here!\n        return this.options.fn[\"onFailureFn\"];\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        // Start referencing everything\n        this.state.tickOps = this.state.allFoundOps;\n        /**\n         * Create a unique hash of an operation using only a subset of the operation's\n         * properties; will never use `data` and will guarantee the order of the\n         * object so we don't rely on individual tools for that.\n         *\n         * If the operation already contains an ID, the current ID will be used\n         * instead, so that users can provide their own IDs.\n         */\n        const hashOp = (\n        /**\n         * The op to generate a hash from. We only use a subset of the op's\n         * properties when creating the hash.\n         */\n        op) => {\n            var _a, _b, _c, _d;\n            /**\n             * It's difficult for v0 to understand whether or not an op has\n             * historically contained a custom ID, as all step usage now require them.\n             *\n             * For this reason, we make the assumption that steps in v0 do not have a\n             * custom ID and generate one for them as we would in all recommendations\n             * and examples.\n             */\n            const obj = {\n                parent: (_b = (_a = this.state.currentOp) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null,\n                op: op.op,\n                name: op.name,\n                // Historically, no v0 runs could have options for `step.run()` call,\n                // but this object can be specified in future versions.\n                //\n                // For this purpose, we change this to always use `null` if the op is\n                // that of a `step.run()`.\n                opts: op.op === types_js_1.StepOpCode.StepPlanned ? null : (_c = op.opts) !== null && _c !== void 0 ? _c : null,\n            };\n            const collisionHash = exports._internals.hashData(obj);\n            const pos = (this.state.tickOpHashes[collisionHash] =\n                ((_d = this.state.tickOpHashes[collisionHash]) !== null && _d !== void 0 ? _d : -1) + 1);\n            return Object.assign(Object.assign({}, op), { id: exports._internals.hashData(Object.assign({ pos }, obj)) });\n        };\n        const stepHandler = ({ args, matchOp, opts }) => {\n            if (this.state.nonStepFnDetected) {\n                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.STEP_USED_AFTER_ASYNC));\n            }\n            if (this.state.executingStep) {\n                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({\n                    whatHappened: \"Your function was stopped from running\",\n                    why: \"We detected that you have nested `step.*` tooling.\",\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    otherwise: \"For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            this.state.hasUsedTools = true;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));\n            return new Promise((resolve, reject) => {\n                this.state.tickOps[opId.id] = Object.assign(Object.assign(Object.assign({}, opId), ((opts === null || opts === void 0 ? void 0 : opts.fn) ? { fn: () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...args); } } : {})), { rawArgs: args, resolve,\n                    reject, fulfilled: false });\n            });\n        };\n        const step = (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.options.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.opStack = [...inputMutations.steps];\n        }\n    }\n    getEarlyExecRunStep(ops) {\n        if (ops.length !== 1)\n            return;\n        const op = ops[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.id;\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError, step) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!step) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.serializeError)(error);\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n}\nexports.V0InngestExecution = V0InngestExecution;\nconst tickOpToOutgoing = (op) => {\n    return {\n        op: op.op,\n        id: op.id,\n        name: op.name,\n        opts: op.opts,\n    };\n};\nconst hashData = (op) => {\n    return (0, hash_js_1.sha1)().update((0, canonicalize_1.default)(op)).digest(\"hex\");\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashData };\n//# sourceMappingURL=v0.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsMEJBQTBCLEdBQUcsZ0NBQWdDO0FBQ2xGLHVDQUF1QyxtQkFBTyxDQUFDLDJFQUFjO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHlEQUFTO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDhCQUE4QixtQkFBTyxDQUFDLDJGQUF3QjtBQUM5RCwrQkFBK0IsbUJBQU8sQ0FBQyw2RkFBeUI7QUFDaEUsNkJBQTZCLG1CQUFPLENBQUMseUZBQXVCO0FBQzVELDhCQUE4QixtQkFBTyxDQUFDLG9HQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDJDQUEyQyxRQUFRO0FBQ25HO0FBQ0EsdUVBQXVFLGlDQUFpQyxnQ0FBZ0M7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdEQUF3RCxPQUFPO0FBQy9ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsTUFBTTtBQUM5RCxpQkFBaUI7QUFDakIsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsd0JBQXdCO0FBQzVFLHVFQUF1RSxvQkFBb0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDREQUE0RCxrQkFBa0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTLGdEQUFnRCxLQUFLLFNBQVM7QUFDeEg7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLG9FQUFvRSxZQUFZLFFBQVEsdUZBQXVGLElBQUksTUFBTTtBQUNuUiw4Q0FBOEM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxrREFBa0Qsd0JBQXdCLE1BQU07QUFDaEY7QUFDQTtBQUNBLDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQSxrREFBa0QsWUFBWSwyREFBMkQ7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsU0FBUztBQUNULGdCQUFnQixjQUFjLGdDQUFnQztBQUM5RDtBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQyxRQUFRLElBQUksTUFBTTtBQUM5RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX2ludGVybmFscyA9IGV4cG9ydHMuVjBJbm5nZXN0RXhlY3V0aW9uID0gZXhwb3J0cy5jcmVhdGVWMElubmdlc3RFeGVjdXRpb24gPSB2b2lkIDA7XG5jb25zdCBjYW5vbmljYWxpemVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2Fub25pY2FsaXplXCIpKTtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCJoYXNoLmpzXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9lcnJvcnMuanNcIik7XG5jb25zdCBmdW5jdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2Z1bmN0aW9ucy5qc1wiKTtcbmNvbnN0IHByb21pc2VzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9wcm9taXNlcy5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXMuanNcIik7XG5jb25zdCBJbm5nZXN0TWlkZGxld2FyZV9qc18xID0gcmVxdWlyZShcIi4uL0lubmdlc3RNaWRkbGV3YXJlLmpzXCIpO1xuY29uc3QgSW5uZ2VzdFN0ZXBUb29sc19qc18xID0gcmVxdWlyZShcIi4uL0lubmdlc3RTdGVwVG9vbHMuanNcIik7XG5jb25zdCBOb25SZXRyaWFibGVFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL05vblJldHJpYWJsZUVycm9yLmpzXCIpO1xuY29uc3QgUmV0cnlBZnRlckVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi4vUmV0cnlBZnRlckVycm9yLmpzXCIpO1xuY29uc3QgSW5uZ2VzdEV4ZWN1dGlvbl9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbmNvbnN0IGNyZWF0ZVYwSW5uZ2VzdEV4ZWN1dGlvbiA9IChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWMElubmdlc3RFeGVjdXRpb24ob3B0aW9ucyk7XG59O1xuZXhwb3J0cy5jcmVhdGVWMElubmdlc3RFeGVjdXRpb24gPSBjcmVhdGVWMElubmdlc3RFeGVjdXRpb247XG5jbGFzcyBWMElubmdlc3RFeGVjdXRpb24gZXh0ZW5kcyBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuSW5uZ2VzdEV4ZWN1dGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy51c2VyRm5Ub1J1biA9IHRoaXMuZ2V0VXNlckZuVG9SdW4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuY3JlYXRlRXhlY3V0aW9uU3RhdGUoKTtcbiAgICAgICAgdGhpcy5mbkFyZyA9IHRoaXMuY3JlYXRlRm5BcmcoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcInN0YXJ0aW5nIFYwIGV4ZWN1dGlvblwiKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmV4ZWN1dGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuZXhlY3V0aW9uID0gdGhpcy5fc3RhcnQoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJyZXN1bHQ6XCIsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeDtcbiAgICAgICAgdGhpcy5zdGF0ZS5ob29rcyA9IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZU1pZGRsZXdhcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudHJhbnNmb3JtSW5wdXQoKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKS5iZWZvcmVNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm9wU3RhY2subGVuZ3RoID09PSAwICYmICF0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCkge1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2YgPSAoX2UgPSB0aGlzLnN0YXRlLmhvb2tzKS5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1c2VyRm5Qcm9taXNlID0gKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKSgoKSA9PiB0aGlzLnVzZXJGblRvUnVuKHRoaXMuZm5BcmcpKTtcbiAgICAgICAgICAgIGxldCBwb3MgPSAtMTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID09PSB0aGlzLnN0YXRlLm9wU3RhY2subGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgKChfaCA9IChfZyA9IHRoaXMuc3RhdGUuaG9va3MpLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5jYWxsKF9nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9rID0gKF9qID0gdGhpcy5zdGF0ZS5ob29rcykuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suY2FsbChfaikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudGlja09wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZ09wID0gdGhpcy5zdGF0ZS5vcFN0YWNrW3Bvc107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudE9wID0gdGhpcy5zdGF0ZS5hbGxGb3VuZE9wc1tpbmNvbWluZ09wLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmN1cnJlbnRPcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBXZSdyZSB0cnlpbmcgdG8gcmVzdW1lIHRoZSBmdW5jdGlvbiwgYnV0IHdlIGNhbid0IGZpbmQgd2hlcmUgdG8gZ28uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBtZWFucyB0aGF0IGVpdGhlciB0aGUgZnVuY3Rpb24gaGFzIGNoYW5nZWQgb3IgdGhlcmUgYXJlIGFzeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhY3Rpb25zIGluLWJldHdlZW4gc3RlcHMgdGhhdCB3ZSBoYXZlbid0IG5vdGljZWQgaW4gcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGV4ZWN1dGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogV2hpY2hldmVyIHRoZSBjYXNlLCB0aGlzIGlzIGJhZCBhbmQgd2UgY2FuJ3QgY29udGludWUgaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogdW5kZWZpbmVkIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9uUmV0cmlhYmxlRXJyb3JfanNfMS5Ob25SZXRyaWFibGVFcnJvcigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiIFlvdXIgZnVuY3Rpb24gd2FzIHN0b3BwZWQgZnJvbSBydW5uaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2h5OiBcIldlIGNvdWxkbid0IHJlc3VtZSB5b3VyIGZ1bmN0aW9uJ3Mgc3RhdGUgYmVjYXVzZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBydW4gc3RhcnRlZCBvciB0aGVyZSBhcmUgYXN5bmMgYWN0aW9ucyBpbi1iZXR3ZWVuIHN0ZXBzIHRoYXQgd2UgaGF2ZW4ndCBub3RpY2VkIGluIHByZXZpb3VzIGV4ZWN1dGlvbnMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIkNvbnRpbnVpbmcgdG8gcnVuIHRoZSBmdW5jdGlvbiBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLCBzbyB3ZSd2ZSBzdG9wcGVkIHlvdXIgZnVuY3Rpb24gdG8gZW5zdXJlIG5vdGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZCFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0ZpeE5vdzogXCJFbnN1cmUgdGhhdCB5b3VyIGZ1bmN0aW9uIGlzIGVpdGhlciBlbnRpcmVseSBzdGVwLWJhc2VkIG9yIGVudGlyZWx5IG5vbi1zdGVwLWJhc2VkLCBieSBlaXRoZXIgd3JhcHBpbmcgYWxsIGFzeW5jaHJvbm91cyBsb2dpYyBpbiBgc3RlcC5ydW4oKWAgY2FsbHMgb3IgYnkgcmVtb3ZpbmcgYWxsIGBzdGVwLiooKWAgY2FsbHMuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJ3aXNlOiBcIkZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoeSBzdGVwIGZ1bmN0aW9ucyB3b3JrIGluIHRoaXMgbWFubmVyLCBzZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9mdW5jdGlvbnMvbXVsdGktc3RlcCNnb3RjaGFzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JzX2pzXzEuRXJyQ29kZS5OT05fREVURVJNSU5JU1RJQ19GVU5DVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRPcC5mdWxmaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluY29taW5nT3AuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50T3AucmVzb2x2ZShpbmNvbWluZ09wLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50T3AucmVqZWN0KGluY29taW5nT3AuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0ICgwLCBwcm9taXNlc19qc18xLnJlc29sdmVBZnRlclBlbmRpbmcpKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSB3aGlsZSAocG9zIDwgdGhpcy5zdGF0ZS5vcFN0YWNrLmxlbmd0aCk7XG4gICAgICAgICAgICBhd2FpdCAoKF9tID0gKF9sID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmNhbGwoX2wpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyZWRPcHMgPSBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUudGlja09wcykubWFwKHRpY2tPcFRvT3V0Z29pbmcpO1xuICAgICAgICAgICAgY29uc3QgcnVuU3RlcCA9IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFYXJseUV4ZWNSdW5TdGVwKGRpc2NvdmVyZWRPcHMpO1xuICAgICAgICAgICAgaWYgKHJ1blN0ZXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyRm5PcCA9IHRoaXMuc3RhdGUuYWxsRm91bmRPcHNbcnVuU3RlcF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvUnVuID0gdXNlckZuT3AgPT09IG51bGwgfHwgdXNlckZuT3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXJGbk9wLmZuO1xuICAgICAgICAgICAgICAgIGlmICghc3RlcFRvUnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHN0YWNrOyBleGVjdXRvciByZXF1ZXN0aW5nIHRvIHJ1biB1bmtub3duIHN0ZXAgXCIke3J1blN0ZXB9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Z29pbmdVc2VyRm5PcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGlja09wVG9PdXRnb2luZyh1c2VyRm5PcCkpLCB7IG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcCB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCAoKF9wID0gKF9vID0gdGhpcy5zdGF0ZS5ob29rcykuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3AuY2FsbChfbykpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKShzdGVwVG9SdW4pXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvciB9LCBvdXRnb2luZ1VzZXJGbk9wKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBkYXRhIH0sIG91dGdvaW5nVXNlckZuT3ApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZTogX3R5cGUgfSA9IHJlc3VsdCwgcmVzdCA9IF9fcmVzdChyZXN1bHQsIFtcInR5cGVcIl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1yYW5cIixcbiAgICAgICAgICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dGdvaW5nVXNlckZuT3ApLCByZXN0KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkaXNjb3ZlcmVkT3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZuUmV0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAgICAgdXNlckZuUHJvbWlzZS50aGVuKChkYXRhKSA9PiAoeyB0eXBlOiBcImNvbXBsZXRlXCIsIGRhdGEgfSkpLFxuICAgICAgICAgICAgICAgICAgICAoMCwgcHJvbWlzZXNfanNfMS5yZXNvbHZlTmV4dFRpY2spKCkudGhlbigoKSA9PiAoeyB0eXBlOiBcImluY29tcGxldGVcIiB9KSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKGZuUmV0LnR5cGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9yID0gKF9xID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfci5jYWxsKF9xKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbE9wc0Z1bGZpbGxlZCA9IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5hbGxGb3VuZE9wcykuZXZlcnkoKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3AuZnVsZmlsbGVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbE9wc0Z1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZGF0YTogZm5SZXQuZGF0YSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5zdGF0ZS5oYXNVc2VkVG9vbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5ub25TdGVwRm5EZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB1c2VyRm5Qcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF90ID0gKF9zID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF90ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdC5jYWxsKF9zKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNPcHNQZW5kaW5nID0gT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLmFsbEZvdW5kT3BzKS5zb21lKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wLmZ1bGZpbGxlZCA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc09wc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKCgwLCBlcnJvcnNfanNfMS5mdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyKShlcnJvcnNfanNfMS5FcnJDb2RlLkFTWU5DX0RFVEVDVEVEX0FGVEVSX01FTU9JWkFUSU9OKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoKF92ID0gKF91ID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF92ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdi5jYWxsKF91KSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcHMtZm91bmRcIixcbiAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgICAgICBzdGVwczogZGlzY292ZXJlZE9wcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0ICgoX3ggPSAoX3cgPSB0aGlzLnN0YXRlLmhvb2tzKS5iZWZvcmVSZXNwb25zZSkgPT09IG51bGwgfHwgX3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF94LmNhbGwoX3cpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZSgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5vcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uRnVuY3Rpb25SdW5cIiwge1xuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgcmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3MsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYuY3R4KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LmN0eCksXG4gICAgICAgICAgICAgICAgICAgIGZuOiB0aGlzLm9wdGlvbnMuZm4sXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBwcmV2LnN0ZXBzLm1hcCgoc3RlcCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXApLCAoX2EgPSBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuc3RlcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVxQXJnczogcHJldi5yZXFBcmdzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYucmVzdWx0KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHByZXYuc3RlcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBob29rcztcbiAgICB9XG4gICAgY3JlYXRlRXhlY3V0aW9uU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsRm91bmRPcHM6IHt9LFxuICAgICAgICAgICAgdGlja09wczoge30sXG4gICAgICAgICAgICB0aWNrT3BIYXNoZXM6IHt9LFxuICAgICAgICAgICAgY3VycmVudE9wOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoYXNVc2VkVG9vbHM6IGZhbHNlLFxuICAgICAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS50aWNrT3BIYXNoZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxGb3VuZE9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYWxsRm91bmRPcHMpLCBzdGF0ZS50aWNrT3BzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub25TdGVwRm5EZXRlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBleGVjdXRpbmdTdGVwOiBmYWxzZSxcbiAgICAgICAgICAgIG9wU3RhY2s6IHRoaXMub3B0aW9ucy5zdGVwQ29tcGxldGlvbk9yZGVyLnJlZHVjZSgoYWNjLCBzdGVwSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwU3RhdGUgPSB0aGlzLm9wdGlvbnMuc3RlcFN0YXRlW3N0ZXBJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFzdGVwU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIHN0ZXBTdGF0ZV07XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZ2V0IG9wcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0aGlzLnN0YXRlLmFsbEZvdW5kT3BzKS5tYXAoKFtpZCwgb3BdKSA9PiBbXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogb3AuaWQsXG4gICAgICAgICAgICAgICAgcmF3QXJnczogb3AucmF3QXJncyxcbiAgICAgICAgICAgICAgICBkYXRhOiBvcC5kYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBvcC5lcnJvcixcbiAgICAgICAgICAgICAgICBmdWxmaWxsZWQ6IG9wLmZ1bGZpbGxlZCxcbiAgICAgICAgICAgICAgICBzZWVuOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBnZXRVc2VyRm5Ub1J1bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mbltcImZuXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl0pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29tZWhvdywgd2UndmUgZW5kZWQgdXAgZGV0ZWN0aW5nIHRoYXQgdGhpcyBpcyBhIGZhaWx1cmUgaGFuZGxlciBidXRcbiAgICAgICAgICAgICAqIGRvZXNuJ3QgaGF2ZSBhbiBgb25GYWlsdXJlYCBmdW5jdGlvbi4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmdW5jdGlvbiBgb25GYWlsdXJlYCBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFJldmlldzsgaW5mZXJyZWQgdHlwZXMgcmVzdWx0cyBpbiBhbiBgYW55YCBoZXJlIVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl07XG4gICAgfVxuICAgIGNyZWF0ZUZuQXJnKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIC8vIFN0YXJ0IHJlZmVyZW5jaW5nIGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5zdGF0ZS50aWNrT3BzID0gdGhpcy5zdGF0ZS5hbGxGb3VuZE9wcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIG9mIGFuIG9wZXJhdGlvbiB1c2luZyBvbmx5IGEgc3Vic2V0IG9mIHRoZSBvcGVyYXRpb24nc1xuICAgICAgICAgKiBwcm9wZXJ0aWVzOyB3aWxsIG5ldmVyIHVzZSBgZGF0YWAgYW5kIHdpbGwgZ3VhcmFudGVlIHRoZSBvcmRlciBvZiB0aGVcbiAgICAgICAgICogb2JqZWN0IHNvIHdlIGRvbid0IHJlbHkgb24gaW5kaXZpZHVhbCB0b29scyBmb3IgdGhhdC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIG9wZXJhdGlvbiBhbHJlYWR5IGNvbnRhaW5zIGFuIElELCB0aGUgY3VycmVudCBJRCB3aWxsIGJlIHVzZWRcbiAgICAgICAgICogaW5zdGVhZCwgc28gdGhhdCB1c2VycyBjYW4gcHJvdmlkZSB0aGVpciBvd24gSURzLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaGFzaE9wID0gKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wIHRvIGdlbmVyYXRlIGEgaGFzaCBmcm9tLiBXZSBvbmx5IHVzZSBhIHN1YnNldCBvZiB0aGUgb3Anc1xuICAgICAgICAgKiBwcm9wZXJ0aWVzIHdoZW4gY3JlYXRpbmcgdGhlIGhhc2guXG4gICAgICAgICAqL1xuICAgICAgICBvcCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJdCdzIGRpZmZpY3VsdCBmb3IgdjAgdG8gdW5kZXJzdGFuZCB3aGV0aGVyIG9yIG5vdCBhbiBvcCBoYXNcbiAgICAgICAgICAgICAqIGhpc3RvcmljYWxseSBjb250YWluZWQgYSBjdXN0b20gSUQsIGFzIGFsbCBzdGVwIHVzYWdlIG5vdyByZXF1aXJlIHRoZW0uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRm9yIHRoaXMgcmVhc29uLCB3ZSBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgc3RlcHMgaW4gdjAgZG8gbm90IGhhdmUgYVxuICAgICAgICAgICAgICogY3VzdG9tIElEIGFuZCBnZW5lcmF0ZSBvbmUgZm9yIHRoZW0gYXMgd2Ugd291bGQgaW4gYWxsIHJlY29tbWVuZGF0aW9uc1xuICAgICAgICAgICAgICogYW5kIGV4YW1wbGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICAgICAgcGFyZW50OiAoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmN1cnJlbnRPcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgIG9wOiBvcC5vcCxcbiAgICAgICAgICAgICAgICBuYW1lOiBvcC5uYW1lLFxuICAgICAgICAgICAgICAgIC8vIEhpc3RvcmljYWxseSwgbm8gdjAgcnVucyBjb3VsZCBoYXZlIG9wdGlvbnMgZm9yIGBzdGVwLnJ1bigpYCBjYWxsLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGlzIG9iamVjdCBjYW4gYmUgc3BlY2lmaWVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEZvciB0aGlzIHB1cnBvc2UsIHdlIGNoYW5nZSB0aGlzIHRvIGFsd2F5cyB1c2UgYG51bGxgIGlmIHRoZSBvcCBpc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgb2YgYSBgc3RlcC5ydW4oKWAuXG4gICAgICAgICAgICAgICAgb3B0czogb3Aub3AgPT09IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZCA/IG51bGwgOiAoX2MgPSBvcC5vcHRzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpc2lvbkhhc2ggPSBleHBvcnRzLl9pbnRlcm5hbHMuaGFzaERhdGEob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9ICh0aGlzLnN0YXRlLnRpY2tPcEhhc2hlc1tjb2xsaXNpb25IYXNoXSA9XG4gICAgICAgICAgICAgICAgKChfZCA9IHRoaXMuc3RhdGUudGlja09wSGFzaGVzW2NvbGxpc2lvbkhhc2hdKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAtMSkgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wKSwgeyBpZDogZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hEYXRhKE9iamVjdC5hc3NpZ24oeyBwb3MgfSwgb2JqKSkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0ZXBIYW5kbGVyID0gKHsgYXJncywgbWF0Y2hPcCwgb3B0cyB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5ub25TdGVwRm5EZXRlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKCgwLCBlcnJvcnNfanNfMS5mdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyKShlcnJvcnNfanNfMS5FcnJDb2RlLlNURVBfVVNFRF9BRlRFUl9BU1lOQykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiWW91ciBmdW5jdGlvbiB3YXMgc3RvcHBlZCBmcm9tIHJ1bm5pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgd2h5OiBcIldlIGRldGVjdGVkIHRoYXQgeW91IGhhdmUgbmVzdGVkIGBzdGVwLipgIHRvb2xpbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJOZXN0aW5nIGBzdGVwLipgIHRvb2xpbmcgaXMgbm90IHN1cHBvcnRlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRvRml4Tm93OiBcIk1ha2Ugc3VyZSB5b3UncmUgbm90IHVzaW5nIGBzdGVwLipgIHRvb2xpbmcgaW5zaWRlIG9mIG90aGVyIGBzdGVwLipgIHRvb2xpbmcuIElmIHlvdSBuZWVkIHRvIGNvbXBvc2Ugc3RlcHMgdG9nZXRoZXIsIHlvdSBjYW4gY3JlYXRlIGEgbmV3IGFzeW5jIGZ1bmN0aW9uIGFuZCBjYWxsIGl0IGZyb20gd2l0aGluIHlvdXIgc3RlcCBmdW5jdGlvbiwgb3IgdXNlIHByb21pc2UgY2hhaW5pbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyd2lzZTogXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdGVwIGZ1bmN0aW9ucyB3aXRoIElubmdlc3QsIHNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL2Z1bmN0aW9ucy9tdWx0aS1zdGVwXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yc19qc18xLkVyckNvZGUuTkVTVElOR19TVEVQUyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmhhc1VzZWRUb29scyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzdGVwT3B0aW9ucyA9ICgwLCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuZ2V0U3RlcE9wdGlvbnMpKGFyZ3NbMF0pO1xuICAgICAgICAgICAgY29uc3Qgb3BJZCA9IGhhc2hPcChtYXRjaE9wKHN0ZXBPcHRpb25zLCAuLi5hcmdzLnNsaWNlKDEpKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudGlja09wc1tvcElkLmlkXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcElkKSwgKChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZm4pID8geyBmbjogKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBvcHRzLmZuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRzLCAuLi5hcmdzKTsgfSB9IDoge30pKSwgeyByYXdBcmdzOiBhcmdzLCByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICByZWplY3QsIGZ1bGZpbGxlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RlcCA9ICgwLCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuY3JlYXRlU3RlcFRvb2xzKSh0aGlzLm9wdGlvbnMuY2xpZW50LCB0aGlzLCBzdGVwSGFuZGxlcik7XG4gICAgICAgIGxldCBmbkFyZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLmRhdGEpLCB7IHN0ZXAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gem9kXzEuelxuICAgICAgICAgICAgICAgIC5vYmplY3QoeyBlcnJvcjogdHlwZXNfanNfMS5qc29uRXJyb3JTY2hlbWEgfSlcbiAgICAgICAgICAgICAgICAucGFyc2UoKF9hID0gZm5BcmcuZXZlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKTtcbiAgICAgICAgICAgIGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmbkFyZyksIHsgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5kZXNlcmlhbGl6ZUVycm9yKShldmVudERhdGEuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2QgPSAoX2MgPSAoX2IgPSB0aGlzLm9wdGlvbnMpLnRyYW5zZm9ybUN0eCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZuQXJnKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZm5Bcmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBpbnB1dCBiZWZvcmUgcnVubmluZy5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1JbnB1dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgaW5wdXRNdXRhdGlvbnMgPSBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zZm9ybUlucHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZuQXJnKSxcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHJlcUFyZ3M6IHRoaXMub3B0aW9ucy5yZXFBcmdzLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuY3R4KSB7XG4gICAgICAgICAgICB0aGlzLmZuQXJnID0gaW5wdXRNdXRhdGlvbnMuY3R4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuc3RlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUub3BTdGFjayA9IFsuLi5pbnB1dE11dGF0aW9ucy5zdGVwc107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RWFybHlFeGVjUnVuU3RlcChvcHMpIHtcbiAgICAgICAgaWYgKG9wcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9wID0gb3BzWzBdO1xuICAgICAgICBpZiAob3AgJiZcbiAgICAgICAgICAgIG9wLm9wID09PSB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFBsYW5uZWRcbiAgICAgICAgLy8gVE9ETyBXZSBtdXN0IGluZGl2aWR1YWxseSBjaGVjayBwcm9wZXJ0aWVzIGhlcmUgdGhhdCB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAvLyBleGVjdXRlIG9uLCBzdWNoIGFzIHJldHJ5IGNvdW50cy4gTm90aGluZyBleGlzdHMgaGVyZSB0aGF0IGZhbGxzIGluIHRvXG4gICAgICAgIC8vIHRoaXMgY2FzZSwgYnV0IHNob3VsZCBiZSBhY2NvdW50ZWQgZm9yIHdoZW4gd2UgYWRkIHRoZW0uXG4gICAgICAgIC8vICYmIHR5cGVvZiBvcC5vcHRzID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG9wLmlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBvdXRwdXQgYmVmb3JlIHJldHVybmluZy5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1PdXRwdXQoZGF0YU9yRXJyb3IsIHN0ZXApIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhT3JFcnJvcik7XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0LmVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvdXRwdXQuZGF0YSA9ICgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikob3V0cHV0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZE91dHB1dCA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtT3V0cHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLFxuICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dHB1dCksIHRyYW5zZm9ybWVkT3V0cHV0ID09PSBudWxsIHx8IHRyYW5zZm9ybWVkT3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZE91dHB1dC5yZXN1bHQpO1xuICAgICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmluaXNoZWQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCAodHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiID8geyBlcnJvciB9IDogeyBkYXRhIH0pKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuc3VyZSB3ZSBnaXZlIG1pZGRsZXdhcmUgdGhlIGNoYW5jZSB0byBkZWNpZGUgb24gcmV0cmlhYmxlIGJlaGF2aW91clxuICAgICAgICAgICAgICogYnkgbG9va2luZyBhdCB0aGUgZXJyb3IgcmV0dXJuZWQgZnJvbSBvdXRwdXQgdHJhbnNmb3JtYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCByZXRyaWFibGUgPSAhKGVycm9yIGluc3RhbmNlb2YgTm9uUmV0cmlhYmxlRXJyb3JfanNfMS5Ob25SZXRyaWFibGVFcnJvcik7XG4gICAgICAgICAgICBpZiAocmV0cmlhYmxlICYmIGVycm9yIGluc3RhbmNlb2YgUmV0cnlBZnRlckVycm9yX2pzXzEuUmV0cnlBZnRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0cmlhYmxlID0gZXJyb3IucmV0cnlBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRFcnJvciA9ICgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uLXJlamVjdGVkXCIsXG4gICAgICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgICAgIG9wczogdGhpcy5vcHMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHNlcmlhbGl6ZWRFcnJvcixcbiAgICAgICAgICAgICAgICByZXRyaWFibGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsXG4gICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgZGF0YTogKDAsIGZ1bmN0aW9uc19qc18xLnVuZGVmaW5lZFRvTnVsbCkoZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5WMElubmdlc3RFeGVjdXRpb24gPSBWMElubmdlc3RFeGVjdXRpb247XG5jb25zdCB0aWNrT3BUb091dGdvaW5nID0gKG9wKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3A6IG9wLm9wLFxuICAgICAgICBpZDogb3AuaWQsXG4gICAgICAgIG5hbWU6IG9wLm5hbWUsXG4gICAgICAgIG9wdHM6IG9wLm9wdHMsXG4gICAgfTtcbn07XG5jb25zdCBoYXNoRGF0YSA9IChvcCkgPT4ge1xuICAgIHJldHVybiAoMCwgaGFzaF9qc18xLnNoYTEpKCkudXBkYXRlKCgwLCBjYW5vbmljYWxpemVfMS5kZWZhdWx0KShvcCkpLmRpZ2VzdChcImhleFwiKTtcbn07XG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nLlxuICovXG5leHBvcnRzLl9pbnRlcm5hbHMgPSB7IGhhc2hEYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12MC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v0.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v1.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v1.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.createV1InngestExecution = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst StepError_js_1 = __webpack_require__(/*! ../StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst als_js_1 = __webpack_require__(/*! ./als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst access_js_1 = __webpack_require__(/*! ./otel/access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst createV1InngestExecution = (options) => {\n    return new V1InngestExecution(options);\n};\nexports.createV1InngestExecution = createV1InngestExecution;\nclass V1InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.timeoutDuration = 1000 * 10;\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n        this.checkpointHandlers = this.createCheckpointHandlers();\n        this.initializeTimer(this.state);\n        this.debug(\"created new V1 execution for run;\", this.options.requestedRunStep\n            ? `wanting to run step \"${this.options.requestedRunStep}\"`\n            : \"discovering steps\");\n        this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n    }\n    /**\n     * Idempotently start the execution of the user's function.\n     */\n    start() {\n        if (!this.execution) {\n            this.debug(\"starting V1 execution\");\n            const tracer = api_1.trace.getTracer(\"inngest\", version_js_1.version);\n            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als) => {\n                return als.run({ app: this.options.client, ctx: this.fnArg }, async () => {\n                    return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n                        var _a;\n                        (_a = access_js_1.clientProcessorMap.get(this.options.client)) === null || _a === void 0 ? void 0 : _a.declareStartingSpan({\n                            span,\n                            runId: this.options.runId,\n                            traceparent: this.options.headers[consts_js_1.headerKeys.TraceParent],\n                            tracestate: this.options.headers[consts_js_1.headerKeys.TraceState],\n                        });\n                        return this._start()\n                            .then((result) => {\n                            this.debug(\"result:\", result);\n                            return result;\n                        })\n                            .finally(() => {\n                            span.end();\n                        });\n                    });\n                });\n            });\n        }\n        return this.execution;\n    }\n    /**\n     * Starts execution of the user's function and the core loop.\n     */\n    async _start() {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        try {\n            const allCheckpointHandler = this.getCheckpointHandler(\"\");\n            this.state.hooks = await this.initializeMiddleware();\n            await this.startExecution();\n            try {\n                for (var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                    _c = _h.value;\n                    _f = false;\n                    const checkpoint = _c;\n                    await allCheckpointHandler(checkpoint);\n                    const handler = this.getCheckpointHandler(checkpoint.type);\n                    const result = await handler(checkpoint);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            void this.state.loop.return();\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));\n        }\n        /**\n         * If we're here, the generator somehow finished without returning a value.\n         * This should never happen.\n         */\n        throw new Error(\"Core loop finished without returning a value\");\n    }\n    /**\n     * Creates a handler for every checkpoint type, defining what to do when we\n     * reach that checkpoint in the core loop.\n     */\n    createCheckpointHandlers() {\n        return {\n            /**\n             * Run for all checkpoints. Best used for logging or common actions.\n             * Use other handlers to return values and interrupt the core loop.\n             */\n            \"\": (checkpoint) => {\n                this.debug(\"checkpoint:\", checkpoint);\n            },\n            /**\n             * The user's function has completed and returned a value.\n             */\n            \"function-resolved\": async (checkpoint) => {\n                return await this.transformOutput({ data: checkpoint.data });\n            },\n            /**\n             * The user's function has thrown an error.\n             */\n            \"function-rejected\": async (checkpoint) => {\n                return await this.transformOutput({ error: checkpoint.error });\n            },\n            /**\n             * We've found one or more steps. Here we may want to run a step or report\n             * them back to Inngest.\n             */\n            \"steps-found\": async ({ steps }) => {\n                const stepResult = await this.tryExecuteStep(steps);\n                if (stepResult) {\n                    const transformResult = await this.transformOutput(stepResult);\n                    /**\n                     * Transforming output will always return either function rejection or\n                     * resolution. In most cases, this can be immediately returned, but in\n                     * this particular case we want to handle it differently.\n                     */\n                    if (transformResult.type === \"function-resolved\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { data: transformResult.data })),\n                        };\n                    }\n                    else if (transformResult.type === \"function-rejected\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { error: transformResult.error })),\n                            retriable: transformResult.retriable,\n                        };\n                    }\n                    return transformResult;\n                }\n                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));\n                if (newSteps) {\n                    return {\n                        type: \"steps-found\",\n                        ctx: this.fnArg,\n                        ops: this.ops,\n                        steps: newSteps,\n                    };\n                }\n            },\n            /**\n             * While trying to find a step that Inngest has told us to run, we've\n             * timed out or have otherwise decided that it doesn't exist.\n             */\n            \"step-not-found\": ({ step }) => {\n                return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n            },\n        };\n    }\n    getCheckpointHandler(type) {\n        return this.checkpointHandlers[type];\n    }\n    async tryExecuteStep(steps) {\n        var _a;\n        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n        if (!hashedStepIdToRun) {\n            return;\n        }\n        const step = steps.find((step) => step.hashedId === hashedStepIdToRun && step.fn);\n        if (step) {\n            return await this.executeStep(step);\n        }\n        /**\n         * Ensure we reset the timeout if we have a requested run step but couldn't\n         * find it, but also that we don't reset if we found and executed it.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());\n    }\n    /**\n     * Given a list of outgoing ops, decide if we can execute an op early and\n     * return the ID of the step to execute if we can.\n     */\n    getEarlyExecRunStep(steps) {\n        /**\n         * We may have been disabled due to parallelism, in which case we can't\n         * immediately execute unless explicitly requested.\n         */\n        if (this.options.disableImmediateExecution)\n            return;\n        const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n        if (unfulfilledSteps.length !== 1)\n            return;\n        const op = unfulfilledSteps[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.hashedId;\n        }\n    }\n    async filterNewSteps(foundSteps) {\n        var _a, _b, _c, _d, _e, _f;\n        if (this.options.requestedRunStep) {\n            return;\n        }\n        /**\n         * Gather any steps that aren't memoized and report them.\n         */\n        const newSteps = foundSteps.filter((step) => !step.fulfilled);\n        if (!newSteps.length) {\n            return;\n        }\n        /**\n         * Warn if we've found new steps but haven't yet seen all previous\n         * steps. This may indicate that step presence isn't determinate.\n         */\n        let knownSteps = 0;\n        for (const step of foundSteps) {\n            if (step.fulfilled) {\n                knownSteps++;\n            }\n        }\n        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n        if (!foundAllCompletedSteps) {\n            // TODO Tag\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"Function may be indeterminate\",\n                why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n                consequences: \"This may cause unexpected behaviour as Inngest executes your function.\",\n                reassurance: \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n            }));\n        }\n        /**\n         * We're finishing up; let's trigger the last of the hooks.\n         */\n        await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        const stepList = newSteps.map((step) => ({\n            displayName: step.displayName,\n            op: step.op,\n            id: step.hashedId,\n            name: step.name,\n            opts: step.opts,\n        }));\n        /**\n         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n         * to ensure that their `data` is transformed correctly.\n         */\n        return await this.transformNewSteps(stepList);\n    }\n    /**\n     * Using middleware, transform any newly-found steps before returning them to\n     * an Inngest Server.\n     */\n    async transformNewSteps(steps) {\n        return Promise.all(steps.map(async (step) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {\n                return step;\n            }\n            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onSendEvent\", undefined, {\n                transformInput: (prev, output) => {\n                    return Object.assign(Object.assign({}, prev), output);\n                },\n                transformOutput: (prev, output) => {\n                    return {\n                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    };\n                },\n            });\n            /**\n             * For each event being sent, create a new `onSendEvent` hook stack to\n             * process it. We do this as middleware hooks are intended to run once\n             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n             * is run for every single event.\n             *\n             * This is done because a developer can use this hook to filter out\n             * events entirely; if we batch all of the events together, we can't\n             * tell which ones were filtered out if we're processing >1 invocation\n             * here.\n             */\n            const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {\n                payloads: [\n                    Object.assign(Object.assign({}, ((_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {})), { name: consts_js_1.internalEvents.FunctionInvoked }),\n                ],\n            }));\n            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});\n            return Object.assign(Object.assign({}, step), { opts: Object.assign(Object.assign({}, step.opts), { payload: Object.assign(Object.assign({}, ((_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {})), newPayload) }) });\n        }));\n    }\n    async executeStep({ id, name, opts, fn, displayName, }) {\n        var _a, _b, _c, _d, _e;\n        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));\n        const outgoingOp = {\n            id,\n            op: types_js_1.StepOpCode.StepRun,\n            name,\n            opts,\n            displayName,\n        };\n        this.state.executingStep = outgoingOp;\n        const store = await (0, als_js_1.getAsyncCtx)();\n        if (store) {\n            store.executingStep = {\n                id,\n                name: displayName,\n            };\n        }\n        this.debug(`executing step \"${id}\"`);\n        return ((0, promises_js_1.runAsPromise)(fn)\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b;\n            if (store) {\n                delete store.executingStep;\n            }\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n        })\n            .then((data) => {\n            return Object.assign(Object.assign({}, outgoingOp), { data });\n        })\n            .catch((error) => {\n            return Object.assign(Object.assign({}, outgoingOp), { op: types_js_1.StepOpCode.StepError, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error });\n        }));\n    }\n    /**\n     * Starts execution of the user's function, including triggering checkpoints\n     * and middleware hooks where appropriate.\n     */\n    async startExecution() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        /**\n         * Mutate input as neccessary based on middleware.\n         */\n        await this.transformInput();\n        /**\n         * Start the timer to time out the run if needed.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        /**\n         * If we had no state to begin with, immediately end the memoization phase.\n         */\n        if (this.state.allStateUsed()) {\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));\n            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));\n        }\n        /**\n         * Trigger the user's function.\n         */\n        (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg))\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        })\n            .then((data) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-resolved\", data });\n        })\n            .catch((error) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-rejected\", error });\n        });\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.state.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        /**\n         * If we've been given an error and it's one that we just threw from a step,\n         * we should return a `NonRetriableError` to stop execution.\n         */\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const isStepExecution = Boolean(this.state.executingStep);\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step: this.state.executingStep,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!isStepExecution) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n    createExecutionState() {\n        const d = (0, promises_js_1.createDeferredPromiseWithStack)();\n        let checkpointResolve = d.deferred.resolve;\n        const checkpointResults = d.results;\n        const loop = (function (cleanUp) {\n            return __asyncGenerator(this, arguments, function* () {\n                try {\n                    while (true) {\n                        const res = (yield __await(checkpointResults.next())).value;\n                        if (res) {\n                            yield yield __await(res);\n                        }\n                    }\n                }\n                finally {\n                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();\n                }\n            });\n        })(() => {\n            var _a;\n            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n            void checkpointResults.return();\n        });\n        const stepsToFulfill = Object.keys(this.options.stepState).length;\n        const state = {\n            stepState: this.options.stepState,\n            stepsToFulfill,\n            steps: new Map(),\n            loop,\n            hasSteps: Boolean(stepsToFulfill),\n            stepCompletionOrder: [...this.options.stepCompletionOrder],\n            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n            setCheckpoint: (checkpoint) => {\n                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n            },\n            allStateUsed: () => {\n                return this.state.remainingStepsToBeSeen.size === 0;\n            },\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(this.state.steps);\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        const step = this.createStepTools();\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        /**\n         * Handle use of the `onFailure` option by deserializing the error.\n         */\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    createStepTools() {\n        /**\n         * A list of steps that have been found and are being rolled up before being\n         * reported to the core loop.\n         */\n        const foundStepsToReport = new Map();\n        /**\n         * A map of the subset of found steps to report that have not yet been\n         * handled. Used for fast access to steps that need to be handled in order.\n         */\n        const unhandledFoundStepsToReport = new Map();\n        /**\n         * A map of the latest sequential step indexes found for each step ID. Used\n         * to ensure that we don't index steps in parallel.\n         *\n         * Note that these must be sequential; if we've seen or assigned `a:1`,\n         * `a:2` and `a:4`, the latest sequential step index is `2`.\n         *\n         */\n        const expectedNextStepIndexes = new Map();\n        /**\n         * An ordered list of step IDs that have yet to be handled in this\n         * execution. Used to ensure that we handle steps in the order they were\n         * found and based on the `stepCompletionOrder` in this execution's state.\n         */\n        const remainingStepCompletionOrder = this.state.stepCompletionOrder.slice();\n        /**\n         * A promise that's used to ensure that step reporting cannot be run more than\n         * once in a given asynchronous time span.\n         */\n        let foundStepsReportPromise;\n        /**\n         * A promise that's used to represent middleware hooks running before\n         * execution.\n         */\n        let beforeExecHooksPromise;\n        /**\n         * A flag used to ensure that we only warn about parallel indexing once per\n         * execution to avoid spamming the console.\n         */\n        let warnOfParallelIndexing = false;\n        /**\n         * Counts the number of times we've extended this tick.\n         */\n        let tickExtensionCount = 0;\n        /**\n         * Given a colliding step ID, maybe warn the user about parallel indexing.\n         */\n        const maybeWarnOfParallelIndexing = (collisionId) => {\n            if (warnOfParallelIndexing) {\n                return;\n            }\n            const stepExists = this.state.steps.has(collisionId);\n            if (stepExists) {\n                const stepFoundThisTick = foundStepsToReport.has(collisionId);\n                if (!stepFoundThisTick) {\n                    warnOfParallelIndexing = true;\n                    console.warn((0, errors_js_1.prettyError)({\n                        type: \"warn\",\n                        whatHappened: \"We detected that you have multiple steps with the same ID.\",\n                        code: errors_js_1.ErrCode.AUTOMATIC_PARALLEL_INDEXING,\n                        why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step \"${collisionId}\".`,\n                        reassurance: \"Your function is still running, though it may exhibit unexpected behaviour.\",\n                        consequences: \"Using the same IDs across parallel chains of work can cause unexpected behaviour.\",\n                        toFixNow: \"We recommend using a unique ID for each step, especially those happening in parallel.\",\n                    }));\n                }\n            }\n        };\n        /**\n         * A helper used to report steps to the core loop. Used after adding an item\n         * to `foundStepsToReport`.\n         */\n        const reportNextTick = () => {\n            // Being explicit instead of using `??=` to appease TypeScript.\n            if (foundStepsReportPromise) {\n                return;\n            }\n            let extensionPromise;\n            if (++tickExtensionCount >= 10) {\n                tickExtensionCount = 0;\n                extensionPromise = new Promise((resolve) => setTimeout(resolve));\n            }\n            else {\n                extensionPromise = (0, promises_js_1.resolveAfterPending)();\n            }\n            foundStepsReportPromise = extensionPromise\n                /**\n                 * Ensure that we wait for this promise to resolve before continuing.\n                 *\n                 * The groups in which steps are reported can affect how we detect some\n                 * more complex determinism issues like parallel indexing. This promise\n                 * can represent middleware hooks being run early, in the middle of\n                 * ingesting steps to report.\n                 *\n                 * Because of this, it's important we wait for this middleware to resolve\n                 * before continuing to report steps to ensure that all steps have a\n                 * chance to be reported throughout this asynchronous action.\n                 */\n                .then(() => beforeExecHooksPromise)\n                .then(() => {\n                var _a;\n                foundStepsReportPromise = undefined;\n                for (let i = 0; i < remainingStepCompletionOrder.length; i++) {\n                    const nextStepId = remainingStepCompletionOrder[i];\n                    if (!nextStepId) {\n                        // Strange - skip this empty index\n                        continue;\n                    }\n                    const handled = (_a = unhandledFoundStepsToReport\n                        .get(nextStepId)) === null || _a === void 0 ? void 0 : _a.handle();\n                    if (handled) {\n                        remainingStepCompletionOrder.splice(i, 1);\n                        unhandledFoundStepsToReport.delete(nextStepId);\n                        return void reportNextTick();\n                    }\n                }\n                // If we've handled no steps in this \"tick,\" roll up everything we've\n                // found and report it.\n                const steps = [...foundStepsToReport.values()];\n                foundStepsToReport.clear();\n                unhandledFoundStepsToReport.clear();\n                return void this.state.setCheckpoint({\n                    type: \"steps-found\",\n                    steps: steps,\n                });\n            });\n        };\n        /**\n         * A helper used to push a step to the list of steps to report.\n         */\n        const pushStepToReport = (step) => {\n            foundStepsToReport.set(step.id, step);\n            unhandledFoundStepsToReport.set(step.hashedId, step);\n            reportNextTick();\n        };\n        const stepHandler = async ({ args, matchOp, opts, }) => {\n            var _a, _b, _c, _d;\n            await beforeExecHooksPromise;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = matchOp(stepOptions, ...args.slice(1));\n            if (this.state.executingStep) {\n                /**\n                 * If a step is found after asynchronous actions during another step's\n                 * execution, everything is fine. The problem here is if we've found\n                 * that a step nested inside another a step, which is something we don't\n                 * support at the time of writing.\n                 *\n                 * In this case, we could use something like Async Hooks to understand\n                 * how the step is being triggered, though this isn't available in all\n                 * environments.\n                 *\n                 * Therefore, we'll only show a warning here to indicate that this is\n                 * potentially an issue.\n                 */\n                console.warn((0, errors_js_1.prettyError)({\n                    whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\\``,\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    type: \"warn\",\n                    reassurance: \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            if (this.state.steps.has(opId.id)) {\n                const originalId = opId.id;\n                maybeWarnOfParallelIndexing(originalId);\n                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;\n                for (let i = expectedNextIndex;; i++) {\n                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;\n                    if (!this.state.steps.has(newId)) {\n                        expectedNextStepIndexes.set(originalId, i + 1);\n                        opId.id = newId;\n                        break;\n                    }\n                }\n            }\n            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();\n            const hashedId = exports._internals.hashId(opId.id);\n            const stepState = this.state.stepState[hashedId];\n            let isFulfilled = false;\n            if (stepState) {\n                stepState.seen = true;\n                this.state.remainingStepsToBeSeen.delete(hashedId);\n                if (typeof stepState.input === \"undefined\") {\n                    isFulfilled = true;\n                }\n            }\n            let extraOpts;\n            let fnArgs = [...args];\n            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== \"undefined\" &&\n                Array.isArray(stepState.input)) {\n                switch (opId.op) {\n                    // `step.run()` has its function input affected\n                    case types_js_1.StepOpCode.StepPlanned: {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        fnArgs = [...args.slice(0, 2), ...stepState.input];\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        extraOpts = { input: [...stepState.input] };\n                        break;\n                    }\n                    // `step.ai.infer()` has its body affected\n                    case types_js_1.StepOpCode.AiGateway: {\n                        extraOpts = {\n                            body: Object.assign(Object.assign({}, (typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === \"object\"\n                                ? Object.assign({}, opId.opts.body) : {})), stepState.input[0]),\n                        };\n                        break;\n                    }\n                }\n            }\n            const step = Object.assign(Object.assign({}, opId), { opts: Object.assign(Object.assign({}, opId.opts), extraOpts), rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n                hashedId, input: stepState === null || stepState === void 0 ? void 0 : stepState.input, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs); } : undefined, promise, fulfilled: isFulfilled, hasStepState: Boolean(stepState), displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id, handled: false, handle: () => {\n                    if (step.handled) {\n                        return false;\n                    }\n                    step.handled = true;\n                    if (isFulfilled && stepState) {\n                        stepState.fulfilled = true;\n                        // For some execution scenarios such as testing, `data`, `error`,\n                        // and `input` may be `Promises`. This could also be the case for\n                        // future middleware applications. For this reason, we'll make sure\n                        // the values are fully resolved before continuing.\n                        void Promise.all([\n                            stepState.data,\n                            stepState.error,\n                            stepState.input,\n                        ]).then(() => {\n                            if (typeof stepState.data !== \"undefined\") {\n                                resolve(stepState.data);\n                            }\n                            else {\n                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);\n                                reject(this.state.recentlyRejectedStepError);\n                            }\n                        });\n                    }\n                    return true;\n                } });\n            this.state.steps.set(opId.id, step);\n            this.state.hasSteps = true;\n            pushStepToReport(step);\n            /**\n             * If this is the last piece of state we had, we've now finished\n             * memoizing.\n             */\n            if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n                await (beforeExecHooksPromise = (async () => {\n                    var _a, _b, _c, _d;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n                })());\n            }\n            return promise;\n        };\n        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        return this.options.fn[\"onFailureFn\"];\n    }\n    initializeTimer(state) {\n        if (!this.options.requestedRunStep) {\n            return;\n        }\n        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);\n        void this.timeout.then(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            state.setCheckpoint({\n                type: \"step-not-found\",\n                step: {\n                    id: this.options.requestedRunStep,\n                    op: types_js_1.StepOpCode.StepNotFound,\n                },\n            });\n        });\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n}\nconst hashId = (id) => {\n    return (0, hash_js_1.sha1)().update(id).digest(\"hex\");\n};\nconst hashOp = (op) => {\n    return Object.assign(Object.assign({}, op), { id: hashId(op.id) });\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashOp, hashId };\n//# sourceMappingURL=v1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0NBQWdDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsaUVBQWtCO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLDZGQUF5QjtBQUNoRSw4QkFBOEIsbUJBQU8sQ0FBQywyRkFBd0I7QUFDOUQsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDZCQUE2QixtQkFBTyxDQUFDLHlGQUF1QjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDaEQsOEJBQThCLG1CQUFPLENBQUMsb0dBQXVCO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLDBFQUFVO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlDQUF5QztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1QkFBdUI7QUFDM0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixpQkFBaUIsNEJBQTRCO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGlCQUFpQiw4QkFBOEI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw4R0FBOEcsTUFBTSxrREFBa0Q7QUFDeE47QUFDQSxhQUFhO0FBQ2IsK1FBQStRO0FBQy9RLGlEQUFpRCxXQUFXLG9DQUFvQyxnQkFBZ0IsdUNBQXVDLDhHQUE4RyxpQkFBaUIsR0FBRztBQUN6UixTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlEQUFpRCxpQkFBaUIsTUFBTTtBQUN4RSxTQUFTO0FBQ1Q7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0EsdUJBQXVCO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1QyxpQ0FBaUM7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsY0FBYyxnQ0FBZ0M7QUFDOUQ7QUFDQTtBQUNBLHdDQUF3QyxvQ0FBb0MsUUFBUSxJQUFJLE1BQU07QUFDOUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0IsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBLGtEQUFrRCxZQUFZLDJEQUEyRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUtBQXVLLFlBQVk7QUFDbkw7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlDQUF5QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsaUVBQWlFO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVyxvQ0FBb0M7QUFDdEc7QUFDQTtBQUNBLG9GQUFvRixRQUFRLHVGQUF1RjtBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUyxtQkFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2FzeW5jVmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn07XG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEFzeW5jSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5faW50ZXJuYWxzID0gZXhwb3J0cy5jcmVhdGVWMUlubmdlc3RFeGVjdXRpb24gPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBoYXNoX2pzXzEgPSByZXF1aXJlKFwiaGFzaC5qc1wiKTtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9lcnJvcnMuanNcIik7XG5jb25zdCBmdW5jdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2Z1bmN0aW9ucy5qc1wiKTtcbmNvbnN0IHByb21pc2VzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9wcm9taXNlcy5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXMuanNcIik7XG5jb25zdCB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdmVyc2lvbi5qc1wiKTtcbmNvbnN0IElubmdlc3RNaWRkbGV3YXJlX2pzXzEgPSByZXF1aXJlKFwiLi4vSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG5jb25zdCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEgPSByZXF1aXJlKFwiLi4vSW5uZ2VzdFN0ZXBUb29scy5qc1wiKTtcbmNvbnN0IE5vblJldHJpYWJsZUVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi4vTm9uUmV0cmlhYmxlRXJyb3IuanNcIik7XG5jb25zdCBSZXRyeUFmdGVyRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9SZXRyeUFmdGVyRXJyb3IuanNcIik7XG5jb25zdCBTdGVwRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9TdGVwRXJyb3IuanNcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCIpO1xuY29uc3QgYWxzX2pzXzEgPSByZXF1aXJlKFwiLi9hbHMuanNcIik7XG5jb25zdCBhY2Nlc3NfanNfMSA9IHJlcXVpcmUoXCIuL290ZWwvYWNjZXNzLmpzXCIpO1xuY29uc3QgY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFYxSW5uZ2VzdEV4ZWN1dGlvbihvcHRpb25zKTtcbn07XG5leHBvcnRzLmNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbiA9IGNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbjtcbmNsYXNzIFYxSW5uZ2VzdEV4ZWN1dGlvbiBleHRlbmRzIElubmdlc3RFeGVjdXRpb25fanNfMS5Jbm5nZXN0RXhlY3V0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRpbWVvdXREdXJhdGlvbiA9IDEwMDAgKiAxMDtcbiAgICAgICAgdGhpcy51c2VyRm5Ub1J1biA9IHRoaXMuZ2V0VXNlckZuVG9SdW4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuY3JlYXRlRXhlY3V0aW9uU3RhdGUoKTtcbiAgICAgICAgdGhpcy5mbkFyZyA9IHRoaXMuY3JlYXRlRm5BcmcoKTtcbiAgICAgICAgdGhpcy5jaGVja3BvaW50SGFuZGxlcnMgPSB0aGlzLmNyZWF0ZUNoZWNrcG9pbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVUaW1lcih0aGlzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImNyZWF0ZWQgbmV3IFYxIGV4ZWN1dGlvbiBmb3IgcnVuO1wiLCB0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcFxuICAgICAgICAgICAgPyBgd2FudGluZyB0byBydW4gc3RlcCBcIiR7dGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXB9XCJgXG4gICAgICAgICAgICA6IFwiZGlzY292ZXJpbmcgc3RlcHNcIik7XG4gICAgICAgIHRoaXMuZGVidWcoXCJleGlzdGluZyBzdGF0ZSBrZXlzOlwiLCBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLnN0ZXBTdGF0ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZGVtcG90ZW50bHkgc3RhcnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZXhlY3V0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKFwic3RhcnRpbmcgVjEgZXhlY3V0aW9uXCIpO1xuICAgICAgICAgICAgY29uc3QgdHJhY2VyID0gYXBpXzEudHJhY2UuZ2V0VHJhY2VyKFwiaW5uZ2VzdFwiLCB2ZXJzaW9uX2pzXzEudmVyc2lvbik7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGlvbiA9ICgwLCBhbHNfanNfMS5nZXRBc3luY0xvY2FsU3RvcmFnZSkoKS50aGVuKChhbHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxzLnJ1bih7IGFwcDogdGhpcy5vcHRpb25zLmNsaWVudCwgY3R4OiB0aGlzLmZuQXJnIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4oXCJpbm5nZXN0LmV4ZWN1dGlvblwiLCAoc3BhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gYWNjZXNzX2pzXzEuY2xpZW50UHJvY2Vzc29yTWFwLmdldCh0aGlzLm9wdGlvbnMuY2xpZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY2xhcmVTdGFydGluZ1NwYW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IHRoaXMub3B0aW9ucy5ydW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXBhcmVudDogdGhpcy5vcHRpb25zLmhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5UcmFjZVBhcmVudF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VzdGF0ZTogdGhpcy5vcHRpb25zLmhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5UcmFjZVN0YXRlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcInJlc3VsdDpcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uIGFuZCB0aGUgY29yZSBsb29wLlxuICAgICAqL1xuICAgIGFzeW5jIF9zdGFydCgpIHtcbiAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgdmFyIF9kLCBfZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFsbENoZWNrcG9pbnRIYW5kbGVyID0gdGhpcy5nZXRDaGVja3BvaW50SGFuZGxlcihcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaG9va3MgPSBhd2FpdCB0aGlzLmluaXRpYWxpemVNaWRkbGV3YXJlKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0RXhlY3V0aW9uKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgX2cgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc3RhdGUubG9vcCksIF9oOyBfaCA9IGF3YWl0IF9nLm5leHQoKSwgX2EgPSBfaC5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IF9oLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja3BvaW50ID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFsbENoZWNrcG9pbnRIYW5kbGVyKGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5nZXRDaGVja3BvaW50SGFuZGxlcihjaGVja3BvaW50LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IF9nLnJldHVybikpIGF3YWl0IF9iLmNhbGwoX2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5zdGF0ZS5sb29wLnJldHVybigpO1xuICAgICAgICAgICAgYXdhaXQgKChfZSA9IChfZCA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5iZWZvcmVSZXNwb25zZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgaGVyZSwgdGhlIGdlbmVyYXRvciBzb21laG93IGZpbmlzaGVkIHdpdGhvdXQgcmV0dXJuaW5nIGEgdmFsdWUuXG4gICAgICAgICAqIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcmUgbG9vcCBmaW5pc2hlZCB3aXRob3V0IHJldHVybmluZyBhIHZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFuZGxlciBmb3IgZXZlcnkgY2hlY2twb2ludCB0eXBlLCBkZWZpbmluZyB3aGF0IHRvIGRvIHdoZW4gd2VcbiAgICAgKiByZWFjaCB0aGF0IGNoZWNrcG9pbnQgaW4gdGhlIGNvcmUgbG9vcC5cbiAgICAgKi9cbiAgICBjcmVhdGVDaGVja3BvaW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJ1biBmb3IgYWxsIGNoZWNrcG9pbnRzLiBCZXN0IHVzZWQgZm9yIGxvZ2dpbmcgb3IgY29tbW9uIGFjdGlvbnMuXG4gICAgICAgICAgICAgKiBVc2Ugb3RoZXIgaGFuZGxlcnMgdG8gcmV0dXJuIHZhbHVlcyBhbmQgaW50ZXJydXB0IHRoZSBjb3JlIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiXCI6IChjaGVja3BvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcImNoZWNrcG9pbnQ6XCIsIGNoZWNrcG9pbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHVzZXIncyBmdW5jdGlvbiBoYXMgY29tcGxldGVkIGFuZCByZXR1cm5lZCBhIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZ1bmN0aW9uLXJlc29sdmVkXCI6IGFzeW5jIChjaGVja3BvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZGF0YTogY2hlY2twb2ludC5kYXRhIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHVzZXIncyBmdW5jdGlvbiBoYXMgdGhyb3duIGFuIGVycm9yLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZ1bmN0aW9uLXJlamVjdGVkXCI6IGFzeW5jIChjaGVja3BvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZXJyb3I6IGNoZWNrcG9pbnQuZXJyb3IgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSd2ZSBmb3VuZCBvbmUgb3IgbW9yZSBzdGVwcy4gSGVyZSB3ZSBtYXkgd2FudCB0byBydW4gYSBzdGVwIG9yIHJlcG9ydFxuICAgICAgICAgICAgICogdGhlbSBiYWNrIHRvIElubmdlc3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic3RlcHMtZm91bmRcIjogYXN5bmMgKHsgc3RlcHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBSZXN1bHQgPSBhd2FpdCB0aGlzLnRyeUV4ZWN1dGVTdGVwKHN0ZXBzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHQgPSBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dChzdGVwUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRyYW5zZm9ybWluZyBvdXRwdXQgd2lsbCBhbHdheXMgcmV0dXJuIGVpdGhlciBmdW5jdGlvbiByZWplY3Rpb24gb3JcbiAgICAgICAgICAgICAgICAgICAgICogcmVzb2x1dGlvbi4gSW4gbW9zdCBjYXNlcywgdGhpcyBjYW4gYmUgaW1tZWRpYXRlbHkgcmV0dXJuZWQsIGJ1dCBpblxuICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIHBhcnRpY3VsYXIgY2FzZSB3ZSB3YW50IHRvIGhhbmRsZSBpdCBkaWZmZXJlbnRseS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1SZXN1bHQudHlwZSA9PT0gXCJmdW5jdGlvbi1yZXNvbHZlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1yYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHg6IHRyYW5zZm9ybVJlc3VsdC5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiB0cmFuc2Zvcm1SZXN1bHQub3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IGV4cG9ydHMuX2ludGVybmFscy5oYXNoT3AoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGVwUmVzdWx0KSwgeyBkYXRhOiB0cmFuc2Zvcm1SZXN1bHQuZGF0YSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zZm9ybVJlc3VsdC50eXBlID09PSBcImZ1bmN0aW9uLXJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLXJhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogdHJhbnNmb3JtUmVzdWx0LmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHM6IHRyYW5zZm9ybVJlc3VsdC5vcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hPcChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXBSZXN1bHQpLCB7IGVycm9yOiB0cmFuc2Zvcm1SZXN1bHQuZXJyb3IgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpYWJsZTogdHJhbnNmb3JtUmVzdWx0LnJldHJpYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3RlcHMgPSBhd2FpdCB0aGlzLmZpbHRlck5ld1N0ZXBzKEFycmF5LmZyb20odGhpcy5zdGF0ZS5zdGVwcy52YWx1ZXMoKSkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGVwcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwcy1mb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBuZXdTdGVwcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGlsZSB0cnlpbmcgdG8gZmluZCBhIHN0ZXAgdGhhdCBJbm5nZXN0IGhhcyB0b2xkIHVzIHRvIHJ1biwgd2UndmVcbiAgICAgICAgICAgICAqIHRpbWVkIG91dCBvciBoYXZlIG90aGVyd2lzZSBkZWNpZGVkIHRoYXQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzdGVwLW5vdC1mb3VuZFwiOiAoeyBzdGVwIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0ZXAtbm90LWZvdW5kXCIsIGN0eDogdGhpcy5mbkFyZywgb3BzOiB0aGlzLm9wcywgc3RlcCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2hlY2twb2ludEhhbmRsZXIodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja3BvaW50SGFuZGxlcnNbdHlwZV07XG4gICAgfVxuICAgIGFzeW5jIHRyeUV4ZWN1dGVTdGVwKHN0ZXBzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaGFzaGVkU3RlcElkVG9SdW4gPSB0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCB8fCB0aGlzLmdldEVhcmx5RXhlY1J1blN0ZXAoc3RlcHMpO1xuICAgICAgICBpZiAoIWhhc2hlZFN0ZXBJZFRvUnVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzLmZpbmQoKHN0ZXApID0+IHN0ZXAuaGFzaGVkSWQgPT09IGhhc2hlZFN0ZXBJZFRvUnVuICYmIHN0ZXAuZm4pO1xuICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZVN0ZXAoc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuc3VyZSB3ZSByZXNldCB0aGUgdGltZW91dCBpZiB3ZSBoYXZlIGEgcmVxdWVzdGVkIHJ1biBzdGVwIGJ1dCBjb3VsZG4ndFxuICAgICAgICAgKiBmaW5kIGl0LCBidXQgYWxzbyB0aGF0IHdlIGRvbid0IHJlc2V0IGlmIHdlIGZvdW5kIGFuZCBleGVjdXRlZCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHZvaWQgKChfYSA9IHRoaXMudGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc2V0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGxpc3Qgb2Ygb3V0Z29pbmcgb3BzLCBkZWNpZGUgaWYgd2UgY2FuIGV4ZWN1dGUgYW4gb3AgZWFybHkgYW5kXG4gICAgICogcmV0dXJuIHRoZSBJRCBvZiB0aGUgc3RlcCB0byBleGVjdXRlIGlmIHdlIGNhbi5cbiAgICAgKi9cbiAgICBnZXRFYXJseUV4ZWNSdW5TdGVwKHN0ZXBzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBtYXkgaGF2ZSBiZWVuIGRpc2FibGVkIGR1ZSB0byBwYXJhbGxlbGlzbSwgaW4gd2hpY2ggY2FzZSB3ZSBjYW4ndFxuICAgICAgICAgKiBpbW1lZGlhdGVseSBleGVjdXRlIHVubGVzcyBleHBsaWNpdGx5IHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUltbWVkaWF0ZUV4ZWN1dGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdW5mdWxmaWxsZWRTdGVwcyA9IHN0ZXBzLmZpbHRlcigoc3RlcCkgPT4gIXN0ZXAuZnVsZmlsbGVkKTtcbiAgICAgICAgaWYgKHVuZnVsZmlsbGVkU3RlcHMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcCA9IHVuZnVsZmlsbGVkU3RlcHNbMF07XG4gICAgICAgIGlmIChvcCAmJlxuICAgICAgICAgICAgb3Aub3AgPT09IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZFxuICAgICAgICAvLyBUT0RPIFdlIG11c3QgaW5kaXZpZHVhbGx5IGNoZWNrIHByb3BlcnRpZXMgaGVyZSB0aGF0IHdlIGRvIG5vdCB3YW50IHRvXG4gICAgICAgIC8vIGV4ZWN1dGUgb24sIHN1Y2ggYXMgcmV0cnkgY291bnRzLiBOb3RoaW5nIGV4aXN0cyBoZXJlIHRoYXQgZmFsbHMgaW4gdG9cbiAgICAgICAgLy8gdGhpcyBjYXNlLCBidXQgc2hvdWxkIGJlIGFjY291bnRlZCBmb3Igd2hlbiB3ZSBhZGQgdGhlbS5cbiAgICAgICAgLy8gJiYgdHlwZW9mIG9wLm9wdHMgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gb3AuaGFzaGVkSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmlsdGVyTmV3U3RlcHMoZm91bmRTdGVwcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdhdGhlciBhbnkgc3RlcHMgdGhhdCBhcmVuJ3QgbWVtb2l6ZWQgYW5kIHJlcG9ydCB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgbmV3U3RlcHMgPSBmb3VuZFN0ZXBzLmZpbHRlcigoc3RlcCkgPT4gIXN0ZXAuZnVsZmlsbGVkKTtcbiAgICAgICAgaWYgKCFuZXdTdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2FybiBpZiB3ZSd2ZSBmb3VuZCBuZXcgc3RlcHMgYnV0IGhhdmVuJ3QgeWV0IHNlZW4gYWxsIHByZXZpb3VzXG4gICAgICAgICAqIHN0ZXBzLiBUaGlzIG1heSBpbmRpY2F0ZSB0aGF0IHN0ZXAgcHJlc2VuY2UgaXNuJ3QgZGV0ZXJtaW5hdGUuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQga25vd25TdGVwcyA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgc3RlcCBvZiBmb3VuZFN0ZXBzKSB7XG4gICAgICAgICAgICBpZiAoc3RlcC5mdWxmaWxsZWQpIHtcbiAgICAgICAgICAgICAgICBrbm93blN0ZXBzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm91bmRBbGxDb21wbGV0ZWRTdGVwcyA9IHRoaXMuc3RhdGUuc3RlcHNUb0Z1bGZpbGwgPT09IGtub3duU3RlcHM7XG4gICAgICAgIGlmICghZm91bmRBbGxDb21wbGV0ZWRTdGVwcykge1xuICAgICAgICAgICAgLy8gVE9ETyBUYWdcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIndhcm5cIixcbiAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiRnVuY3Rpb24gbWF5IGJlIGluZGV0ZXJtaW5hdGVcIixcbiAgICAgICAgICAgICAgICB3aHk6IFwiV2UgZm91bmQgbmV3IHN0ZXBzIGJlZm9yZSBzZWVpbmcgYWxsIHByZXZpb3VzIHN0ZXBzLCB3aGljaCBtYXkgaW5kaWNhdGUgdGhhdCB0aGUgZnVuY3Rpb24gaXMgbm9uLWRldGVybWluaXN0aWMuXCIsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIlRoaXMgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyIGFzIElubmdlc3QgZXhlY3V0ZXMgeW91ciBmdW5jdGlvbi5cIixcbiAgICAgICAgICAgICAgICByZWFzc3VyYW5jZTogXCJUaGlzIGlzIGV4cGVjdGVkIGlmIGEgZnVuY3Rpb24gaXMgdXBkYXRlZCBpbiB0aGUgbWlkZGxlIG9mIGEgcnVuLCBidXQgbWF5IGluZGljYXRlIGEgYnVnIGlmIG5vdC5cIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2UncmUgZmluaXNoaW5nIHVwOyBsZXQncyB0cmlnZ2VyIHRoZSBsYXN0IG9mIHRoZSBob29rcy5cbiAgICAgICAgICovXG4gICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgIGF3YWl0ICgoX2YgPSAoX2UgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgIGNvbnN0IHN0ZXBMaXN0ID0gbmV3U3RlcHMubWFwKChzdGVwKSA9PiAoe1xuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHN0ZXAuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICBvcDogc3RlcC5vcCxcbiAgICAgICAgICAgIGlkOiBzdGVwLmhhc2hlZElkLFxuICAgICAgICAgICAgbmFtZTogc3RlcC5uYW1lLFxuICAgICAgICAgICAgb3B0czogc3RlcC5vcHRzLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBhbHNvIHJ1biBgb25TZW5kRXZlbnRgIG1pZGRsZXdhcmUgaG9va3MgYWdhaW5zdCBgc3RlcC5pbnZva2UoKWAgc3RlcHNcbiAgICAgICAgICogdG8gZW5zdXJlIHRoYXQgdGhlaXIgYGRhdGFgIGlzIHRyYW5zZm9ybWVkIGNvcnJlY3RseS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU5ld1N0ZXBzKHN0ZXBMaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGFueSBuZXdseS1mb3VuZCBzdGVwcyBiZWZvcmUgcmV0dXJuaW5nIHRoZW0gdG9cbiAgICAgKiBhbiBJbm5nZXN0IFNlcnZlci5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1OZXdTdGVwcyhzdGVwcykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoc3RlcHMubWFwKGFzeW5jIChzdGVwKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgICBpZiAoc3RlcC5vcCAhPT0gdHlwZXNfanNfMS5TdGVwT3BDb2RlLkludm9rZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvblNlbmRFdmVudEhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uU2VuZEV2ZW50XCIsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYpLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5yZXN1bHQpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQucmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBlYWNoIGV2ZW50IGJlaW5nIHNlbnQsIGNyZWF0ZSBhIG5ldyBgb25TZW5kRXZlbnRgIGhvb2sgc3RhY2sgdG9cbiAgICAgICAgICAgICAqIHByb2Nlc3MgaXQuIFdlIGRvIHRoaXMgYXMgbWlkZGxld2FyZSBob29rcyBhcmUgaW50ZW5kZWQgdG8gcnVuIG9uY2VcbiAgICAgICAgICAgICAqIGR1cmluZyBlYWNoIGxpZmVjeWNsZSAob25GdW5jdGlvblJ1biBvciBvblNlbmRFdmVudCkgYW5kIGhlcmUsIGEgaG9va1xuICAgICAgICAgICAgICogaXMgcnVuIGZvciBldmVyeSBzaW5nbGUgZXZlbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhpcyBpcyBkb25lIGJlY2F1c2UgYSBkZXZlbG9wZXIgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZmlsdGVyIG91dFxuICAgICAgICAgICAgICogZXZlbnRzIGVudGlyZWx5OyBpZiB3ZSBiYXRjaCBhbGwgb2YgdGhlIGV2ZW50cyB0b2dldGhlciwgd2UgY2FuJ3RcbiAgICAgICAgICAgICAqIHRlbGwgd2hpY2ggb25lcyB3ZXJlIGZpbHRlcmVkIG91dCBpZiB3ZSdyZSBwcm9jZXNzaW5nID4xIGludm9jYXRpb25cbiAgICAgICAgICAgICAqIGhlcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGF5bG9hZCA9IGF3YWl0ICgoX2EgPSBvblNlbmRFdmVudEhvb2tzLnRyYW5zZm9ybUlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvblNlbmRFdmVudEhvb2tzLCB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoKF9jID0gKF9iID0gc3RlcC5vcHRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGF5bG9hZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30pKSwgeyBuYW1lOiBjb25zdHNfanNfMS5pbnRlcm5hbEV2ZW50cy5GdW5jdGlvbkludm9rZWQgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BheWxvYWQgPSBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuaW52b2tlUGF5bG9hZFNjaGVtYS5wYXJzZSgoX2UgPSAoX2QgPSB0cmFuc2Zvcm1lZFBheWxvYWQgPT09IG51bGwgfHwgdHJhbnNmb3JtZWRQYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZFBheWxvYWQucGF5bG9hZHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDoge30pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcCksIHsgb3B0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGVwLm9wdHMpLCB7IHBheWxvYWQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKChfZyA9IChfZiA9IHN0ZXAub3B0cykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnBheWxvYWQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHt9KSksIG5ld1BheWxvYWQpIH0pIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGVTdGVwKHsgaWQsIG5hbWUsIG9wdHMsIGZuLCBkaXNwbGF5TmFtZSwgfSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAoX2EgPSB0aGlzLnRpbWVvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhcigpO1xuICAgICAgICBhd2FpdCAoKF9jID0gKF9iID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKSk7XG4gICAgICAgIGF3YWl0ICgoX2UgPSAoX2QgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICBjb25zdCBvdXRnb2luZ09wID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBSdW4sXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXAgPSBvdXRnb2luZ09wO1xuICAgICAgICBjb25zdCBzdG9yZSA9IGF3YWl0ICgwLCBhbHNfanNfMS5nZXRBc3luY0N0eCkoKTtcbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICBzdG9yZS5leGVjdXRpbmdTdGVwID0ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKGBleGVjdXRpbmcgc3RlcCBcIiR7aWR9XCJgKTtcbiAgICAgICAgcmV0dXJuICgoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKGZuKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgICAgICAgICAuZmluYWxseShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0b3JlLmV4ZWN1dGluZ1N0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dGdvaW5nT3ApLCB7IGRhdGEgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdXRnb2luZ09wKSwgeyBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBFcnJvciwgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGVycm9yIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBleGVjdXRpb24gb2YgdGhlIHVzZXIncyBmdW5jdGlvbiwgaW5jbHVkaW5nIHRyaWdnZXJpbmcgY2hlY2twb2ludHNcbiAgICAgKiBhbmQgbWlkZGxld2FyZSBob29rcyB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdGFydEV4ZWN1dGlvbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAvKipcbiAgICAgICAgICogTXV0YXRlIGlucHV0IGFzIG5lY2Nlc3NhcnkgYmFzZWQgb24gbWlkZGxld2FyZS5cbiAgICAgICAgICovXG4gICAgICAgIGF3YWl0IHRoaXMudHJhbnNmb3JtSW5wdXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IHRoZSB0aW1lciB0byB0aW1lIG91dCB0aGUgcnVuIGlmIG5lZWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHZvaWQgKChfYSA9IHRoaXMudGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0KCkpO1xuICAgICAgICBhd2FpdCAoKF9jID0gKF9iID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJlZm9yZU1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYikpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UgaGFkIG5vIHN0YXRlIHRvIGJlZ2luIHdpdGgsIGltbWVkaWF0ZWx5IGVuZCB0aGUgbWVtb2l6YXRpb24gcGhhc2UuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5hbGxTdGF0ZVVzZWQoKSkge1xuICAgICAgICAgICAgYXdhaXQgKChfZSA9IChfZCA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICAgICAgYXdhaXQgKChfZyA9IChfZiA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5jYWxsKF9mKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgdGhlIHVzZXIncyBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgICgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoKCkgPT4gdGhpcy51c2VyRm5Ub1J1bih0aGlzLmZuQXJnKSlcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgICAgICAgICAgLmZpbmFsbHkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2YgPSAoX2UgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDaGVja3BvaW50KHsgdHlwZTogXCJmdW5jdGlvbi1yZXNvbHZlZFwiLCBkYXRhIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDaGVja3BvaW50KHsgdHlwZTogXCJmdW5jdGlvbi1yZWplY3RlZFwiLCBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBpbnB1dCBiZWZvcmUgcnVubmluZy5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1JbnB1dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgaW5wdXRNdXRhdGlvbnMgPSBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zZm9ybUlucHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZuQXJnKSxcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUuc3RlcFN0YXRlKSxcbiAgICAgICAgICAgIGZuOiB0aGlzLm9wdGlvbnMuZm4sXG4gICAgICAgICAgICByZXFBcmdzOiB0aGlzLm9wdGlvbnMucmVxQXJncyxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoaW5wdXRNdXRhdGlvbnMgPT09IG51bGwgfHwgaW5wdXRNdXRhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0TXV0YXRpb25zLmN0eCkge1xuICAgICAgICAgICAgdGhpcy5mbkFyZyA9IGlucHV0TXV0YXRpb25zLmN0eDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRNdXRhdGlvbnMgPT09IG51bGwgfHwgaW5wdXRNdXRhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0TXV0YXRpb25zLnN0ZXBzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0ZXBTdGF0ZSA9IE9iamVjdC5mcm9tRW50cmllcyhpbnB1dE11dGF0aW9ucy5zdGVwcy5tYXAoKHN0ZXApID0+IFtzdGVwLmlkLCBzdGVwXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBvdXRwdXQgYmVmb3JlIHJldHVybmluZy5cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zvcm1PdXRwdXQoZGF0YU9yRXJyb3IpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhT3JFcnJvcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGFuIGVycm9yIGFuZCBpdCdzIG9uZSB0aGF0IHdlIGp1c3QgdGhyZXcgZnJvbSBhIHN0ZXAsXG4gICAgICAgICAqIHdlIHNob3VsZCByZXR1cm4gYSBgTm9uUmV0cmlhYmxlRXJyb3JgIHRvIHN0b3AgZXhlY3V0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXQuZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG91dHB1dC5kYXRhID0gKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShvdXRwdXQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU3RlcEV4ZWN1dGlvbiA9IEJvb2xlYW4odGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRPdXRwdXQgPSBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zZm9ybU91dHB1dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSxcbiAgICAgICAgICAgIHN0ZXA6IHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dHB1dCksIHRyYW5zZm9ybWVkT3V0cHV0ID09PSBudWxsIHx8IHRyYW5zZm9ybWVkT3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZE91dHB1dC5yZXN1bHQpO1xuICAgICAgICBpZiAoIWlzU3RlcEV4ZWN1dGlvbikge1xuICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maW5pc2hlZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oe30sICh0eXBlb2YgZXJyb3IgIT09IFwidW5kZWZpbmVkXCIgPyB7IGVycm9yIH0gOiB7IGRhdGEgfSkpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5zdXJlIHdlIGdpdmUgbWlkZGxld2FyZSB0aGUgY2hhbmNlIHRvIGRlY2lkZSBvbiByZXRyaWFibGUgYmVoYXZpb3VyXG4gICAgICAgICAgICAgKiBieSBsb29raW5nIGF0IHRoZSBlcnJvciByZXR1cm5lZCBmcm9tIG91dHB1dCB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IHJldHJpYWJsZSA9ICEoZXJyb3IgaW5zdGFuY2VvZiBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgU3RlcEVycm9yX2pzXzEuU3RlcEVycm9yKTtcbiAgICAgICAgICAgIGlmIChyZXRyaWFibGUgJiYgZXJyb3IgaW5zdGFuY2VvZiBSZXRyeUFmdGVyRXJyb3JfanNfMS5SZXRyeUFmdGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXRyaWFibGUgPSBlcnJvci5yZXRyeUFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVycm9yID0gKDAsIGVycm9yc19qc18xLm1pbmlmeVByZXR0eUVycm9yKSgoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogc2VyaWFsaXplZEVycm9yLFxuICAgICAgICAgICAgICAgIHJldHJpYWJsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb24tcmVzb2x2ZWRcIixcbiAgICAgICAgICAgIGN0eDogdGhpcy5mbkFyZyxcbiAgICAgICAgICAgIG9wczogdGhpcy5vcHMsXG4gICAgICAgICAgICBkYXRhOiAoMCwgZnVuY3Rpb25zX2pzXzEudW5kZWZpbmVkVG9OdWxsKShkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlRXhlY3V0aW9uU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IGQgPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2spKCk7XG4gICAgICAgIGxldCBjaGVja3BvaW50UmVzb2x2ZSA9IGQuZGVmZXJyZWQucmVzb2x2ZTtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludFJlc3VsdHMgPSBkLnJlc3VsdHM7XG4gICAgICAgIGNvbnN0IGxvb3AgPSAoZnVuY3Rpb24gKGNsZWFuVXApIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gKHlpZWxkIF9fYXdhaXQoY2hlY2twb2ludFJlc3VsdHMubmV4dCgpKSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhblVwID09PSBudWxsIHx8IGNsZWFuVXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXIoKTtcbiAgICAgICAgICAgIHZvaWQgY2hlY2twb2ludFJlc3VsdHMucmV0dXJuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdGVwc1RvRnVsZmlsbCA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBzdGVwU3RhdGU6IHRoaXMub3B0aW9ucy5zdGVwU3RhdGUsXG4gICAgICAgICAgICBzdGVwc1RvRnVsZmlsbCxcbiAgICAgICAgICAgIHN0ZXBzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBsb29wLFxuICAgICAgICAgICAgaGFzU3RlcHM6IEJvb2xlYW4oc3RlcHNUb0Z1bGZpbGwpLFxuICAgICAgICAgICAgc3RlcENvbXBsZXRpb25PcmRlcjogWy4uLnRoaXMub3B0aW9ucy5zdGVwQ29tcGxldGlvbk9yZGVyXSxcbiAgICAgICAgICAgIHJlbWFpbmluZ1N0ZXBzVG9CZVNlZW46IG5ldyBTZXQodGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXIpLFxuICAgICAgICAgICAgc2V0Q2hlY2twb2ludDogKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICAoeyByZXNvbHZlOiBjaGVja3BvaW50UmVzb2x2ZSB9ID0gY2hlY2twb2ludFJlc29sdmUoY2hlY2twb2ludCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbFN0YXRlVXNlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJlbWFpbmluZ1N0ZXBzVG9CZVNlZW4uc2l6ZSA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZ2V0IG9wcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnN0YXRlLnN0ZXBzKTtcbiAgICB9XG4gICAgY3JlYXRlRm5BcmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuY3JlYXRlU3RlcFRvb2xzKCk7XG4gICAgICAgIGxldCBmbkFyZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLmRhdGEpLCB7IHN0ZXAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGUgdXNlIG9mIHRoZSBgb25GYWlsdXJlYCBvcHRpb24gYnkgZGVzZXJpYWxpemluZyB0aGUgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzRmFpbHVyZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAub2JqZWN0KHsgZXJyb3I6IHR5cGVzX2pzXzEuanNvbkVycm9yU2NoZW1hIH0pXG4gICAgICAgICAgICAgICAgLnBhcnNlKChfYSA9IGZuQXJnLmV2ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSk7XG4gICAgICAgICAgICBmbkFyZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm5BcmcpLCB7IGVycm9yOiAoMCwgZXJyb3JzX2pzXzEuZGVzZXJpYWxpemVFcnJvcikoZXZlbnREYXRhLmVycm9yKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9kID0gKF9jID0gKF9iID0gdGhpcy5vcHRpb25zKS50cmFuc2Zvcm1DdHgpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBmbkFyZykpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZuQXJnO1xuICAgIH1cbiAgICBjcmVhdGVTdGVwVG9vbHMoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2Ygc3RlcHMgdGhhdCBoYXZlIGJlZW4gZm91bmQgYW5kIGFyZSBiZWluZyByb2xsZWQgdXAgYmVmb3JlIGJlaW5nXG4gICAgICAgICAqIHJlcG9ydGVkIHRvIHRoZSBjb3JlIGxvb3AuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBmb3VuZFN0ZXBzVG9SZXBvcnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiB0aGUgc3Vic2V0IG9mIGZvdW5kIHN0ZXBzIHRvIHJlcG9ydCB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgICAgICAqIGhhbmRsZWQuIFVzZWQgZm9yIGZhc3QgYWNjZXNzIHRvIHN0ZXBzIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkIGluIG9yZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgdGhlIGxhdGVzdCBzZXF1ZW50aWFsIHN0ZXAgaW5kZXhlcyBmb3VuZCBmb3IgZWFjaCBzdGVwIElELiBVc2VkXG4gICAgICAgICAqIHRvIGVuc3VyZSB0aGF0IHdlIGRvbid0IGluZGV4IHN0ZXBzIGluIHBhcmFsbGVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlc2UgbXVzdCBiZSBzZXF1ZW50aWFsOyBpZiB3ZSd2ZSBzZWVuIG9yIGFzc2lnbmVkIGBhOjFgLFxuICAgICAgICAgKiBgYToyYCBhbmQgYGE6NGAsIHRoZSBsYXRlc3Qgc2VxdWVudGlhbCBzdGVwIGluZGV4IGlzIGAyYC5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3JkZXJlZCBsaXN0IG9mIHN0ZXAgSURzIHRoYXQgaGF2ZSB5ZXQgdG8gYmUgaGFuZGxlZCBpbiB0aGlzXG4gICAgICAgICAqIGV4ZWN1dGlvbi4gVXNlZCB0byBlbnN1cmUgdGhhdCB3ZSBoYW5kbGUgc3RlcHMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZVxuICAgICAgICAgKiBmb3VuZCBhbmQgYmFzZWQgb24gdGhlIGBzdGVwQ29tcGxldGlvbk9yZGVyYCBpbiB0aGlzIGV4ZWN1dGlvbidzIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVtYWluaW5nU3RlcENvbXBsZXRpb25PcmRlciA9IHRoaXMuc3RhdGUuc3RlcENvbXBsZXRpb25PcmRlci5zbGljZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcm9taXNlIHRoYXQncyB1c2VkIHRvIGVuc3VyZSB0aGF0IHN0ZXAgcmVwb3J0aW5nIGNhbm5vdCBiZSBydW4gbW9yZSB0aGFuXG4gICAgICAgICAqIG9uY2UgaW4gYSBnaXZlbiBhc3luY2hyb25vdXMgdGltZSBzcGFuLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcm9taXNlIHRoYXQncyB1c2VkIHRvIHJlcHJlc2VudCBtaWRkbGV3YXJlIGhvb2tzIHJ1bm5pbmcgYmVmb3JlXG4gICAgICAgICAqIGV4ZWN1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBiZWZvcmVFeGVjSG9va3NQcm9taXNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHVzZWQgdG8gZW5zdXJlIHRoYXQgd2Ugb25seSB3YXJuIGFib3V0IHBhcmFsbGVsIGluZGV4aW5nIG9uY2UgcGVyXG4gICAgICAgICAqIGV4ZWN1dGlvbiB0byBhdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCB3YXJuT2ZQYXJhbGxlbEluZGV4aW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiB0aW1lcyB3ZSd2ZSBleHRlbmRlZCB0aGlzIHRpY2suXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgdGlja0V4dGVuc2lvbkNvdW50ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgY29sbGlkaW5nIHN0ZXAgSUQsIG1heWJlIHdhcm4gdGhlIHVzZXIgYWJvdXQgcGFyYWxsZWwgaW5kZXhpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBtYXliZVdhcm5PZlBhcmFsbGVsSW5kZXhpbmcgPSAoY29sbGlzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIGlmICh3YXJuT2ZQYXJhbGxlbEluZGV4aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RlcEV4aXN0cyA9IHRoaXMuc3RhdGUuc3RlcHMuaGFzKGNvbGxpc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChzdGVwRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcEZvdW5kVGhpc1RpY2sgPSBmb3VuZFN0ZXBzVG9SZXBvcnQuaGFzKGNvbGxpc2lvbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0ZXBGb3VuZFRoaXNUaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5PZlBhcmFsbGVsSW5kZXhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIndhcm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJXZSBkZXRlY3RlZCB0aGF0IHlvdSBoYXZlIG11bHRpcGxlIHN0ZXBzIHdpdGggdGhlIHNhbWUgSUQuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvcnNfanNfMS5FcnJDb2RlLkFVVE9NQVRJQ19QQVJBTExFTF9JTkRFWElORyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoeTogYFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UncmUgdXNpbmcgdGhlIHNhbWUgSUQgZm9yIG11bHRpcGxlIHN0ZXBzIGFjcm9zcyBkaWZmZXJlbnQgY2hhaW5zIG9mIHBhcmFsbGVsIHdvcmsuIFdlIGZvdW5kIHRoZSBpc3N1ZSB3aXRoIHN0ZXAgXCIke2NvbGxpc2lvbklkfVwiLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzc3VyYW5jZTogXCJZb3VyIGZ1bmN0aW9uIGlzIHN0aWxsIHJ1bm5pbmcsIHRob3VnaCBpdCBtYXkgZXhoaWJpdCB1bmV4cGVjdGVkIGJlaGF2aW91ci5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJVc2luZyB0aGUgc2FtZSBJRHMgYWNyb3NzIHBhcmFsbGVsIGNoYWlucyBvZiB3b3JrIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ci5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvRml4Tm93OiBcIldlIHJlY29tbWVuZCB1c2luZyBhIHVuaXF1ZSBJRCBmb3IgZWFjaCBzdGVwLCBlc3BlY2lhbGx5IHRob3NlIGhhcHBlbmluZyBpbiBwYXJhbGxlbC5cIixcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIHVzZWQgdG8gcmVwb3J0IHN0ZXBzIHRvIHRoZSBjb3JlIGxvb3AuIFVzZWQgYWZ0ZXIgYWRkaW5nIGFuIGl0ZW1cbiAgICAgICAgICogdG8gYGZvdW5kU3RlcHNUb1JlcG9ydGAuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXBvcnROZXh0VGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJlaW5nIGV4cGxpY2l0IGluc3RlYWQgb2YgdXNpbmcgYD8/PWAgdG8gYXBwZWFzZSBUeXBlU2NyaXB0LlxuICAgICAgICAgICAgaWYgKGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4dGVuc2lvblByb21pc2U7XG4gICAgICAgICAgICBpZiAoKyt0aWNrRXh0ZW5zaW9uQ291bnQgPj0gMTApIHtcbiAgICAgICAgICAgICAgICB0aWNrRXh0ZW5zaW9uQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25Qcm9taXNlID0gKDAsIHByb21pc2VzX2pzXzEucmVzb2x2ZUFmdGVyUGVuZGluZykoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlID0gZXh0ZW5zaW9uUHJvbWlzZVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEVuc3VyZSB0aGF0IHdlIHdhaXQgZm9yIHRoaXMgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogVGhlIGdyb3VwcyBpbiB3aGljaCBzdGVwcyBhcmUgcmVwb3J0ZWQgY2FuIGFmZmVjdCBob3cgd2UgZGV0ZWN0IHNvbWVcbiAgICAgICAgICAgICAgICAgKiBtb3JlIGNvbXBsZXggZGV0ZXJtaW5pc20gaXNzdWVzIGxpa2UgcGFyYWxsZWwgaW5kZXhpbmcuIFRoaXMgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAqIGNhbiByZXByZXNlbnQgbWlkZGxld2FyZSBob29rcyBiZWluZyBydW4gZWFybHksIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgICAgICAgICAgKiBpbmdlc3Rpbmcgc3RlcHMgdG8gcmVwb3J0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQmVjYXVzZSBvZiB0aGlzLCBpdCdzIGltcG9ydGFudCB3ZSB3YWl0IGZvciB0aGlzIG1pZGRsZXdhcmUgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAqIGJlZm9yZSBjb250aW51aW5nIHRvIHJlcG9ydCBzdGVwcyB0byBlbnN1cmUgdGhhdCBhbGwgc3RlcHMgaGF2ZSBhXG4gICAgICAgICAgICAgICAgICogY2hhbmNlIHRvIGJlIHJlcG9ydGVkIHRocm91Z2hvdXQgdGhpcyBhc3luY2hyb25vdXMgYWN0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGJlZm9yZUV4ZWNIb29rc1Byb21pc2UpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbWFpbmluZ1N0ZXBDb21wbGV0aW9uT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFN0ZXBJZCA9IHJlbWFpbmluZ1N0ZXBDb21wbGV0aW9uT3JkZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFN0ZXBJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyYW5nZSAtIHNraXAgdGhpcyBlbXB0eSBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlZCA9IChfYSA9IHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldChuZXh0U3RlcElkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbmRsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nU3RlcENvbXBsZXRpb25PcmRlci5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuZGVsZXRlKG5leHRTdGVwSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgcmVwb3J0TmV4dFRpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBoYW5kbGVkIG5vIHN0ZXBzIGluIHRoaXMgXCJ0aWNrLFwiIHJvbGwgdXAgZXZlcnl0aGluZyB3ZSd2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGFuZCByZXBvcnQgaXQuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSBbLi4uZm91bmRTdGVwc1RvUmVwb3J0LnZhbHVlcygpXTtcbiAgICAgICAgICAgICAgICBmb3VuZFN0ZXBzVG9SZXBvcnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXBzLWZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBzdGVwcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdXNlZCB0byBwdXNoIGEgc3RlcCB0byB0aGUgbGlzdCBvZiBzdGVwcyB0byByZXBvcnQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwdXNoU3RlcFRvUmVwb3J0ID0gKHN0ZXApID0+IHtcbiAgICAgICAgICAgIGZvdW5kU3RlcHNUb1JlcG9ydC5zZXQoc3RlcC5pZCwgc3RlcCk7XG4gICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuc2V0KHN0ZXAuaGFzaGVkSWQsIHN0ZXApO1xuICAgICAgICAgICAgcmVwb3J0TmV4dFRpY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RlcEhhbmRsZXIgPSBhc3luYyAoeyBhcmdzLCBtYXRjaE9wLCBvcHRzLCB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBhd2FpdCBiZWZvcmVFeGVjSG9va3NQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgc3RlcE9wdGlvbnMgPSAoMCwgSW5uZ2VzdFN0ZXBUb29sc19qc18xLmdldFN0ZXBPcHRpb25zKShhcmdzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IG9wSWQgPSBtYXRjaE9wKHN0ZXBPcHRpb25zLCAuLi5hcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBhIHN0ZXAgaXMgZm91bmQgYWZ0ZXIgYXN5bmNocm9ub3VzIGFjdGlvbnMgZHVyaW5nIGFub3RoZXIgc3RlcCdzXG4gICAgICAgICAgICAgICAgICogZXhlY3V0aW9uLCBldmVyeXRoaW5nIGlzIGZpbmUuIFRoZSBwcm9ibGVtIGhlcmUgaXMgaWYgd2UndmUgZm91bmRcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGEgc3RlcCBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgYSBzdGVwLCB3aGljaCBpcyBzb21ldGhpbmcgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgKiBzdXBwb3J0IGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBJbiB0aGlzIGNhc2UsIHdlIGNvdWxkIHVzZSBzb21ldGhpbmcgbGlrZSBBc3luYyBIb29rcyB0byB1bmRlcnN0YW5kXG4gICAgICAgICAgICAgICAgICogaG93IHRoZSBzdGVwIGlzIGJlaW5nIHRyaWdnZXJlZCwgdGhvdWdoIHRoaXMgaXNuJ3QgYXZhaWxhYmxlIGluIGFsbFxuICAgICAgICAgICAgICAgICAqIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlZm9yZSwgd2UnbGwgb25seSBzaG93IGEgd2FybmluZyBoZXJlIHRvIGluZGljYXRlIHRoYXQgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAqIHBvdGVudGlhbGx5IGFuIGlzc3VlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBgV2UgZGV0ZWN0ZWQgdGhhdCB5b3UgaGF2ZSBuZXN0ZWQgXFxgc3RlcC4qXFxgIHRvb2xpbmcgaW4gXFxgJHsoX2EgPSBvcElkLmRpc3BsYXlOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcElkLmlkfVxcYGAsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJOZXN0aW5nIGBzdGVwLipgIHRvb2xpbmcgaXMgbm90IHN1cHBvcnRlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ3YXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNzdXJhbmNlOiBcIkl0J3MgcG9zc2libGUgdG8gc2VlIHRoaXMgd2FybmluZyBpZiBzdGVwcyBhcmUgc2VwYXJhdGVkIGJ5IHJlZ3VsYXIgYXN5bmNocm9ub3VzIGNhbGxzLCB3aGljaCBpcyBmaW5lLlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9GaXhOb3c6IFwiTWFrZSBzdXJlIHlvdSdyZSBub3QgdXNpbmcgYHN0ZXAuKmAgdG9vbGluZyBpbnNpZGUgb2Ygb3RoZXIgYHN0ZXAuKmAgdG9vbGluZy4gSWYgeW91IG5lZWQgdG8gY29tcG9zZSBzdGVwcyB0b2dldGhlciwgeW91IGNhbiBjcmVhdGUgYSBuZXcgYXN5bmMgZnVuY3Rpb24gYW5kIGNhbGwgaXQgZnJvbSB3aXRoaW4geW91ciBzdGVwIGZ1bmN0aW9uLCBvciB1c2UgcHJvbWlzZSBjaGFpbmluZy5cIixcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JzX2pzXzEuRXJyQ29kZS5ORVNUSU5HX1NURVBTLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnN0ZXBzLmhhcyhvcElkLmlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSWQgPSBvcElkLmlkO1xuICAgICAgICAgICAgICAgIG1heWJlV2Fybk9mUGFyYWxsZWxJbmRleGluZyhvcmlnaW5hbElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZE5leHRJbmRleCA9IChfYiA9IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLmdldChvcmlnaW5hbElkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwZWN0ZWROZXh0SW5kZXg7OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBvcmlnaW5hbElkICsgSW5uZ2VzdFN0ZXBUb29sc19qc18xLlNURVBfSU5ERVhJTkdfU1VGRklYICsgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnN0ZXBzLmhhcyhuZXdJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLnNldChvcmlnaW5hbElkLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcElkLmlkID0gbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCk7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWRJZCA9IGV4cG9ydHMuX2ludGVybmFscy5oYXNoSWQob3BJZC5pZCk7XG4gICAgICAgICAgICBjb25zdCBzdGVwU3RhdGUgPSB0aGlzLnN0YXRlLnN0ZXBTdGF0ZVtoYXNoZWRJZF07XG4gICAgICAgICAgICBsZXQgaXNGdWxmaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGVwU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGVwU3RhdGUuc2VlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5yZW1haW5pbmdTdGVwc1RvQmVTZWVuLmRlbGV0ZShoYXNoZWRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwU3RhdGUuaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGdWxmaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRyYU9wdHM7XG4gICAgICAgICAgICBsZXQgZm5BcmdzID0gWy4uLmFyZ3NdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoc3RlcFN0YXRlID09PSBudWxsIHx8IHN0ZXBTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RlcFN0YXRlLmlucHV0KSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoc3RlcFN0YXRlLmlucHV0KSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BJZC5vcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgc3RlcC5ydW4oKWAgaGFzIGl0cyBmdW5jdGlvbiBpbnB1dCBhZmZlY3RlZFxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZm5BcmdzID0gWy4uLmFyZ3Muc2xpY2UoMCwgMiksIC4uLnN0ZXBTdGF0ZS5pbnB1dF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYU9wdHMgPSB7IGlucHV0OiBbLi4uc3RlcFN0YXRlLmlucHV0XSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0ZXAuYWkuaW5mZXIoKWAgaGFzIGl0cyBib2R5IGFmZmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfanNfMS5TdGVwT3BDb2RlLkFpR2F0ZXdheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFPcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHR5cGVvZiAoKF9jID0gb3BJZC5vcHRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYm9keSkgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBvcElkLm9wdHMuYm9keSkgOiB7fSkpLCBzdGVwU3RhdGUuaW5wdXRbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3BJZCksIHsgb3B0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcElkLm9wdHMpLCBleHRyYU9wdHMpLCByYXdBcmdzOiBmbkFyZ3MsIC8vIFRPRE8gV2hhdCBpcyB0aGUgcmlnaHQgdmFsdWUgaGVyZT8gU2hvdWxkIHRoaXMgYmUgcmF3IGFyZ3Mgd2l0aG91dCBhZmZlY3RlZCBpbnB1dD9cbiAgICAgICAgICAgICAgICBoYXNoZWRJZCwgaW5wdXQ6IHN0ZXBTdGF0ZSA9PT0gbnVsbCB8fCBzdGVwU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0ZXBTdGF0ZS5pbnB1dCwgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBmbjogKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mbikgPyAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG9wdHMuZm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMsIC4uLmZuQXJncyk7IH0gOiB1bmRlZmluZWQsIHByb21pc2UsIGZ1bGZpbGxlZDogaXNGdWxmaWxsZWQsIGhhc1N0ZXBTdGF0ZTogQm9vbGVhbihzdGVwU3RhdGUpLCBkaXNwbGF5TmFtZTogKF9kID0gb3BJZC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3BJZC5pZCwgaGFuZGxlZDogZmFsc2UsIGhhbmRsZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcC5oYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RlcC5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVsZmlsbGVkICYmIHN0ZXBTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmZ1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc29tZSBleGVjdXRpb24gc2NlbmFyaW9zIHN1Y2ggYXMgdGVzdGluZywgYGRhdGFgLCBgZXJyb3JgLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGBpbnB1dGAgbWF5IGJlIGBQcm9taXNlc2AuIFRoaXMgY291bGQgYWxzbyBiZSB0aGUgY2FzZSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1dHVyZSBtaWRkbGV3YXJlIGFwcGxpY2F0aW9ucy4gRm9yIHRoaXMgcmVhc29uLCB3ZSdsbCBtYWtlIHN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgYXJlIGZ1bGx5IHJlc29sdmVkIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZS5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcFN0YXRlLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGVwU3RhdGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IgPSBuZXcgU3RlcEVycm9yX2pzXzEuU3RlcEVycm9yKG9wSWQuaWQsIHN0ZXBTdGF0ZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0ZXBzLnNldChvcElkLmlkLCBzdGVwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaGFzU3RlcHMgPSB0cnVlO1xuICAgICAgICAgICAgcHVzaFN0ZXBUb1JlcG9ydChzdGVwKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyB0aGUgbGFzdCBwaWVjZSBvZiBzdGF0ZSB3ZSBoYWQsIHdlJ3ZlIG5vdyBmaW5pc2hlZFxuICAgICAgICAgICAgICogbWVtb2l6aW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWJlZm9yZUV4ZWNIb29rc1Byb21pc2UgJiYgdGhpcy5zdGF0ZS5hbGxTdGF0ZVVzZWQoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IChiZWZvcmVFeGVjSG9va3NQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoMCwgSW5uZ2VzdFN0ZXBUb29sc19qc18xLmNyZWF0ZVN0ZXBUb29scykodGhpcy5vcHRpb25zLmNsaWVudCwgdGhpcywgc3RlcEhhbmRsZXIpO1xuICAgIH1cbiAgICBnZXRVc2VyRm5Ub1J1bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mbltcImZuXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl0pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29tZWhvdywgd2UndmUgZW5kZWQgdXAgZGV0ZWN0aW5nIHRoYXQgdGhpcyBpcyBhIGZhaWx1cmUgaGFuZGxlciBidXRcbiAgICAgICAgICAgICAqIGRvZXNuJ3QgaGF2ZSBhbiBgb25GYWlsdXJlYCBmdW5jdGlvbi4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmdW5jdGlvbiBgb25GYWlsdXJlYCBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVRpbWVyKHN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXQgPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVUaW1lb3V0UHJvbWlzZSkodGhpcy50aW1lb3V0RHVyYXRpb24pO1xuICAgICAgICB2b2lkIHRoaXMudGltZW91dC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9mID0gKF9lID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSkpO1xuICAgICAgICAgICAgc3RhdGUuc2V0Q2hlY2twb2ludCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLW5vdC1mb3VuZFwiLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwLFxuICAgICAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBOb3RGb3VuZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZSgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5vcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uRnVuY3Rpb25SdW5cIiwge1xuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgcmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3MsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYuY3R4KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LmN0eCksXG4gICAgICAgICAgICAgICAgICAgIGZuOiB0aGlzLm9wdGlvbnMuZm4sXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBwcmV2LnN0ZXBzLm1hcCgoc3RlcCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXApLCAoX2EgPSBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuc3RlcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVxQXJnczogcHJldi5yZXFBcmdzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYucmVzdWx0KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHByZXYuc3RlcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBob29rcztcbiAgICB9XG59XG5jb25zdCBoYXNoSWQgPSAoaWQpID0+IHtcbiAgICByZXR1cm4gKDAsIGhhc2hfanNfMS5zaGExKSgpLnVwZGF0ZShpZCkuZGlnZXN0KFwiaGV4XCIpO1xufTtcbmNvbnN0IGhhc2hPcCA9IChvcCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wKSwgeyBpZDogaGFzaElkKG9wLmlkKSB9KTtcbn07XG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nLlxuICovXG5leHBvcnRzLl9pbnRlcm5hbHMgPSB7IGhhc2hPcCwgaGFzaElkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12MS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v2.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v2.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.createV2InngestExecution = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst StepError_js_1 = __webpack_require__(/*! ../StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst als_js_1 = __webpack_require__(/*! ./als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst access_js_1 = __webpack_require__(/*! ./otel/access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst createV2InngestExecution = (options) => {\n    return new V2InngestExecution(options);\n};\nexports.createV2InngestExecution = createV2InngestExecution;\nclass V2InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.timeoutDuration = 1000 * 10;\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n        this.checkpointHandlers = this.createCheckpointHandlers();\n        this.initializeTimer(this.state);\n        this.debug(\"created new V2 execution for run;\", this.options.requestedRunStep\n            ? `wanting to run step \"${this.options.requestedRunStep}\"`\n            : \"discovering steps\");\n        this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n    }\n    /**\n     * Idempotently start the execution of the user's function.\n     */\n    start() {\n        if (!this.execution) {\n            this.debug(\"starting V2 execution\");\n            const tracer = api_1.trace.getTracer(\"inngest\", version_js_1.version);\n            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als) => {\n                return als.run({ app: this.options.client, ctx: this.fnArg }, async () => {\n                    return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n                        var _a;\n                        (_a = access_js_1.clientProcessorMap.get(this.options.client)) === null || _a === void 0 ? void 0 : _a.declareStartingSpan({\n                            span,\n                            runId: this.options.runId,\n                            traceparent: this.options.headers[consts_js_1.headerKeys.TraceParent],\n                            tracestate: this.options.headers[consts_js_1.headerKeys.TraceState],\n                        });\n                        return this._start()\n                            .then((result) => {\n                            this.debug(\"result:\", result);\n                            return result;\n                        })\n                            .finally(() => {\n                            span.end();\n                        });\n                    });\n                });\n            });\n        }\n        return this.execution;\n    }\n    /**\n     * Starts execution of the user's function and the core loop.\n     */\n    async _start() {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        try {\n            const allCheckpointHandler = this.getCheckpointHandler(\"\");\n            this.state.hooks = await this.initializeMiddleware();\n            await this.startExecution();\n            try {\n                for (var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                    _c = _h.value;\n                    _f = false;\n                    const checkpoint = _c;\n                    await allCheckpointHandler(checkpoint);\n                    const handler = this.getCheckpointHandler(checkpoint.type);\n                    const result = await handler(checkpoint);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            void this.state.loop.return();\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));\n        }\n        /**\n         * If we're here, the generator somehow finished without returning a value.\n         * This should never happen.\n         */\n        throw new Error(\"Core loop finished without returning a value\");\n    }\n    /**\n     * Creates a handler for every checkpoint type, defining what to do when we\n     * reach that checkpoint in the core loop.\n     */\n    createCheckpointHandlers() {\n        return {\n            /**\n             * Run for all checkpoints. Best used for logging or common actions.\n             * Use other handlers to return values and interrupt the core loop.\n             */\n            \"\": (checkpoint) => {\n                this.debug(\"checkpoint:\", checkpoint);\n            },\n            /**\n             * The user's function has completed and returned a value.\n             */\n            \"function-resolved\": async (checkpoint) => {\n                return await this.transformOutput({ data: checkpoint.data });\n            },\n            /**\n             * The user's function has thrown an error.\n             */\n            \"function-rejected\": async (checkpoint) => {\n                return await this.transformOutput({ error: checkpoint.error });\n            },\n            /**\n             * We've found one or more steps. Here we may want to run a step or report\n             * them back to Inngest.\n             */\n            \"steps-found\": async ({ steps }) => {\n                const stepResult = await this.tryExecuteStep(steps);\n                if (stepResult) {\n                    const transformResult = await this.transformOutput(stepResult);\n                    /**\n                     * Transforming output will always return either function rejection or\n                     * resolution. In most cases, this can be immediately returned, but in\n                     * this particular case we want to handle it differently.\n                     */\n                    if (transformResult.type === \"function-resolved\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { data: transformResult.data })),\n                        };\n                    }\n                    else if (transformResult.type === \"function-rejected\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { error: transformResult.error })),\n                            retriable: transformResult.retriable,\n                        };\n                    }\n                    return transformResult;\n                }\n                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));\n                if (newSteps) {\n                    return {\n                        type: \"steps-found\",\n                        ctx: this.fnArg,\n                        ops: this.ops,\n                        steps: newSteps,\n                    };\n                }\n            },\n            /**\n             * While trying to find a step that Inngest has told us to run, we've\n             * timed out or have otherwise decided that it doesn't exist.\n             */\n            \"step-not-found\": ({ step }) => {\n                return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n            },\n        };\n    }\n    getCheckpointHandler(type) {\n        return this.checkpointHandlers[type];\n    }\n    async tryExecuteStep(steps) {\n        var _a;\n        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n        if (!hashedStepIdToRun) {\n            return;\n        }\n        const step = steps.find((step) => step.hashedId === hashedStepIdToRun && step.fn);\n        if (step) {\n            return await this.executeStep(step);\n        }\n        /**\n         * Ensure we reset the timeout if we have a requested run step but couldn't\n         * find it, but also that we don't reset if we found and executed it.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());\n    }\n    /**\n     * Given a list of outgoing ops, decide if we can execute an op early and\n     * return the ID of the step to execute if we can.\n     */\n    getEarlyExecRunStep(steps) {\n        /**\n         * We may have been disabled due to parallelism, in which case we can't\n         * immediately execute unless explicitly requested.\n         */\n        if (this.options.disableImmediateExecution)\n            return;\n        const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n        if (unfulfilledSteps.length !== 1)\n            return;\n        const op = unfulfilledSteps[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.hashedId;\n        }\n    }\n    async filterNewSteps(foundSteps) {\n        var _a, _b, _c, _d, _e, _f;\n        if (this.options.requestedRunStep) {\n            return;\n        }\n        /**\n         * Gather any steps that aren't memoized and report them.\n         */\n        const newSteps = foundSteps.filter((step) => !step.fulfilled);\n        if (!newSteps.length) {\n            return;\n        }\n        /**\n         * Warn if we've found new steps but haven't yet seen all previous\n         * steps. This may indicate that step presence isn't determinate.\n         */\n        let knownSteps = 0;\n        for (const step of foundSteps) {\n            if (step.fulfilled) {\n                knownSteps++;\n            }\n        }\n        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n        if (!foundAllCompletedSteps) {\n            // TODO Tag\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"Function may be indeterminate\",\n                why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n                consequences: \"This may cause unexpected behaviour as Inngest executes your function.\",\n                reassurance: \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n            }));\n        }\n        /**\n         * We're finishing up; let's trigger the last of the hooks.\n         */\n        await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        const stepList = newSteps.map((step) => ({\n            displayName: step.displayName,\n            op: step.op,\n            id: step.hashedId,\n            name: step.name,\n            opts: step.opts,\n        }));\n        /**\n         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n         * to ensure that their `data` is transformed correctly.\n         */\n        return await this.transformNewSteps(stepList);\n    }\n    /**\n     * Using middleware, transform any newly-found steps before returning them to\n     * an Inngest Server.\n     */\n    async transformNewSteps(steps) {\n        return Promise.all(steps.map(async (step) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {\n                return step;\n            }\n            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onSendEvent\", undefined, {\n                transformInput: (prev, output) => {\n                    return Object.assign(Object.assign({}, prev), output);\n                },\n                transformOutput: (prev, output) => {\n                    return {\n                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    };\n                },\n            });\n            /**\n             * For each event being sent, create a new `onSendEvent` hook stack to\n             * process it. We do this as middleware hooks are intended to run once\n             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n             * is run for every single event.\n             *\n             * This is done because a developer can use this hook to filter out\n             * events entirely; if we batch all of the events together, we can't\n             * tell which ones were filtered out if we're processing >1 invocation\n             * here.\n             */\n            const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {\n                payloads: [\n                    Object.assign(Object.assign({}, ((_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {})), { name: consts_js_1.internalEvents.FunctionInvoked }),\n                ],\n            }));\n            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});\n            return Object.assign(Object.assign({}, step), { opts: Object.assign(Object.assign({}, step.opts), { payload: Object.assign(Object.assign({}, ((_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {})), newPayload) }) });\n        }));\n    }\n    async executeStep({ id, name, opts, fn, displayName, }) {\n        var _a, _b, _c, _d, _e;\n        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));\n        const outgoingOp = {\n            id,\n            op: types_js_1.StepOpCode.StepRun,\n            name,\n            opts,\n            displayName,\n        };\n        this.state.executingStep = outgoingOp;\n        const store = await (0, als_js_1.getAsyncCtx)();\n        if (store) {\n            store.executingStep = {\n                id,\n                name: displayName,\n            };\n        }\n        this.debug(`executing step \"${id}\"`);\n        return ((0, promises_js_1.runAsPromise)(fn)\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b;\n            if (store) {\n                delete store.executingStep;\n            }\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n        })\n            .then((data) => {\n            return Object.assign(Object.assign({}, outgoingOp), { data });\n        })\n            .catch((error) => {\n            return Object.assign(Object.assign({}, outgoingOp), { op: types_js_1.StepOpCode.StepError, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error });\n        }));\n    }\n    /**\n     * Starts execution of the user's function, including triggering checkpoints\n     * and middleware hooks where appropriate.\n     */\n    async startExecution() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        /**\n         * Mutate input as neccessary based on middleware.\n         */\n        await this.transformInput();\n        /**\n         * Start the timer to time out the run if needed.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        /**\n         * If we had no state to begin with, immediately end the memoization phase.\n         */\n        if (this.state.allStateUsed()) {\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));\n            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));\n        }\n        /**\n         * Trigger the user's function.\n         */\n        (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg))\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        })\n            .then((data) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-resolved\", data });\n        })\n            .catch((error) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-rejected\", error });\n        });\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.state.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        /**\n         * If we've been given an error and it's one that we just threw from a step,\n         * we should return a `NonRetriableError` to stop execution.\n         */\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const isStepExecution = Boolean(this.state.executingStep);\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step: this.state.executingStep,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!isStepExecution) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n    createExecutionState() {\n        const d = (0, promises_js_1.createDeferredPromiseWithStack)();\n        let checkpointResolve = d.deferred.resolve;\n        const checkpointResults = d.results;\n        const loop = (function (cleanUp) {\n            return __asyncGenerator(this, arguments, function* () {\n                try {\n                    while (true) {\n                        const res = (yield __await(checkpointResults.next())).value;\n                        if (res) {\n                            yield yield __await(res);\n                        }\n                    }\n                }\n                finally {\n                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();\n                }\n            });\n        })(() => {\n            var _a;\n            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n            void checkpointResults.return();\n        });\n        const stepsToFulfill = Object.keys(this.options.stepState).length;\n        const state = {\n            stepState: this.options.stepState,\n            stepsToFulfill,\n            steps: new Map(),\n            loop,\n            hasSteps: Boolean(stepsToFulfill),\n            stepCompletionOrder: [...this.options.stepCompletionOrder],\n            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n            setCheckpoint: (checkpoint) => {\n                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n            },\n            allStateUsed: () => {\n                return this.state.remainingStepsToBeSeen.size === 0;\n            },\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(this.state.steps);\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        const step = this.createStepTools();\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        /**\n         * Handle use of the `onFailure` option by deserializing the error.\n         */\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    createStepTools() {\n        /**\n         * A list of steps that have been found and are being rolled up before being\n         * reported to the core loop.\n         */\n        const foundStepsToReport = new Map();\n        /**\n         * A map of the subset of found steps to report that have not yet been\n         * handled. Used for fast access to steps that need to be handled in order.\n         */\n        const unhandledFoundStepsToReport = new Map();\n        /**\n         * A map of the latest sequential step indexes found for each step ID. Used\n         * to ensure that we don't index steps in parallel.\n         *\n         * Note that these must be sequential; if we've seen or assigned `a:1`,\n         * `a:2` and `a:4`, the latest sequential step index is `2`.\n         *\n         */\n        const expectedNextStepIndexes = new Map();\n        /**\n         * A promise that's used to ensure that step reporting cannot be run more than\n         * once in a given asynchronous time span.\n         */\n        let foundStepsReportPromise;\n        /**\n         * A promise that's used to represent middleware hooks running before\n         * execution.\n         */\n        let beforeExecHooksPromise;\n        /**\n         * A helper used to report steps to the core loop. Used after adding an item\n         * to `foundStepsToReport`.\n         */\n        const reportNextTick = () => {\n            // Being explicit instead of using `??=` to appease TypeScript.\n            if (foundStepsReportPromise) {\n                return;\n            }\n            foundStepsReportPromise = new Promise((resolve) => setImmediate(resolve))\n                /**\n                 * Ensure that we wait for this promise to resolve before continuing.\n                 *\n                 * The groups in which steps are reported can affect how we detect some\n                 * more complex determinism issues like parallel indexing. This promise\n                 * can represent middleware hooks being run early, in the middle of\n                 * ingesting steps to report.\n                 *\n                 * Because of this, it's important we wait for this middleware to resolve\n                 * before continuing to report steps to ensure that all steps have a\n                 * chance to be reported throughout this asynchronous action.\n                 */\n                .then(() => beforeExecHooksPromise)\n                .then(() => {\n                foundStepsReportPromise = undefined;\n                for (const [hashedId, step] of unhandledFoundStepsToReport) {\n                    if (step.handle()) {\n                        unhandledFoundStepsToReport.delete(hashedId);\n                        if (step.fulfilled) {\n                            foundStepsToReport.delete(step.id);\n                        }\n                    }\n                }\n                if (foundStepsToReport.size) {\n                    const steps = [...foundStepsToReport.values()];\n                    foundStepsToReport.clear();\n                    return void this.state.setCheckpoint({\n                        type: \"steps-found\",\n                        steps: steps,\n                    });\n                }\n            });\n        };\n        /**\n         * A helper used to push a step to the list of steps to report.\n         */\n        const pushStepToReport = (step) => {\n            foundStepsToReport.set(step.id, step);\n            unhandledFoundStepsToReport.set(step.hashedId, step);\n            reportNextTick();\n        };\n        const stepHandler = async ({ args, matchOp, opts, }) => {\n            var _a, _b, _c, _d;\n            await beforeExecHooksPromise;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = matchOp(stepOptions, ...args.slice(1));\n            if (this.state.executingStep) {\n                /**\n                 * If a step is found after asynchronous actions during another step's\n                 * execution, everything is fine. The problem here is if we've found\n                 * that a step nested inside another a step, which is something we don't\n                 * support at the time of writing.\n                 *\n                 * In this case, we could use something like Async Hooks to understand\n                 * how the step is being triggered, though this isn't available in all\n                 * environments.\n                 *\n                 * Therefore, we'll only show a warning here to indicate that this is\n                 * potentially an issue.\n                 */\n                console.warn((0, errors_js_1.prettyError)({\n                    whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\\``,\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    type: \"warn\",\n                    reassurance: \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            if (this.state.steps.has(opId.id)) {\n                const originalId = opId.id;\n                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;\n                for (let i = expectedNextIndex;; i++) {\n                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;\n                    if (!this.state.steps.has(newId)) {\n                        expectedNextStepIndexes.set(originalId, i + 1);\n                        opId.id = newId;\n                        break;\n                    }\n                }\n            }\n            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();\n            const hashedId = exports._internals.hashId(opId.id);\n            const stepState = this.state.stepState[hashedId];\n            let isFulfilled = false;\n            if (stepState) {\n                stepState.seen = true;\n                this.state.remainingStepsToBeSeen.delete(hashedId);\n                if (typeof stepState.input === \"undefined\") {\n                    isFulfilled = true;\n                }\n            }\n            let extraOpts;\n            let fnArgs = [...args];\n            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== \"undefined\" &&\n                Array.isArray(stepState.input)) {\n                switch (opId.op) {\n                    // `step.run()` has its function input affected\n                    case types_js_1.StepOpCode.StepPlanned: {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        fnArgs = [...args.slice(0, 2), ...stepState.input];\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        extraOpts = { input: [...stepState.input] };\n                        break;\n                    }\n                    // `step.ai.infer()` has its body affected\n                    case types_js_1.StepOpCode.AiGateway: {\n                        extraOpts = {\n                            body: Object.assign(Object.assign({}, (typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === \"object\"\n                                ? Object.assign({}, opId.opts.body) : {})), stepState.input[0]),\n                        };\n                        break;\n                    }\n                }\n            }\n            const step = Object.assign(Object.assign({}, opId), { opts: Object.assign(Object.assign({}, opId.opts), extraOpts), rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n                hashedId, input: stepState === null || stepState === void 0 ? void 0 : stepState.input, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs); } : undefined, promise, fulfilled: isFulfilled, hasStepState: Boolean(stepState), displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id, handled: false, handle: () => {\n                    if (step.handled) {\n                        return false;\n                    }\n                    step.handled = true;\n                    if (isFulfilled && stepState) {\n                        stepState.fulfilled = true;\n                        // For some execution scenarios such as testing, `data`, `error`,\n                        // and `input` may be `Promises`. This could also be the case for\n                        // future middleware applications. For this reason, we'll make sure\n                        // the values are fully resolved before continuing.\n                        void Promise.all([\n                            stepState.data,\n                            stepState.error,\n                            stepState.input,\n                        ]).then(() => {\n                            if (typeof stepState.data !== \"undefined\") {\n                                resolve(stepState.data);\n                            }\n                            else {\n                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);\n                                reject(this.state.recentlyRejectedStepError);\n                            }\n                        });\n                    }\n                    return true;\n                } });\n            this.state.steps.set(opId.id, step);\n            this.state.hasSteps = true;\n            pushStepToReport(step);\n            /**\n             * If this is the last piece of state we had, we've now finished\n             * memoizing.\n             */\n            if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n                await (beforeExecHooksPromise = (async () => {\n                    var _a, _b, _c, _d;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n                })());\n            }\n            return promise;\n        };\n        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        return this.options.fn[\"onFailureFn\"];\n    }\n    initializeTimer(state) {\n        if (!this.options.requestedRunStep) {\n            return;\n        }\n        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);\n        void this.timeout.then(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            state.setCheckpoint({\n                type: \"step-not-found\",\n                step: {\n                    id: this.options.requestedRunStep,\n                    op: types_js_1.StepOpCode.StepNotFound,\n                },\n            });\n        });\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n}\nconst hashId = (id) => {\n    return (0, hash_js_1.sha1)().update(id).digest(\"hex\");\n};\nconst hashOp = (op) => {\n    return Object.assign(Object.assign({}, op), { id: hashId(op.id) });\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashOp, hashId };\n//# sourceMappingURL=v2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0NBQWdDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsaUVBQWtCO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLDZGQUF5QjtBQUNoRSw4QkFBOEIsbUJBQU8sQ0FBQywyRkFBd0I7QUFDOUQsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDZCQUE2QixtQkFBTyxDQUFDLHlGQUF1QjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDaEQsOEJBQThCLG1CQUFPLENBQUMsb0dBQXVCO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLDBFQUFVO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlDQUF5QztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1QkFBdUI7QUFDM0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixpQkFBaUIsNEJBQTRCO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGlCQUFpQiw4QkFBOEI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw4R0FBOEcsTUFBTSxrREFBa0Q7QUFDeE47QUFDQSxhQUFhO0FBQ2IsK1FBQStRO0FBQy9RLGlEQUFpRCxXQUFXLG9DQUFvQyxnQkFBZ0IsdUNBQXVDLDhHQUE4RyxpQkFBaUIsR0FBRztBQUN6UixTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlEQUFpRCxpQkFBaUIsTUFBTTtBQUN4RSxTQUFTO0FBQ1Q7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0EsdUJBQXVCO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1QyxpQ0FBaUM7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsY0FBYyxnQ0FBZ0M7QUFDOUQ7QUFDQTtBQUNBLHdDQUF3QyxvQ0FBb0MsUUFBUSxJQUFJLE1BQU07QUFDOUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0IsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBLGtEQUFrRCxZQUFZLDJEQUEyRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGlFQUFpRTtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXLG9DQUFvQztBQUN0RztBQUNBO0FBQ0Esb0ZBQW9GLFFBQVEsdUZBQXVGO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTLG1CQUFtQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL3YyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXN5bmNWYWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNHZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLl9pbnRlcm5hbHMgPSBleHBvcnRzLmNyZWF0ZVYySW5uZ2VzdEV4ZWN1dGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCJoYXNoLmpzXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9jb25zdHMuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGZ1bmN0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvZnVuY3Rpb25zLmpzXCIpO1xuY29uc3QgcHJvbWlzZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VzLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlcy5qc1wiKTtcbmNvbnN0IHZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuLi8uLi92ZXJzaW9uLmpzXCIpO1xuY29uc3QgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9Jbm5nZXN0TWlkZGxld2FyZS5qc1wiKTtcbmNvbnN0IElubmdlc3RTdGVwVG9vbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9Jbm5nZXN0U3RlcFRvb2xzLmpzXCIpO1xuY29uc3QgTm9uUmV0cmlhYmxlRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9Ob25SZXRyaWFibGVFcnJvci5qc1wiKTtcbmNvbnN0IFJldHJ5QWZ0ZXJFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL1JldHJ5QWZ0ZXJFcnJvci5qc1wiKTtcbmNvbnN0IFN0ZXBFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL1N0ZXBFcnJvci5qc1wiKTtcbmNvbnN0IElubmdlc3RFeGVjdXRpb25fanNfMSA9IHJlcXVpcmUoXCIuL0lubmdlc3RFeGVjdXRpb24uanNcIik7XG5jb25zdCBhbHNfanNfMSA9IHJlcXVpcmUoXCIuL2Fscy5qc1wiKTtcbmNvbnN0IGFjY2Vzc19qc18xID0gcmVxdWlyZShcIi4vb3RlbC9hY2Nlc3MuanNcIik7XG5jb25zdCBjcmVhdGVWMklubmdlc3RFeGVjdXRpb24gPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBuZXcgVjJJbm5nZXN0RXhlY3V0aW9uKG9wdGlvbnMpO1xufTtcbmV4cG9ydHMuY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uID0gY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uO1xuY2xhc3MgVjJJbm5nZXN0RXhlY3V0aW9uIGV4dGVuZHMgSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLklubmdlc3RFeGVjdXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGltZW91dER1cmF0aW9uID0gMTAwMCAqIDEwO1xuICAgICAgICB0aGlzLnVzZXJGblRvUnVuID0gdGhpcy5nZXRVc2VyRm5Ub1J1bigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jcmVhdGVFeGVjdXRpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLmZuQXJnID0gdGhpcy5jcmVhdGVGbkFyZygpO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRIYW5kbGVycyA9IHRoaXMuY3JlYXRlQ2hlY2twb2ludEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRpbWVyKHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlYnVnKFwiY3JlYXRlZCBuZXcgVjIgZXhlY3V0aW9uIGZvciBydW47XCIsIHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwXG4gICAgICAgICAgICA/IGB3YW50aW5nIHRvIHJ1biBzdGVwIFwiJHt0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcH1cImBcbiAgICAgICAgICAgIDogXCJkaXNjb3ZlcmluZyBzdGVwc1wiKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImV4aXN0aW5nIHN0YXRlIGtleXM6XCIsIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuc3RlcFN0YXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElkZW1wb3RlbnRseSBzdGFydCB0aGUgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5leGVjdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJzdGFydGluZyBWMiBleGVjdXRpb25cIik7XG4gICAgICAgICAgICBjb25zdCB0cmFjZXIgPSBhcGlfMS50cmFjZS5nZXRUcmFjZXIoXCJpbm5nZXN0XCIsIHZlcnNpb25fanNfMS52ZXJzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uID0gKDAsIGFsc19qc18xLmdldEFzeW5jTG9jYWxTdG9yYWdlKSgpLnRoZW4oKGFscykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHMucnVuKHsgYXBwOiB0aGlzLm9wdGlvbnMuY2xpZW50LCBjdHg6IHRoaXMuZm5BcmcgfSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihcImlubmdlc3QuZXhlY3V0aW9uXCIsIChzcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBhY2Nlc3NfanNfMS5jbGllbnRQcm9jZXNzb3JNYXAuZ2V0KHRoaXMub3B0aW9ucy5jbGllbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjbGFyZVN0YXJ0aW5nU3Bhbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5JZDogdGhpcy5vcHRpb25zLnJ1bklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlcGFyZW50OiB0aGlzLm9wdGlvbnMuaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlRyYWNlUGFyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXN0YXRlOiB0aGlzLm9wdGlvbnMuaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlRyYWNlU3RhdGVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwicmVzdWx0OlwiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24gYW5kIHRoZSBjb3JlIGxvb3AuXG4gICAgICovXG4gICAgYXN5bmMgX3N0YXJ0KCkge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWxsQ2hlY2twb2ludEhhbmRsZXIgPSB0aGlzLmdldENoZWNrcG9pbnRIYW5kbGVyKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ob29rcyA9IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZU1pZGRsZXdhcmUoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhcnRFeGVjdXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXModGhpcy5zdGF0ZS5sb29wKSwgX2g7IF9oID0gYXdhaXQgX2cubmV4dCgpLCBfYSA9IF9oLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWxsQ2hlY2twb2ludEhhbmRsZXIoY2hlY2twb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmdldENoZWNrcG9pbnRIYW5kbGVyKGNoZWNrcG9pbnQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoY2hlY2twb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gX2cucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLnN0YXRlLmxvb3AucmV0dXJuKCk7XG4gICAgICAgICAgICBhd2FpdCAoKF9lID0gKF9kID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmJlZm9yZVJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBoZXJlLCB0aGUgZ2VuZXJhdG9yIHNvbWVob3cgZmluaXNoZWQgd2l0aG91dCByZXR1cm5pbmcgYSB2YWx1ZS5cbiAgICAgICAgICogVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29yZSBsb29wIGZpbmlzaGVkIHdpdGhvdXQgcmV0dXJuaW5nIGEgdmFsdWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYW5kbGVyIGZvciBldmVyeSBjaGVja3BvaW50IHR5cGUsIGRlZmluaW5nIHdoYXQgdG8gZG8gd2hlbiB3ZVxuICAgICAqIHJlYWNoIHRoYXQgY2hlY2twb2ludCBpbiB0aGUgY29yZSBsb29wLlxuICAgICAqL1xuICAgIGNyZWF0ZUNoZWNrcG9pbnRIYW5kbGVycygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUnVuIGZvciBhbGwgY2hlY2twb2ludHMuIEJlc3QgdXNlZCBmb3IgbG9nZ2luZyBvciBjb21tb24gYWN0aW9ucy5cbiAgICAgICAgICAgICAqIFVzZSBvdGhlciBoYW5kbGVycyB0byByZXR1cm4gdmFsdWVzIGFuZCBpbnRlcnJ1cHQgdGhlIGNvcmUgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJcIjogKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiY2hlY2twb2ludDpcIiwgY2hlY2twb2ludCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdXNlcidzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQgYW5kIHJldHVybmVkIGEgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZnVuY3Rpb24tcmVzb2x2ZWRcIjogYXN5bmMgKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBkYXRhOiBjaGVja3BvaW50LmRhdGEgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdXNlcidzIGZ1bmN0aW9uIGhhcyB0aHJvd24gYW4gZXJyb3IuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZnVuY3Rpb24tcmVqZWN0ZWRcIjogYXN5bmMgKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvcjogY2hlY2twb2ludC5lcnJvciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlJ3ZlIGZvdW5kIG9uZSBvciBtb3JlIHN0ZXBzLiBIZXJlIHdlIG1heSB3YW50IHRvIHJ1biBhIHN0ZXAgb3IgcmVwb3J0XG4gICAgICAgICAgICAgKiB0aGVtIGJhY2sgdG8gSW5uZ2VzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzdGVwcy1mb3VuZFwiOiBhc3luYyAoeyBzdGVwcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5RXhlY3V0ZVN0ZXAoc3RlcHMpO1xuICAgICAgICAgICAgICAgIGlmIChzdGVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdCA9IGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHN0ZXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVHJhbnNmb3JtaW5nIG91dHB1dCB3aWxsIGFsd2F5cyByZXR1cm4gZWl0aGVyIGZ1bmN0aW9uIHJlamVjdGlvbiBvclxuICAgICAgICAgICAgICAgICAgICAgKiByZXNvbHV0aW9uLiBJbiBtb3N0IGNhc2VzLCB0aGlzIGNhbiBiZSBpbW1lZGlhdGVseSByZXR1cm5lZCwgYnV0IGluXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgcGFydGljdWxhciBjYXNlIHdlIHdhbnQgdG8gaGFuZGxlIGl0IGRpZmZlcmVudGx5LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVJlc3VsdC50eXBlID09PSBcImZ1bmN0aW9uLXJlc29sdmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLXJhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogdHJhbnNmb3JtUmVzdWx0LmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHM6IHRyYW5zZm9ybVJlc3VsdC5vcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hPcChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXBSZXN1bHQpLCB7IGRhdGE6IHRyYW5zZm9ybVJlc3VsdC5kYXRhIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtUmVzdWx0LnR5cGUgPT09IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtcmFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiB0cmFuc2Zvcm1SZXN1bHQuY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wczogdHJhbnNmb3JtUmVzdWx0Lm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBleHBvcnRzLl9pbnRlcm5hbHMuaGFzaE9wKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcFJlc3VsdCksIHsgZXJyb3I6IHRyYW5zZm9ybVJlc3VsdC5lcnJvciB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlhYmxlOiB0cmFuc2Zvcm1SZXN1bHQucmV0cmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTdGVwcyA9IGF3YWl0IHRoaXMuZmlsdGVyTmV3U3RlcHMoQXJyYXkuZnJvbSh0aGlzLnN0YXRlLnN0ZXBzLnZhbHVlcygpKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXBzLWZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcHM6IG5ld1N0ZXBzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoaWxlIHRyeWluZyB0byBmaW5kIGEgc3RlcCB0aGF0IElubmdlc3QgaGFzIHRvbGQgdXMgdG8gcnVuLCB3ZSd2ZVxuICAgICAgICAgICAgICogdGltZWQgb3V0IG9yIGhhdmUgb3RoZXJ3aXNlIGRlY2lkZWQgdGhhdCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInN0ZXAtbm90LWZvdW5kXCI6ICh7IHN0ZXAgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcC1ub3QtZm91bmRcIiwgY3R4OiB0aGlzLmZuQXJnLCBvcHM6IHRoaXMub3BzLCBzdGVwIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDaGVja3BvaW50SGFuZGxlcih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrcG9pbnRIYW5kbGVyc1t0eXBlXTtcbiAgICB9XG4gICAgYXN5bmMgdHJ5RXhlY3V0ZVN0ZXAoc3RlcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBoYXNoZWRTdGVwSWRUb1J1biA9IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwIHx8IHRoaXMuZ2V0RWFybHlFeGVjUnVuU3RlcChzdGVwcyk7XG4gICAgICAgIGlmICghaGFzaGVkU3RlcElkVG9SdW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGVwID0gc3RlcHMuZmluZCgoc3RlcCkgPT4gc3RlcC5oYXNoZWRJZCA9PT0gaGFzaGVkU3RlcElkVG9SdW4gJiYgc3RlcC5mbik7XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRlU3RlcChzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5zdXJlIHdlIHJlc2V0IHRoZSB0aW1lb3V0IGlmIHdlIGhhdmUgYSByZXF1ZXN0ZWQgcnVuIHN0ZXAgYnV0IGNvdWxkbid0XG4gICAgICAgICAqIGZpbmQgaXQsIGJ1dCBhbHNvIHRoYXQgd2UgZG9uJ3QgcmVzZXQgaWYgd2UgZm91bmQgYW5kIGV4ZWN1dGVkIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgdm9pZCAoKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBvdXRnb2luZyBvcHMsIGRlY2lkZSBpZiB3ZSBjYW4gZXhlY3V0ZSBhbiBvcCBlYXJseSBhbmRcbiAgICAgKiByZXR1cm4gdGhlIElEIG9mIHRoZSBzdGVwIHRvIGV4ZWN1dGUgaWYgd2UgY2FuLlxuICAgICAqL1xuICAgIGdldEVhcmx5RXhlY1J1blN0ZXAoc3RlcHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIG1heSBoYXZlIGJlZW4gZGlzYWJsZWQgZHVlIHRvIHBhcmFsbGVsaXNtLCBpbiB3aGljaCBjYXNlIHdlIGNhbid0XG4gICAgICAgICAqIGltbWVkaWF0ZWx5IGV4ZWN1dGUgdW5sZXNzIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlSW1tZWRpYXRlRXhlY3V0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB1bmZ1bGZpbGxlZFN0ZXBzID0gc3RlcHMuZmlsdGVyKChzdGVwKSA9PiAhc3RlcC5mdWxmaWxsZWQpO1xuICAgICAgICBpZiAodW5mdWxmaWxsZWRTdGVwcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9wID0gdW5mdWxmaWxsZWRTdGVwc1swXTtcbiAgICAgICAgaWYgKG9wICYmXG4gICAgICAgICAgICBvcC5vcCA9PT0gdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkXG4gICAgICAgIC8vIFRPRE8gV2UgbXVzdCBpbmRpdmlkdWFsbHkgY2hlY2sgcHJvcGVydGllcyBoZXJlIHRoYXQgd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgICAgLy8gZXhlY3V0ZSBvbiwgc3VjaCBhcyByZXRyeSBjb3VudHMuIE5vdGhpbmcgZXhpc3RzIGhlcmUgdGhhdCBmYWxscyBpbiB0b1xuICAgICAgICAvLyB0aGlzIGNhc2UsIGJ1dCBzaG91bGQgYmUgYWNjb3VudGVkIGZvciB3aGVuIHdlIGFkZCB0aGVtLlxuICAgICAgICAvLyAmJiB0eXBlb2Ygb3Aub3B0cyA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBvcC5oYXNoZWRJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmaWx0ZXJOZXdTdGVwcyhmb3VuZFN0ZXBzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2F0aGVyIGFueSBzdGVwcyB0aGF0IGFyZW4ndCBtZW1vaXplZCBhbmQgcmVwb3J0IHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBuZXdTdGVwcyA9IGZvdW5kU3RlcHMuZmlsdGVyKChzdGVwKSA9PiAhc3RlcC5mdWxmaWxsZWQpO1xuICAgICAgICBpZiAoIW5ld1N0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYXJuIGlmIHdlJ3ZlIGZvdW5kIG5ldyBzdGVwcyBidXQgaGF2ZW4ndCB5ZXQgc2VlbiBhbGwgcHJldmlvdXNcbiAgICAgICAgICogc3RlcHMuIFRoaXMgbWF5IGluZGljYXRlIHRoYXQgc3RlcCBwcmVzZW5jZSBpc24ndCBkZXRlcm1pbmF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBrbm93blN0ZXBzID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIGZvdW5kU3RlcHMpIHtcbiAgICAgICAgICAgIGlmIChzdGVwLmZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgIGtub3duU3RlcHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3VuZEFsbENvbXBsZXRlZFN0ZXBzID0gdGhpcy5zdGF0ZS5zdGVwc1RvRnVsZmlsbCA9PT0ga25vd25TdGVwcztcbiAgICAgICAgaWYgKCFmb3VuZEFsbENvbXBsZXRlZFN0ZXBzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFRhZ1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwid2FyblwiLFxuICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJGdW5jdGlvbiBtYXkgYmUgaW5kZXRlcm1pbmF0ZVwiLFxuICAgICAgICAgICAgICAgIHdoeTogXCJXZSBmb3VuZCBuZXcgc3RlcHMgYmVmb3JlIHNlZWluZyBhbGwgcHJldmlvdXMgc3RlcHMsIHdoaWNoIG1heSBpbmRpY2F0ZSB0aGF0IHRoZSBmdW5jdGlvbiBpcyBub24tZGV0ZXJtaW5pc3RpYy5cIixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiVGhpcyBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIgYXMgSW5uZ2VzdCBleGVjdXRlcyB5b3VyIGZ1bmN0aW9uLlwiLFxuICAgICAgICAgICAgICAgIHJlYXNzdXJhbmNlOiBcIlRoaXMgaXMgZXhwZWN0ZWQgaWYgYSBmdW5jdGlvbiBpcyB1cGRhdGVkIGluIHRoZSBtaWRkbGUgb2YgYSBydW4sIGJ1dCBtYXkgaW5kaWNhdGUgYSBidWcgaWYgbm90LlwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSdyZSBmaW5pc2hpbmcgdXA7IGxldCdzIHRyaWdnZXIgdGhlIGxhc3Qgb2YgdGhlIGhvb2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpKTtcbiAgICAgICAgYXdhaXQgKChfZiA9IChfZSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgY29uc3Qgc3RlcExpc3QgPSBuZXdTdGVwcy5tYXAoKHN0ZXApID0+ICh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogc3RlcC5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIG9wOiBzdGVwLm9wLFxuICAgICAgICAgICAgaWQ6IHN0ZXAuaGFzaGVkSWQsXG4gICAgICAgICAgICBuYW1lOiBzdGVwLm5hbWUsXG4gICAgICAgICAgICBvcHRzOiBzdGVwLm9wdHMsXG4gICAgICAgIH0pKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGFsc28gcnVuIGBvblNlbmRFdmVudGAgbWlkZGxld2FyZSBob29rcyBhZ2FpbnN0IGBzdGVwLmludm9rZSgpYCBzdGVwc1xuICAgICAgICAgKiB0byBlbnN1cmUgdGhhdCB0aGVpciBgZGF0YWAgaXMgdHJhbnNmb3JtZWQgY29ycmVjdGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtTmV3U3RlcHMoc3RlcExpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyBtaWRkbGV3YXJlLCB0cmFuc2Zvcm0gYW55IG5ld2x5LWZvdW5kIHN0ZXBzIGJlZm9yZSByZXR1cm5pbmcgdGhlbSB0b1xuICAgICAqIGFuIElubmdlc3QgU2VydmVyLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybU5ld1N0ZXBzKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChzdGVwcy5tYXAoYXN5bmMgKHN0ZXApID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgIGlmIChzdGVwLm9wICE9PSB0eXBlc19qc18xLlN0ZXBPcENvZGUuSW52b2tlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9uU2VuZEV2ZW50SG9va3MgPSBhd2FpdCAoMCwgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5nZXRIb29rU3RhY2spKHRoaXMub3B0aW9ucy5mbltcIm1pZGRsZXdhcmVcIl0sIFwib25TZW5kRXZlbnRcIiwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PdXRwdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2LnJlc3VsdCksIG91dHB1dCA9PT0gbnVsbCB8fCBvdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dHB1dC5yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yIGVhY2ggZXZlbnQgYmVpbmcgc2VudCwgY3JlYXRlIGEgbmV3IGBvblNlbmRFdmVudGAgaG9vayBzdGFjayB0b1xuICAgICAgICAgICAgICogcHJvY2VzcyBpdC4gV2UgZG8gdGhpcyBhcyBtaWRkbGV3YXJlIGhvb2tzIGFyZSBpbnRlbmRlZCB0byBydW4gb25jZVxuICAgICAgICAgICAgICogZHVyaW5nIGVhY2ggbGlmZWN5Y2xlIChvbkZ1bmN0aW9uUnVuIG9yIG9uU2VuZEV2ZW50KSBhbmQgaGVyZSwgYSBob29rXG4gICAgICAgICAgICAgKiBpcyBydW4gZm9yIGV2ZXJ5IHNpbmdsZSBldmVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGRvbmUgYmVjYXVzZSBhIGRldmVsb3BlciBjYW4gdXNlIHRoaXMgaG9vayB0byBmaWx0ZXIgb3V0XG4gICAgICAgICAgICAgKiBldmVudHMgZW50aXJlbHk7IGlmIHdlIGJhdGNoIGFsbCBvZiB0aGUgZXZlbnRzIHRvZ2V0aGVyLCB3ZSBjYW4ndFxuICAgICAgICAgICAgICogdGVsbCB3aGljaCBvbmVzIHdlcmUgZmlsdGVyZWQgb3V0IGlmIHdlJ3JlIHByb2Nlc3NpbmcgPjEgaW52b2NhdGlvblxuICAgICAgICAgICAgICogaGVyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXlsb2FkID0gYXdhaXQgKChfYSA9IG9uU2VuZEV2ZW50SG9va3MudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9uU2VuZEV2ZW50SG9va3MsIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkczogW1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgoX2MgPSAoX2IgPSBzdGVwLm9wdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSkpLCB7IG5hbWU6IGNvbnN0c19qc18xLmludGVybmFsRXZlbnRzLkZ1bmN0aW9uSW52b2tlZCB9KSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgbmV3UGF5bG9hZCA9IElubmdlc3RTdGVwVG9vbHNfanNfMS5pbnZva2VQYXlsb2FkU2NoZW1hLnBhcnNlKChfZSA9IChfZCA9IHRyYW5zZm9ybWVkUGF5bG9hZCA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1lZFBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWVkUGF5bG9hZC5wYXlsb2FkcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kWzBdKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB7fSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGVwKSwgeyBvcHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXAub3B0cyksIHsgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoKF9nID0gKF9mID0gc3RlcC5vcHRzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YucGF5bG9hZCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDoge30pKSwgbmV3UGF5bG9hZCkgfSkgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZVN0ZXAoeyBpZCwgbmFtZSwgb3B0cywgZm4sIGRpc3BsYXlOYW1lLCB9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIChfYSA9IHRoaXMudGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsZWFyKCk7XG4gICAgICAgIGF3YWl0ICgoX2MgPSAoX2IgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpKTtcbiAgICAgICAgYXdhaXQgKChfZSA9IChfZCA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSk7XG4gICAgICAgIGNvbnN0IG91dGdvaW5nT3AgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFJ1bixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCA9IG91dGdvaW5nT3A7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgKDAsIGFsc19qc18xLmdldEFzeW5jQ3R4KSgpO1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHN0b3JlLmV4ZWN1dGluZ1N0ZXAgPSB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoYGV4ZWN1dGluZyBzdGVwIFwiJHtpZH1cImApO1xuICAgICAgICByZXR1cm4gKCgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoZm4pXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICAgICAgICAgIC5maW5hbGx5KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmUuZXhlY3V0aW5nU3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0Z29pbmdPcCksIHsgZGF0YSB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dGdvaW5nT3ApLCB7IG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcEVycm9yLCBcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgZXJyb3IgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uLCBpbmNsdWRpbmcgdHJpZ2dlcmluZyBjaGVja3BvaW50c1xuICAgICAqIGFuZCBtaWRkbGV3YXJlIGhvb2tzIHdoZXJlIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0RXhlY3V0aW9uKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXRhdGUgaW5wdXQgYXMgbmVjY2Vzc2FyeSBiYXNlZCBvbiBtaWRkbGV3YXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc2Zvcm1JbnB1dCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgdGhlIHRpbWVyIHRvIHRpbWUgb3V0IHRoZSBydW4gaWYgbmVlZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdm9pZCAoKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnQoKSk7XG4gICAgICAgIGF3YWl0ICgoX2MgPSAoX2IgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmVmb3JlTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSBoYWQgbm8gc3RhdGUgdG8gYmVnaW4gd2l0aCwgaW1tZWRpYXRlbHkgZW5kIHRoZSBtZW1vaXphdGlvbiBwaGFzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmFsbFN0YXRlVXNlZCgpKSB7XG4gICAgICAgICAgICBhd2FpdCAoKF9lID0gKF9kID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9nID0gKF9mID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmNhbGwoX2YpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlciB0aGUgdXNlcidzIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKSgoKSA9PiB0aGlzLnVzZXJGblRvUnVuKHRoaXMuZm5BcmcpKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgICAgICAgICAuZmluYWxseShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgYXdhaXQgKChfZiA9IChfZSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoeyB0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsIGRhdGEgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoeyB0eXBlOiBcImZ1bmN0aW9uLXJlamVjdGVkXCIsIGVycm9yIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGlucHV0IGJlZm9yZSBydW5uaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybUlucHV0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpbnB1dE11dGF0aW9ucyA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICBjdHg6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZm5BcmcpLFxuICAgICAgICAgICAgc3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHJlcUFyZ3M6IHRoaXMub3B0aW9ucy5yZXFBcmdzLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuY3R4KSB7XG4gICAgICAgICAgICB0aGlzLmZuQXJnID0gaW5wdXRNdXRhdGlvbnMuY3R4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuc3RlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RlcFN0YXRlID0gT2JqZWN0LmZyb21FbnRyaWVzKGlucHV0TXV0YXRpb25zLnN0ZXBzLm1hcCgoc3RlcCkgPT4gW3N0ZXAuaWQsIHN0ZXBdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIG91dHB1dCBiZWZvcmUgcmV0dXJuaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybU91dHB1dChkYXRhT3JFcnJvcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGFPckVycm9yKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYW4gZXJyb3IgYW5kIGl0J3Mgb25lIHRoYXQgd2UganVzdCB0aHJldyBmcm9tIGEgc3RlcCxcbiAgICAgICAgICogd2Ugc2hvdWxkIHJldHVybiBhIGBOb25SZXRyaWFibGVFcnJvcmAgdG8gc3RvcCBleGVjdXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIG91dHB1dC5lcnJvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgb3V0cHV0LmRhdGEgPSAoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKG91dHB1dC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTdGVwRXhlY3V0aW9uID0gQm9vbGVhbih0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXApO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZE91dHB1dCA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtT3V0cHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLFxuICAgICAgICAgICAgc3RlcDogdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSwgdHJhbnNmb3JtZWRPdXRwdXQgPT09IG51bGwgfHwgdHJhbnNmb3JtZWRPdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWVkT3V0cHV0LnJlc3VsdCk7XG4gICAgICAgIGlmICghaXNTdGVwRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbmlzaGVkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbih7fSwgKHR5cGVvZiBlcnJvciAhPT0gXCJ1bmRlZmluZWRcIiA/IHsgZXJyb3IgfSA6IHsgZGF0YSB9KSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbnN1cmUgd2UgZ2l2ZSBtaWRkbGV3YXJlIHRoZSBjaGFuY2UgdG8gZGVjaWRlIG9uIHJldHJpYWJsZSBiZWhhdmlvdXJcbiAgICAgICAgICAgICAqIGJ5IGxvb2tpbmcgYXQgdGhlIGVycm9yIHJldHVybmVkIGZyb20gb3V0cHV0IHRyYW5zZm9ybWF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgcmV0cmlhYmxlID0gIShlcnJvciBpbnN0YW5jZW9mIE5vblJldHJpYWJsZUVycm9yX2pzXzEuTm9uUmV0cmlhYmxlRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBTdGVwRXJyb3JfanNfMS5TdGVwRXJyb3IpO1xuICAgICAgICAgICAgaWYgKHJldHJpYWJsZSAmJiBlcnJvciBpbnN0YW5jZW9mIFJldHJ5QWZ0ZXJFcnJvcl9qc18xLlJldHJ5QWZ0ZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHJpYWJsZSA9IGVycm9yLnJldHJ5QWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkRXJyb3IgPSAoMCwgZXJyb3JzX2pzXzEubWluaWZ5UHJldHR5RXJyb3IpKCgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvbi1yZWplY3RlZFwiLFxuICAgICAgICAgICAgICAgIGN0eDogdGhpcy5mbkFyZyxcbiAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBzZXJpYWxpemVkRXJyb3IsXG4gICAgICAgICAgICAgICAgcmV0cmlhYmxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvbi1yZXNvbHZlZFwiLFxuICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgIGRhdGE6ICgwLCBmdW5jdGlvbnNfanNfMS51bmRlZmluZWRUb051bGwpKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVFeGVjdXRpb25TdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgZCA9ICgwLCBwcm9taXNlc19qc18xLmNyZWF0ZURlZmVycmVkUHJvbWlzZVdpdGhTdGFjaykoKTtcbiAgICAgICAgbGV0IGNoZWNrcG9pbnRSZXNvbHZlID0gZC5kZWZlcnJlZC5yZXNvbHZlO1xuICAgICAgICBjb25zdCBjaGVja3BvaW50UmVzdWx0cyA9IGQucmVzdWx0cztcbiAgICAgICAgY29uc3QgbG9vcCA9IChmdW5jdGlvbiAoY2xlYW5VcCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSAoeWllbGQgX19hd2FpdChjaGVja3BvaW50UmVzdWx0cy5uZXh0KCkpKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVXAgPT09IG51bGwgfHwgY2xlYW5VcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnRpbWVvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhcigpO1xuICAgICAgICAgICAgdm9pZCBjaGVja3BvaW50UmVzdWx0cy5yZXR1cm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN0ZXBzVG9GdWxmaWxsID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0ZXBTdGF0ZTogdGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSxcbiAgICAgICAgICAgIHN0ZXBzVG9GdWxmaWxsLFxuICAgICAgICAgICAgc3RlcHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGxvb3AsXG4gICAgICAgICAgICBoYXNTdGVwczogQm9vbGVhbihzdGVwc1RvRnVsZmlsbCksXG4gICAgICAgICAgICBzdGVwQ29tcGxldGlvbk9yZGVyOiBbLi4udGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXJdLFxuICAgICAgICAgICAgcmVtYWluaW5nU3RlcHNUb0JlU2VlbjogbmV3IFNldCh0aGlzLm9wdGlvbnMuc3RlcENvbXBsZXRpb25PcmRlciksXG4gICAgICAgICAgICBzZXRDaGVja3BvaW50OiAoY2hlY2twb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgICh7IHJlc29sdmU6IGNoZWNrcG9pbnRSZXNvbHZlIH0gPSBjaGVja3BvaW50UmVzb2x2ZShjaGVja3BvaW50KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsU3RhdGVVc2VkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucmVtYWluaW5nU3RlcHNUb0JlU2Vlbi5zaXplID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBnZXQgb3BzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuc3RhdGUuc3RlcHMpO1xuICAgIH1cbiAgICBjcmVhdGVGbkFyZygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5jcmVhdGVTdGVwVG9vbHMoKTtcbiAgICAgICAgbGV0IGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMuZGF0YSksIHsgc3RlcCB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSB1c2Ugb2YgdGhlIGBvbkZhaWx1cmVgIG9wdGlvbiBieSBkZXNlcmlhbGl6aW5nIHRoZSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gem9kXzEuelxuICAgICAgICAgICAgICAgIC5vYmplY3QoeyBlcnJvcjogdHlwZXNfanNfMS5qc29uRXJyb3JTY2hlbWEgfSlcbiAgICAgICAgICAgICAgICAucGFyc2UoKF9hID0gZm5BcmcuZXZlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKTtcbiAgICAgICAgICAgIGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmbkFyZyksIHsgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5kZXNlcmlhbGl6ZUVycm9yKShldmVudERhdGEuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2QgPSAoX2MgPSAoX2IgPSB0aGlzLm9wdGlvbnMpLnRyYW5zZm9ybUN0eCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZuQXJnKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZm5Bcmc7XG4gICAgfVxuICAgIGNyZWF0ZVN0ZXBUb29scygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBzdGVwcyB0aGF0IGhhdmUgYmVlbiBmb3VuZCBhbmQgYXJlIGJlaW5nIHJvbGxlZCB1cCBiZWZvcmUgYmVpbmdcbiAgICAgICAgICogcmVwb3J0ZWQgdG8gdGhlIGNvcmUgbG9vcC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGZvdW5kU3RlcHNUb1JlcG9ydCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHRoZSBzdWJzZXQgb2YgZm91bmQgc3RlcHMgdG8gcmVwb3J0IHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAgICAgICogaGFuZGxlZC4gVXNlZCBmb3IgZmFzdCBhY2Nlc3MgdG8gc3RlcHMgdGhhdCBuZWVkIHRvIGJlIGhhbmRsZWQgaW4gb3JkZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiB0aGUgbGF0ZXN0IHNlcXVlbnRpYWwgc3RlcCBpbmRleGVzIGZvdW5kIGZvciBlYWNoIHN0ZXAgSUQuIFVzZWRcbiAgICAgICAgICogdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaW5kZXggc3RlcHMgaW4gcGFyYWxsZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGVzZSBtdXN0IGJlIHNlcXVlbnRpYWw7IGlmIHdlJ3ZlIHNlZW4gb3IgYXNzaWduZWQgYGE6MWAsXG4gICAgICAgICAqIGBhOjJgIGFuZCBgYTo0YCwgdGhlIGxhdGVzdCBzZXF1ZW50aWFsIHN0ZXAgaW5kZXggaXMgYDJgLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHByb21pc2UgdGhhdCdzIHVzZWQgdG8gZW5zdXJlIHRoYXQgc3RlcCByZXBvcnRpbmcgY2Fubm90IGJlIHJ1biBtb3JlIHRoYW5cbiAgICAgICAgICogb25jZSBpbiBhIGdpdmVuIGFzeW5jaHJvbm91cyB0aW1lIHNwYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgZm91bmRTdGVwc1JlcG9ydFByb21pc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHByb21pc2UgdGhhdCdzIHVzZWQgdG8gcmVwcmVzZW50IG1pZGRsZXdhcmUgaG9va3MgcnVubmluZyBiZWZvcmVcbiAgICAgICAgICogZXhlY3V0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGJlZm9yZUV4ZWNIb29rc1Byb21pc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGhlbHBlciB1c2VkIHRvIHJlcG9ydCBzdGVwcyB0byB0aGUgY29yZSBsb29wLiBVc2VkIGFmdGVyIGFkZGluZyBhbiBpdGVtXG4gICAgICAgICAqIHRvIGBmb3VuZFN0ZXBzVG9SZXBvcnRgLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVwb3J0TmV4dFRpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCZWluZyBleHBsaWNpdCBpbnN0ZWFkIG9mIHVzaW5nIGA/Pz1gIHRvIGFwcGVhc2UgVHlwZVNjcmlwdC5cbiAgICAgICAgICAgIGlmIChmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldEltbWVkaWF0ZShyZXNvbHZlKSlcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbnN1cmUgdGhhdCB3ZSB3YWl0IGZvciB0aGlzIHByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZSBncm91cHMgaW4gd2hpY2ggc3RlcHMgYXJlIHJlcG9ydGVkIGNhbiBhZmZlY3QgaG93IHdlIGRldGVjdCBzb21lXG4gICAgICAgICAgICAgICAgICogbW9yZSBjb21wbGV4IGRldGVybWluaXNtIGlzc3VlcyBsaWtlIHBhcmFsbGVsIGluZGV4aW5nLiBUaGlzIHByb21pc2VcbiAgICAgICAgICAgICAgICAgKiBjYW4gcmVwcmVzZW50IG1pZGRsZXdhcmUgaG9va3MgYmVpbmcgcnVuIGVhcmx5LCBpbiB0aGUgbWlkZGxlIG9mXG4gICAgICAgICAgICAgICAgICogaW5nZXN0aW5nIHN0ZXBzIHRvIHJlcG9ydC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEJlY2F1c2Ugb2YgdGhpcywgaXQncyBpbXBvcnRhbnQgd2Ugd2FpdCBmb3IgdGhpcyBtaWRkbGV3YXJlIHRvIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgKiBiZWZvcmUgY29udGludWluZyB0byByZXBvcnQgc3RlcHMgdG8gZW5zdXJlIHRoYXQgYWxsIHN0ZXBzIGhhdmUgYVxuICAgICAgICAgICAgICAgICAqIGNoYW5jZSB0byBiZSByZXBvcnRlZCB0aHJvdWdob3V0IHRoaXMgYXN5bmNocm9ub3VzIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBiZWZvcmVFeGVjSG9va3NQcm9taXNlKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtoYXNoZWRJZCwgc3RlcF0gb2YgdW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLmhhbmRsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuZGVsZXRlKGhhc2hlZElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLmZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RlcHNUb1JlcG9ydC5kZWxldGUoc3RlcC5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RlcHNUb1JlcG9ydC5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBzID0gWy4uLmZvdW5kU3RlcHNUb1JlcG9ydC52YWx1ZXMoKV07XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU3RlcHNUb1JlcG9ydC5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwcy1mb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcHM6IHN0ZXBzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIHVzZWQgdG8gcHVzaCBhIHN0ZXAgdG8gdGhlIGxpc3Qgb2Ygc3RlcHMgdG8gcmVwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcHVzaFN0ZXBUb1JlcG9ydCA9IChzdGVwKSA9PiB7XG4gICAgICAgICAgICBmb3VuZFN0ZXBzVG9SZXBvcnQuc2V0KHN0ZXAuaWQsIHN0ZXApO1xuICAgICAgICAgICAgdW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0LnNldChzdGVwLmhhc2hlZElkLCBzdGVwKTtcbiAgICAgICAgICAgIHJlcG9ydE5leHRUaWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0ZXBIYW5kbGVyID0gYXN5bmMgKHsgYXJncywgbWF0Y2hPcCwgb3B0cywgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgYXdhaXQgYmVmb3JlRXhlY0hvb2tzUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBPcHRpb25zID0gKDAsIElubmdlc3RTdGVwVG9vbHNfanNfMS5nZXRTdGVwT3B0aW9ucykoYXJnc1swXSk7XG4gICAgICAgICAgICBjb25zdCBvcElkID0gbWF0Y2hPcChzdGVwT3B0aW9ucywgLi4uYXJncy5zbGljZSgxKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgYSBzdGVwIGlzIGZvdW5kIGFmdGVyIGFzeW5jaHJvbm91cyBhY3Rpb25zIGR1cmluZyBhbm90aGVyIHN0ZXAnc1xuICAgICAgICAgICAgICAgICAqIGV4ZWN1dGlvbiwgZXZlcnl0aGluZyBpcyBmaW5lLiBUaGUgcHJvYmxlbSBoZXJlIGlzIGlmIHdlJ3ZlIGZvdW5kXG4gICAgICAgICAgICAgICAgICogdGhhdCBhIHN0ZXAgbmVzdGVkIGluc2lkZSBhbm90aGVyIGEgc3RlcCwgd2hpY2ggaXMgc29tZXRoaW5nIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICogc3VwcG9ydCBhdCB0aGUgdGltZSBvZiB3cml0aW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogSW4gdGhpcyBjYXNlLCB3ZSBjb3VsZCB1c2Ugc29tZXRoaW5nIGxpa2UgQXN5bmMgSG9va3MgdG8gdW5kZXJzdGFuZFxuICAgICAgICAgICAgICAgICAqIGhvdyB0aGUgc3RlcCBpcyBiZWluZyB0cmlnZ2VyZWQsIHRob3VnaCB0aGlzIGlzbid0IGF2YWlsYWJsZSBpbiBhbGxcbiAgICAgICAgICAgICAgICAgKiBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBUaGVyZWZvcmUsIHdlJ2xsIG9ubHkgc2hvdyBhIHdhcm5pbmcgaGVyZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgaXNcbiAgICAgICAgICAgICAgICAgKiBwb3RlbnRpYWxseSBhbiBpc3N1ZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogYFdlIGRldGVjdGVkIHRoYXQgeW91IGhhdmUgbmVzdGVkIFxcYHN0ZXAuKlxcYCB0b29saW5nIGluIFxcYCR7KF9hID0gb3BJZC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3BJZC5pZH1cXGBgLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiTmVzdGluZyBgc3RlcC4qYCB0b29saW5nIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwid2FyblwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzc3VyYW5jZTogXCJJdCdzIHBvc3NpYmxlIHRvIHNlZSB0aGlzIHdhcm5pbmcgaWYgc3RlcHMgYXJlIHNlcGFyYXRlZCBieSByZWd1bGFyIGFzeW5jaHJvbm91cyBjYWxscywgd2hpY2ggaXMgZmluZS5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRvRml4Tm93OiBcIk1ha2Ugc3VyZSB5b3UncmUgbm90IHVzaW5nIGBzdGVwLipgIHRvb2xpbmcgaW5zaWRlIG9mIG90aGVyIGBzdGVwLipgIHRvb2xpbmcuIElmIHlvdSBuZWVkIHRvIGNvbXBvc2Ugc3RlcHMgdG9nZXRoZXIsIHlvdSBjYW4gY3JlYXRlIGEgbmV3IGFzeW5jIGZ1bmN0aW9uIGFuZCBjYWxsIGl0IGZyb20gd2l0aGluIHlvdXIgc3RlcCBmdW5jdGlvbiwgb3IgdXNlIHByb21pc2UgY2hhaW5pbmcuXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yc19qc18xLkVyckNvZGUuTkVTVElOR19TVEVQUyxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGVwcy5oYXMob3BJZC5pZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbElkID0gb3BJZC5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZE5leHRJbmRleCA9IChfYiA9IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLmdldChvcmlnaW5hbElkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwZWN0ZWROZXh0SW5kZXg7OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBvcmlnaW5hbElkICsgSW5uZ2VzdFN0ZXBUb29sc19qc18xLlNURVBfSU5ERVhJTkdfU1VGRklYICsgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnN0ZXBzLmhhcyhuZXdJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLnNldChvcmlnaW5hbElkLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcElkLmlkID0gbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCk7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWRJZCA9IGV4cG9ydHMuX2ludGVybmFscy5oYXNoSWQob3BJZC5pZCk7XG4gICAgICAgICAgICBjb25zdCBzdGVwU3RhdGUgPSB0aGlzLnN0YXRlLnN0ZXBTdGF0ZVtoYXNoZWRJZF07XG4gICAgICAgICAgICBsZXQgaXNGdWxmaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGVwU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGVwU3RhdGUuc2VlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5yZW1haW5pbmdTdGVwc1RvQmVTZWVuLmRlbGV0ZShoYXNoZWRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwU3RhdGUuaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGdWxmaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRyYU9wdHM7XG4gICAgICAgICAgICBsZXQgZm5BcmdzID0gWy4uLmFyZ3NdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoc3RlcFN0YXRlID09PSBudWxsIHx8IHN0ZXBTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RlcFN0YXRlLmlucHV0KSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoc3RlcFN0YXRlLmlucHV0KSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BJZC5vcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgc3RlcC5ydW4oKWAgaGFzIGl0cyBmdW5jdGlvbiBpbnB1dCBhZmZlY3RlZFxuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgZm5BcmdzID0gWy4uLmFyZ3Muc2xpY2UoMCwgMiksIC4uLnN0ZXBTdGF0ZS5pbnB1dF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYU9wdHMgPSB7IGlucHV0OiBbLi4uc3RlcFN0YXRlLmlucHV0XSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0ZXAuYWkuaW5mZXIoKWAgaGFzIGl0cyBib2R5IGFmZmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfanNfMS5TdGVwT3BDb2RlLkFpR2F0ZXdheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFPcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHR5cGVvZiAoKF9jID0gb3BJZC5vcHRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYm9keSkgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBvcElkLm9wdHMuYm9keSkgOiB7fSkpLCBzdGVwU3RhdGUuaW5wdXRbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3BJZCksIHsgb3B0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcElkLm9wdHMpLCBleHRyYU9wdHMpLCByYXdBcmdzOiBmbkFyZ3MsIC8vIFRPRE8gV2hhdCBpcyB0aGUgcmlnaHQgdmFsdWUgaGVyZT8gU2hvdWxkIHRoaXMgYmUgcmF3IGFyZ3Mgd2l0aG91dCBhZmZlY3RlZCBpbnB1dD9cbiAgICAgICAgICAgICAgICBoYXNoZWRJZCwgaW5wdXQ6IHN0ZXBTdGF0ZSA9PT0gbnVsbCB8fCBzdGVwU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0ZXBTdGF0ZS5pbnB1dCwgXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBmbjogKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mbikgPyAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG9wdHMuZm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMsIC4uLmZuQXJncyk7IH0gOiB1bmRlZmluZWQsIHByb21pc2UsIGZ1bGZpbGxlZDogaXNGdWxmaWxsZWQsIGhhc1N0ZXBTdGF0ZTogQm9vbGVhbihzdGVwU3RhdGUpLCBkaXNwbGF5TmFtZTogKF9kID0gb3BJZC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3BJZC5pZCwgaGFuZGxlZDogZmFsc2UsIGhhbmRsZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcC5oYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RlcC5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVsZmlsbGVkICYmIHN0ZXBTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmZ1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc29tZSBleGVjdXRpb24gc2NlbmFyaW9zIHN1Y2ggYXMgdGVzdGluZywgYGRhdGFgLCBgZXJyb3JgLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGBpbnB1dGAgbWF5IGJlIGBQcm9taXNlc2AuIFRoaXMgY291bGQgYWxzbyBiZSB0aGUgY2FzZSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1dHVyZSBtaWRkbGV3YXJlIGFwcGxpY2F0aW9ucy4gRm9yIHRoaXMgcmVhc29uLCB3ZSdsbCBtYWtlIHN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgYXJlIGZ1bGx5IHJlc29sdmVkIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZS5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcFN0YXRlLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGVwU3RhdGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IgPSBuZXcgU3RlcEVycm9yX2pzXzEuU3RlcEVycm9yKG9wSWQuaWQsIHN0ZXBTdGF0ZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0ZXBzLnNldChvcElkLmlkLCBzdGVwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaGFzU3RlcHMgPSB0cnVlO1xuICAgICAgICAgICAgcHVzaFN0ZXBUb1JlcG9ydChzdGVwKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyB0aGUgbGFzdCBwaWVjZSBvZiBzdGF0ZSB3ZSBoYWQsIHdlJ3ZlIG5vdyBmaW5pc2hlZFxuICAgICAgICAgICAgICogbWVtb2l6aW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWJlZm9yZUV4ZWNIb29rc1Byb21pc2UgJiYgdGhpcy5zdGF0ZS5hbGxTdGF0ZVVzZWQoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IChiZWZvcmVFeGVjSG9va3NQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoMCwgSW5uZ2VzdFN0ZXBUb29sc19qc18xLmNyZWF0ZVN0ZXBUb29scykodGhpcy5vcHRpb25zLmNsaWVudCwgdGhpcywgc3RlcEhhbmRsZXIpO1xuICAgIH1cbiAgICBnZXRVc2VyRm5Ub1J1bigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mbltcImZuXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl0pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29tZWhvdywgd2UndmUgZW5kZWQgdXAgZGV0ZWN0aW5nIHRoYXQgdGhpcyBpcyBhIGZhaWx1cmUgaGFuZGxlciBidXRcbiAgICAgICAgICAgICAqIGRvZXNuJ3QgaGF2ZSBhbiBgb25GYWlsdXJlYCBmdW5jdGlvbi4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmdW5jdGlvbiBgb25GYWlsdXJlYCBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVRpbWVyKHN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXQgPSAoMCwgcHJvbWlzZXNfanNfMS5jcmVhdGVUaW1lb3V0UHJvbWlzZSkodGhpcy50aW1lb3V0RHVyYXRpb24pO1xuICAgICAgICB2b2lkIHRoaXMudGltZW91dC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9mID0gKF9lID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSkpO1xuICAgICAgICAgICAgc3RhdGUuc2V0Q2hlY2twb2ludCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLW5vdC1mb3VuZFwiLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwLFxuICAgICAgICAgICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBOb3RGb3VuZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZSgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5vcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gYXdhaXQgKDAsIElubmdlc3RNaWRkbGV3YXJlX2pzXzEuZ2V0SG9va1N0YWNrKSh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uRnVuY3Rpb25SdW5cIiwge1xuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgcmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3MsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYuY3R4KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LmN0eCksXG4gICAgICAgICAgICAgICAgICAgIGZuOiB0aGlzLm9wdGlvbnMuZm4sXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBwcmV2LnN0ZXBzLm1hcCgoc3RlcCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXApLCAoX2EgPSBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuc3RlcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVxQXJnczogcHJldi5yZXFBcmdzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYucmVzdWx0KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHByZXYuc3RlcCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBob29rcztcbiAgICB9XG59XG5jb25zdCBoYXNoSWQgPSAoaWQpID0+IHtcbiAgICByZXR1cm4gKDAsIGhhc2hfanNfMS5zaGExKSgpLnVwZGF0ZShpZCkuZGlnZXN0KFwiaGV4XCIpO1xufTtcbmNvbnN0IGhhc2hPcCA9IChvcCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wKSwgeyBpZDogaGFzaElkKG9wLmlkKSB9KTtcbn07XG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nLlxuICovXG5leHBvcnRzLl9pbnRlcm5hbHMgPSB7IGhhc2hPcCwgaGFzaElkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12Mi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/ServerTiming.js":
/*!******************************************************!*\
  !*** ./node_modules/inngest/helpers/ServerTiming.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerTiming = void 0;\nconst promises_js_1 = __webpack_require__(/*! ./promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n/**\n * A class to manage timing functions and arbitrary periods of time before\n * generating a `Server-Timing` header for use in HTTP responses.\n *\n * This is a very simple implementation that does not support nested timings or\n * fractions of a millisecond.\n */\nclass ServerTiming {\n    constructor() {\n        this.timings = {};\n    }\n    /**\n     * Start a timing. Returns a function that, when called, will stop the timing\n     * and add it to the header.\n     */\n    start(name, description) {\n        if (!this.timings[name]) {\n            this.timings[name] = {\n                description: description !== null && description !== void 0 ? description : \"\",\n                timers: [],\n            };\n        }\n        const index = this.timings[name].timers.push({ start: Date.now() }) - 1;\n        return () => {\n            const target = this.timings[name];\n            if (!target) {\n                return console.warn(`Timing \"${name}\" does not exist`);\n            }\n            const timer = target.timers[index];\n            if (!timer) {\n                return console.warn(`Timer ${index} for timing \"${name}\" does not exist`);\n            }\n            timer.end = Date.now();\n        };\n    }\n    /**\n     * Add a piece of arbitrary, untimed information to the header. Common use\n     * cases would be cache misses.\n     *\n     * @example\n     * ```\n     * timer.append(\"cache\", \"miss\");\n     * ```\n     */\n    append(key, value) {\n        this.timings[key] = {\n            description: value,\n            timers: [],\n        };\n    }\n    /**\n     * Wrap a function in a timing. The timing will be stopped and added to the\n     * header when the function resolves or rejects.\n     *\n     * The return value of the function will be returned from this function.\n     */\n    async wrap(name, fn, description) {\n        const stop = this.start(name, description);\n        try {\n            return (await (0, promises_js_1.runAsPromise)(fn));\n        }\n        finally {\n            stop();\n        }\n    }\n    /**\n     * Generate the `Server-Timing` header.\n     */\n    getHeader() {\n        const entries = Object.entries(this.timings).reduce((acc, [name, { description, timers }]) => {\n            /**\n             * Ignore timers that had no end.\n             */\n            const hasTimersWithEnd = timers.some((timer) => timer.end);\n            if (!hasTimersWithEnd) {\n                return acc;\n            }\n            const dur = timers.reduce((acc, { start, end }) => {\n                if (!start || !end)\n                    return acc;\n                return acc + (end - start);\n            }, 0);\n            const entry = [\n                name,\n                description ? `desc=\"${description}\"` : \"\",\n                dur ? `dur=${dur}` : \"\",\n            ]\n                .filter(Boolean)\n                .join(\";\");\n            return [...acc, entry];\n        }, []);\n        return entries.join(\", \");\n    }\n}\nexports.ServerTiming = ServerTiming;\n//# sourceMappingURL=ServerTiming.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL1NlcnZlclRpbWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsc0JBQXNCLG1CQUFPLENBQUMsdUVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLGNBQWMsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9TZXJ2ZXJUaW1pbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlclRpbWluZyA9IHZvaWQgMDtcbmNvbnN0IHByb21pc2VzX2pzXzEgPSByZXF1aXJlKFwiLi9wcm9taXNlcy5qc1wiKTtcbi8qKlxuICogQSBjbGFzcyB0byBtYW5hZ2UgdGltaW5nIGZ1bmN0aW9ucyBhbmQgYXJiaXRyYXJ5IHBlcmlvZHMgb2YgdGltZSBiZWZvcmVcbiAqIGdlbmVyYXRpbmcgYSBgU2VydmVyLVRpbWluZ2AgaGVhZGVyIGZvciB1c2UgaW4gSFRUUCByZXNwb25zZXMuXG4gKlxuICogVGhpcyBpcyBhIHZlcnkgc2ltcGxlIGltcGxlbWVudGF0aW9uIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgdGltaW5ncyBvclxuICogZnJhY3Rpb25zIG9mIGEgbWlsbGlzZWNvbmQuXG4gKi9cbmNsYXNzIFNlcnZlclRpbWluZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGltaW5ncyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIHRpbWluZy4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIHN0b3AgdGhlIHRpbWluZ1xuICAgICAqIGFuZCBhZGQgaXQgdG8gdGhlIGhlYWRlci5cbiAgICAgKi9cbiAgICBzdGFydChuYW1lLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMudGltaW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy50aW1pbmdzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiAhPT0gbnVsbCAmJiBkZXNjcmlwdGlvbiAhPT0gdm9pZCAwID8gZGVzY3JpcHRpb24gOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRpbWVyczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50aW1pbmdzW25hbWVdLnRpbWVycy5wdXNoKHsgc3RhcnQ6IERhdGUubm93KCkgfSkgLSAxO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50aW1pbmdzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGBUaW1pbmcgXCIke25hbWV9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gdGFyZ2V0LnRpbWVyc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgVGltZXIgJHtpbmRleH0gZm9yIHRpbWluZyBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXIuZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgcGllY2Ugb2YgYXJiaXRyYXJ5LCB1bnRpbWVkIGluZm9ybWF0aW9uIHRvIHRoZSBoZWFkZXIuIENvbW1vbiB1c2VcbiAgICAgKiBjYXNlcyB3b3VsZCBiZSBjYWNoZSBtaXNzZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIHRpbWVyLmFwcGVuZChcImNhY2hlXCIsIFwibWlzc1wiKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhcHBlbmQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbWluZ3Nba2V5XSA9IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZSxcbiAgICAgICAgICAgIHRpbWVyczogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXAgYSBmdW5jdGlvbiBpbiBhIHRpbWluZy4gVGhlIHRpbWluZyB3aWxsIGJlIHN0b3BwZWQgYW5kIGFkZGVkIHRvIHRoZVxuICAgICAqIGhlYWRlciB3aGVuIHRoZSBmdW5jdGlvbiByZXNvbHZlcyBvciByZWplY3RzLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgd3JhcChuYW1lLCBmbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3Qgc3RvcCA9IHRoaXMuc3RhcnQobmFtZSwgZGVzY3JpcHRpb24pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCAoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKGZuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGBTZXJ2ZXItVGltaW5nYCBoZWFkZXIuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKCkge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModGhpcy50aW1pbmdzKS5yZWR1Y2UoKGFjYywgW25hbWUsIHsgZGVzY3JpcHRpb24sIHRpbWVycyB9XSkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZ25vcmUgdGltZXJzIHRoYXQgaGFkIG5vIGVuZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgaGFzVGltZXJzV2l0aEVuZCA9IHRpbWVycy5zb21lKCh0aW1lcikgPT4gdGltZXIuZW5kKTtcbiAgICAgICAgICAgIGlmICghaGFzVGltZXJzV2l0aEVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkdXIgPSB0aW1lcnMucmVkdWNlKChhY2MsIHsgc3RhcnQsIGVuZCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyAoZW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IFtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID8gYGRlc2M9XCIke2Rlc2NyaXB0aW9ufVwiYCA6IFwiXCIsXG4gICAgICAgICAgICAgICAgZHVyID8gYGR1cj0ke2R1cn1gIDogXCJcIixcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCI7XCIpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIGVudHJ5XTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gZW50cmllcy5qb2luKFwiLCBcIik7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJUaW1pbmcgPSBTZXJ2ZXJUaW1pbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXJ2ZXJUaW1pbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/ServerTiming.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/consts.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/consts.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.syncKind = exports.serverKind = exports.dummyEventKey = exports.debugPrefix = exports.logPrefix = exports.internalEvents = exports.defaultDevServerHost = exports.defaultInngestEventBaseUrl = exports.defaultInngestApiBaseUrl = exports.headerKeys = exports.envKeys = exports.probe = exports.queryKeys = void 0;\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ \"(rsc)/./node_modules/chalk/source/index.js\"));\n/**\n * Keys for accessing query parameters included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nvar queryKeys;\n(function (queryKeys) {\n    queryKeys[\"DeployId\"] = \"deployId\";\n    queryKeys[\"FnId\"] = \"fnId\";\n    queryKeys[\"Probe\"] = \"probe\";\n    queryKeys[\"StepId\"] = \"stepId\";\n})(queryKeys || (exports.queryKeys = queryKeys = {}));\nvar probe;\n(function (probe) {\n    probe[\"Trust\"] = \"trust\";\n})(probe || (exports.probe = probe = {}));\nvar envKeys;\n(function (envKeys) {\n    envKeys[\"InngestSigningKey\"] = \"INNGEST_SIGNING_KEY\";\n    envKeys[\"InngestSigningKeyFallback\"] = \"INNGEST_SIGNING_KEY_FALLBACK\";\n    envKeys[\"InngestEventKey\"] = \"INNGEST_EVENT_KEY\";\n    /**\n     * @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.\n     */\n    envKeys[\"InngestDevServerUrl\"] = \"INNGEST_DEVSERVER_URL\";\n    envKeys[\"InngestEnvironment\"] = \"INNGEST_ENV\";\n    envKeys[\"InngestBaseUrl\"] = \"INNGEST_BASE_URL\";\n    envKeys[\"InngestEventApiBaseUrl\"] = \"INNGEST_EVENT_API_BASE_URL\";\n    envKeys[\"InngestApiBaseUrl\"] = \"INNGEST_API_BASE_URL\";\n    envKeys[\"InngestServeHost\"] = \"INNGEST_SERVE_HOST\";\n    envKeys[\"InngestServePath\"] = \"INNGEST_SERVE_PATH\";\n    envKeys[\"InngestLogLevel\"] = \"INNGEST_LOG_LEVEL\";\n    envKeys[\"InngestStreaming\"] = \"INNGEST_STREAMING\";\n    envKeys[\"InngestDevMode\"] = \"INNGEST_DEV\";\n    envKeys[\"InngestAllowInBandSync\"] = \"INNGEST_ALLOW_IN_BAND_SYNC\";\n    /**\n     * @deprecated It's unknown what this env var was used for, but we do not\n     * provide explicit support for it. Prefer using `INNGEST_ENV` instead.\n     */\n    envKeys[\"BranchName\"] = \"BRANCH_NAME\";\n    /**\n     * The git branch of the commit the deployment was triggered by. Example:\n     * `improve-about-page`.\n     *\n     * {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}\n     */\n    envKeys[\"VercelBranch\"] = \"VERCEL_GIT_COMMIT_REF\";\n    /**\n     * Expected to be `\"1\"` if defined.\n     */\n    envKeys[\"IsVercel\"] = \"VERCEL\";\n    /**\n     * The branch name of the current deployment. May only be accessible at build\n     * time, but included here just in case.\n     *\n     * {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}\n     */\n    envKeys[\"CloudflarePagesBranch\"] = \"CF_PAGES_BRANCH\";\n    /**\n     * Expected to be `\"1\"` if defined.\n     */\n    envKeys[\"IsCloudflarePages\"] = \"CF_PAGES\";\n    /**\n     * The branch name of the deployment from Git to Netlify, if available.\n     *\n     * {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}\n     */\n    envKeys[\"NetlifyBranch\"] = \"BRANCH\";\n    /**\n     * Expected to be `\"true\"` if defined.\n     */\n    envKeys[\"IsNetlify\"] = \"NETLIFY\";\n    /**\n     * The Git branch for a service or deploy.\n     *\n     * {@link https://render.com/docs/environment-variables#all-services}\n     */\n    envKeys[\"RenderBranch\"] = \"RENDER_GIT_BRANCH\";\n    /**\n     * Expected to be `\"true\"` if defined.\n     */\n    envKeys[\"IsRender\"] = \"RENDER\";\n    /**\n     * The branch that triggered the deployment. Example: `main`\n     *\n     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n     */\n    envKeys[\"RailwayBranch\"] = \"RAILWAY_GIT_BRANCH\";\n    /**\n     * The railway environment for the deployment. Example: `production`\n     *\n     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n     */\n    envKeys[\"RailwayEnvironment\"] = \"RAILWAY_ENVIRONMENT\";\n    envKeys[\"VercelEnvKey\"] = \"VERCEL_ENV\";\n    envKeys[\"OpenAiApiKey\"] = \"OPENAI_API_KEY\";\n    envKeys[\"GeminiApiKey\"] = \"GEMINI_API_KEY\";\n    envKeys[\"AnthropicApiKey\"] = \"ANTHROPIC_API_KEY\";\n})(envKeys || (exports.envKeys = envKeys = {}));\n/**\n * Keys for accessing headers included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nvar headerKeys;\n(function (headerKeys) {\n    headerKeys[\"ContentLength\"] = \"content-length\";\n    headerKeys[\"Signature\"] = \"x-inngest-signature\";\n    headerKeys[\"SdkVersion\"] = \"x-inngest-sdk\";\n    headerKeys[\"Environment\"] = \"x-inngest-env\";\n    headerKeys[\"Platform\"] = \"x-inngest-platform\";\n    headerKeys[\"Framework\"] = \"x-inngest-framework\";\n    headerKeys[\"NoRetry\"] = \"x-inngest-no-retry\";\n    headerKeys[\"RequestVersion\"] = \"x-inngest-req-version\";\n    headerKeys[\"RetryAfter\"] = \"retry-after\";\n    headerKeys[\"InngestServerKind\"] = \"x-inngest-server-kind\";\n    headerKeys[\"InngestExpectedServerKind\"] = \"x-inngest-expected-server-kind\";\n    headerKeys[\"InngestSyncKind\"] = \"x-inngest-sync-kind\";\n    headerKeys[\"EventIdSeed\"] = \"x-inngest-event-id-seed\";\n    headerKeys[\"TraceParent\"] = \"traceparent\";\n    headerKeys[\"TraceState\"] = \"tracestate\";\n})(headerKeys || (exports.headerKeys = headerKeys = {}));\nexports.defaultInngestApiBaseUrl = \"https://api.inngest.com/\";\nexports.defaultInngestEventBaseUrl = \"https://inn.gs/\";\nexports.defaultDevServerHost = \"http://localhost:8288/\";\n/**\n * Events that Inngest may send internally that can be used to trigger\n * functions.\n *\n * @public\n */\nvar internalEvents;\n(function (internalEvents) {\n    /**\n     * A function has failed after exhausting all available retries. This event\n     * will contain the original event and the error that caused the failure.\n     */\n    internalEvents[\"FunctionFailed\"] = \"inngest/function.failed\";\n    internalEvents[\"FunctionInvoked\"] = \"inngest/function.invoked\";\n    internalEvents[\"FunctionFinished\"] = \"inngest/function.finished\";\n    internalEvents[\"FunctionCancelled\"] = \"inngest/function.cancelled\";\n    internalEvents[\"ScheduledTimer\"] = \"inngest/scheduled.timer\";\n})(internalEvents || (exports.internalEvents = internalEvents = {}));\nexports.logPrefix = chalk_1.default.magenta.bold(\"[Inngest]\");\nexports.debugPrefix = \"inngest\";\nexports.dummyEventKey = \"NO_EVENT_KEY_SET\";\nvar serverKind;\n(function (serverKind) {\n    serverKind[\"Dev\"] = \"dev\";\n    serverKind[\"Cloud\"] = \"cloud\";\n})(serverKind || (exports.serverKind = serverKind = {}));\nvar syncKind;\n(function (syncKind) {\n    syncKind[\"InBand\"] = \"in_band\";\n    syncKind[\"OutOfBand\"] = \"out_of_band\";\n})(syncKind || (exports.syncKind = syncKind = {}));\n//# sourceMappingURL=consts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NvbnN0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLDRCQUE0QixHQUFHLGtDQUFrQyxHQUFHLGdDQUFnQyxHQUFHLGtCQUFrQixHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsaUJBQWlCO0FBQ2xULGdDQUFnQyxtQkFBTyxDQUFDLHlEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxZQUFZLGFBQWEsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYyxlQUFlLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCLGtCQUFrQixrQkFBa0I7QUFDdEQsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEUsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlLGdCQUFnQixnQkFBZ0I7QUFDaEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9jb25zdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN5bmNLaW5kID0gZXhwb3J0cy5zZXJ2ZXJLaW5kID0gZXhwb3J0cy5kdW1teUV2ZW50S2V5ID0gZXhwb3J0cy5kZWJ1Z1ByZWZpeCA9IGV4cG9ydHMubG9nUHJlZml4ID0gZXhwb3J0cy5pbnRlcm5hbEV2ZW50cyA9IGV4cG9ydHMuZGVmYXVsdERldlNlcnZlckhvc3QgPSBleHBvcnRzLmRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsID0gZXhwb3J0cy5kZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwgPSBleHBvcnRzLmhlYWRlcktleXMgPSBleHBvcnRzLmVudktleXMgPSBleHBvcnRzLnByb2JlID0gZXhwb3J0cy5xdWVyeUtleXMgPSB2b2lkIDA7XG5jb25zdCBjaGFsa18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjaGFsa1wiKSk7XG4vKipcbiAqIEtleXMgZm9yIGFjY2Vzc2luZyBxdWVyeSBwYXJhbWV0ZXJzIGluY2x1ZGVkIGluIHJlcXVlc3RzIGZyb20gSW5uZ2VzdCB0byBydW5cbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBVc2VkIGludGVybmFsbHkgdG8gY3JlYXRlIGhhbmRsZXJzIHVzaW5nIGBJbm5nZXN0Q29tbUhhbmRsZXJgLCBidXQgY2FuIGJlXG4gKiBpbXBvcnRlZCB0byBiZSB1c2VkIGlmIGNyZWF0aW5nIGEgY3VzdG9tIGhhbmRsZXIgb3V0c2lkZSBvZiB0aGUgcGFja2FnZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBxdWVyeUtleXM7XG4oZnVuY3Rpb24gKHF1ZXJ5S2V5cykge1xuICAgIHF1ZXJ5S2V5c1tcIkRlcGxveUlkXCJdID0gXCJkZXBsb3lJZFwiO1xuICAgIHF1ZXJ5S2V5c1tcIkZuSWRcIl0gPSBcImZuSWRcIjtcbiAgICBxdWVyeUtleXNbXCJQcm9iZVwiXSA9IFwicHJvYmVcIjtcbiAgICBxdWVyeUtleXNbXCJTdGVwSWRcIl0gPSBcInN0ZXBJZFwiO1xufSkocXVlcnlLZXlzIHx8IChleHBvcnRzLnF1ZXJ5S2V5cyA9IHF1ZXJ5S2V5cyA9IHt9KSk7XG52YXIgcHJvYmU7XG4oZnVuY3Rpb24gKHByb2JlKSB7XG4gICAgcHJvYmVbXCJUcnVzdFwiXSA9IFwidHJ1c3RcIjtcbn0pKHByb2JlIHx8IChleHBvcnRzLnByb2JlID0gcHJvYmUgPSB7fSkpO1xudmFyIGVudktleXM7XG4oZnVuY3Rpb24gKGVudktleXMpIHtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdFNpZ25pbmdLZXlcIl0gPSBcIklOTkdFU1RfU0lHTklOR19LRVlcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdFNpZ25pbmdLZXlGYWxsYmFja1wiXSA9IFwiSU5OR0VTVF9TSUdOSU5HX0tFWV9GQUxMQkFDS1wiO1xuICAgIGVudktleXNbXCJJbm5nZXN0RXZlbnRLZXlcIl0gPSBcIklOTkdFU1RfRVZFTlRfS0VZXCI7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVtb3ZlZCBpbiB2My4gVXNlIHtAbGluayBJbm5nZXN0QmFzZVVybH0gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiSW5uZ2VzdERldlNlcnZlclVybFwiXSA9IFwiSU5OR0VTVF9ERVZTRVJWRVJfVVJMXCI7XG4gICAgZW52S2V5c1tcIklubmdlc3RFbnZpcm9ubWVudFwiXSA9IFwiSU5OR0VTVF9FTlZcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEJhc2VVcmxcIl0gPSBcIklOTkdFU1RfQkFTRV9VUkxcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEV2ZW50QXBpQmFzZVVybFwiXSA9IFwiSU5OR0VTVF9FVkVOVF9BUElfQkFTRV9VUkxcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEFwaUJhc2VVcmxcIl0gPSBcIklOTkdFU1RfQVBJX0JBU0VfVVJMXCI7XG4gICAgZW52S2V5c1tcIklubmdlc3RTZXJ2ZUhvc3RcIl0gPSBcIklOTkdFU1RfU0VSVkVfSE9TVFwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0U2VydmVQYXRoXCJdID0gXCJJTk5HRVNUX1NFUlZFX1BBVEhcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdExvZ0xldmVsXCJdID0gXCJJTk5HRVNUX0xPR19MRVZFTFwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0U3RyZWFtaW5nXCJdID0gXCJJTk5HRVNUX1NUUkVBTUlOR1wiO1xuICAgIGVudktleXNbXCJJbm5nZXN0RGV2TW9kZVwiXSA9IFwiSU5OR0VTVF9ERVZcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEFsbG93SW5CYW5kU3luY1wiXSA9IFwiSU5OR0VTVF9BTExPV19JTl9CQU5EX1NZTkNcIjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBJdCdzIHVua25vd24gd2hhdCB0aGlzIGVudiB2YXIgd2FzIHVzZWQgZm9yLCBidXQgd2UgZG8gbm90XG4gICAgICogcHJvdmlkZSBleHBsaWNpdCBzdXBwb3J0IGZvciBpdC4gUHJlZmVyIHVzaW5nIGBJTk5HRVNUX0VOVmAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiQnJhbmNoTmFtZVwiXSA9IFwiQlJBTkNIX05BTUVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZ2l0IGJyYW5jaCBvZiB0aGUgY29tbWl0IHRoZSBkZXBsb3ltZW50IHdhcyB0cmlnZ2VyZWQgYnkuIEV4YW1wbGU6XG4gICAgICogYGltcHJvdmUtYWJvdXQtcGFnZWAuXG4gICAgICpcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvY29uY2VwdHMvcHJvamVjdHMvZW52aXJvbm1lbnQtdmFyaWFibGVzL3N5c3RlbS1lbnZpcm9ubWVudC12YXJpYWJsZXMjc3lzdGVtLWVudmlyb25tZW50LXZhcmlhYmxlc31cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiVmVyY2VsQnJhbmNoXCJdID0gXCJWRVJDRUxfR0lUX0NPTU1JVF9SRUZcIjtcbiAgICAvKipcbiAgICAgKiBFeHBlY3RlZCB0byBiZSBgXCIxXCJgIGlmIGRlZmluZWQuXG4gICAgICovXG4gICAgZW52S2V5c1tcIklzVmVyY2VsXCJdID0gXCJWRVJDRUxcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgYnJhbmNoIG5hbWUgb2YgdGhlIGN1cnJlbnQgZGVwbG95bWVudC4gTWF5IG9ubHkgYmUgYWNjZXNzaWJsZSBhdCBidWlsZFxuICAgICAqIHRpbWUsIGJ1dCBpbmNsdWRlZCBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuY2xvdWRmbGFyZS5jb20vcGFnZXMvcGxhdGZvcm0vYnVpbGQtY29uZmlndXJhdGlvbi8jZW52aXJvbm1lbnQtdmFyaWFibGVzfVxuICAgICAqL1xuICAgIGVudktleXNbXCJDbG91ZGZsYXJlUGFnZXNCcmFuY2hcIl0gPSBcIkNGX1BBR0VTX0JSQU5DSFwiO1xuICAgIC8qKlxuICAgICAqIEV4cGVjdGVkIHRvIGJlIGBcIjFcImAgaWYgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiSXNDbG91ZGZsYXJlUGFnZXNcIl0gPSBcIkNGX1BBR0VTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGJyYW5jaCBuYW1lIG9mIHRoZSBkZXBsb3ltZW50IGZyb20gR2l0IHRvIE5ldGxpZnksIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2RvY3MubmV0bGlmeS5jb20vY29uZmlndXJlLWJ1aWxkcy9lbnZpcm9ubWVudC12YXJpYWJsZXMvI2dpdC1tZXRhZGF0YX1cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiTmV0bGlmeUJyYW5jaFwiXSA9IFwiQlJBTkNIXCI7XG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgdG8gYmUgYFwidHJ1ZVwiYCBpZiBkZWZpbmVkLlxuICAgICAqL1xuICAgIGVudktleXNbXCJJc05ldGxpZnlcIl0gPSBcIk5FVExJRllcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgR2l0IGJyYW5jaCBmb3IgYSBzZXJ2aWNlIG9yIGRlcGxveS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL3JlbmRlci5jb20vZG9jcy9lbnZpcm9ubWVudC12YXJpYWJsZXMjYWxsLXNlcnZpY2VzfVxuICAgICAqL1xuICAgIGVudktleXNbXCJSZW5kZXJCcmFuY2hcIl0gPSBcIlJFTkRFUl9HSVRfQlJBTkNIXCI7XG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgdG8gYmUgYFwidHJ1ZVwiYCBpZiBkZWZpbmVkLlxuICAgICAqL1xuICAgIGVudktleXNbXCJJc1JlbmRlclwiXSA9IFwiUkVOREVSXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGJyYW5jaCB0aGF0IHRyaWdnZXJlZCB0aGUgZGVwbG95bWVudC4gRXhhbXBsZTogYG1haW5gXG4gICAgICpcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnJhaWx3YXkuYXBwL2RldmVsb3AvdmFyaWFibGVzI3JhaWx3YXktcHJvdmlkZWQtdmFyaWFibGVzfVxuICAgICAqL1xuICAgIGVudktleXNbXCJSYWlsd2F5QnJhbmNoXCJdID0gXCJSQUlMV0FZX0dJVF9CUkFOQ0hcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmFpbHdheSBlbnZpcm9ubWVudCBmb3IgdGhlIGRlcGxveW1lbnQuIEV4YW1wbGU6IGBwcm9kdWN0aW9uYFxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZG9jcy5yYWlsd2F5LmFwcC9kZXZlbG9wL3ZhcmlhYmxlcyNyYWlsd2F5LXByb3ZpZGVkLXZhcmlhYmxlc31cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiUmFpbHdheUVudmlyb25tZW50XCJdID0gXCJSQUlMV0FZX0VOVklST05NRU5UXCI7XG4gICAgZW52S2V5c1tcIlZlcmNlbEVudktleVwiXSA9IFwiVkVSQ0VMX0VOVlwiO1xuICAgIGVudktleXNbXCJPcGVuQWlBcGlLZXlcIl0gPSBcIk9QRU5BSV9BUElfS0VZXCI7XG4gICAgZW52S2V5c1tcIkdlbWluaUFwaUtleVwiXSA9IFwiR0VNSU5JX0FQSV9LRVlcIjtcbiAgICBlbnZLZXlzW1wiQW50aHJvcGljQXBpS2V5XCJdID0gXCJBTlRIUk9QSUNfQVBJX0tFWVwiO1xufSkoZW52S2V5cyB8fCAoZXhwb3J0cy5lbnZLZXlzID0gZW52S2V5cyA9IHt9KSk7XG4vKipcbiAqIEtleXMgZm9yIGFjY2Vzc2luZyBoZWFkZXJzIGluY2x1ZGVkIGluIHJlcXVlc3RzIGZyb20gSW5uZ2VzdCB0byBydW5cbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBVc2VkIGludGVybmFsbHkgdG8gY3JlYXRlIGhhbmRsZXJzIHVzaW5nIGBJbm5nZXN0Q29tbUhhbmRsZXJgLCBidXQgY2FuIGJlXG4gKiBpbXBvcnRlZCB0byBiZSB1c2VkIGlmIGNyZWF0aW5nIGEgY3VzdG9tIGhhbmRsZXIgb3V0c2lkZSBvZiB0aGUgcGFja2FnZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBoZWFkZXJLZXlzO1xuKGZ1bmN0aW9uIChoZWFkZXJLZXlzKSB7XG4gICAgaGVhZGVyS2V5c1tcIkNvbnRlbnRMZW5ndGhcIl0gPSBcImNvbnRlbnQtbGVuZ3RoXCI7XG4gICAgaGVhZGVyS2V5c1tcIlNpZ25hdHVyZVwiXSA9IFwieC1pbm5nZXN0LXNpZ25hdHVyZVwiO1xuICAgIGhlYWRlcktleXNbXCJTZGtWZXJzaW9uXCJdID0gXCJ4LWlubmdlc3Qtc2RrXCI7XG4gICAgaGVhZGVyS2V5c1tcIkVudmlyb25tZW50XCJdID0gXCJ4LWlubmdlc3QtZW52XCI7XG4gICAgaGVhZGVyS2V5c1tcIlBsYXRmb3JtXCJdID0gXCJ4LWlubmdlc3QtcGxhdGZvcm1cIjtcbiAgICBoZWFkZXJLZXlzW1wiRnJhbWV3b3JrXCJdID0gXCJ4LWlubmdlc3QtZnJhbWV3b3JrXCI7XG4gICAgaGVhZGVyS2V5c1tcIk5vUmV0cnlcIl0gPSBcIngtaW5uZ2VzdC1uby1yZXRyeVwiO1xuICAgIGhlYWRlcktleXNbXCJSZXF1ZXN0VmVyc2lvblwiXSA9IFwieC1pbm5nZXN0LXJlcS12ZXJzaW9uXCI7XG4gICAgaGVhZGVyS2V5c1tcIlJldHJ5QWZ0ZXJcIl0gPSBcInJldHJ5LWFmdGVyXCI7XG4gICAgaGVhZGVyS2V5c1tcIklubmdlc3RTZXJ2ZXJLaW5kXCJdID0gXCJ4LWlubmdlc3Qtc2VydmVyLWtpbmRcIjtcbiAgICBoZWFkZXJLZXlzW1wiSW5uZ2VzdEV4cGVjdGVkU2VydmVyS2luZFwiXSA9IFwieC1pbm5nZXN0LWV4cGVjdGVkLXNlcnZlci1raW5kXCI7XG4gICAgaGVhZGVyS2V5c1tcIklubmdlc3RTeW5jS2luZFwiXSA9IFwieC1pbm5nZXN0LXN5bmMta2luZFwiO1xuICAgIGhlYWRlcktleXNbXCJFdmVudElkU2VlZFwiXSA9IFwieC1pbm5nZXN0LWV2ZW50LWlkLXNlZWRcIjtcbiAgICBoZWFkZXJLZXlzW1wiVHJhY2VQYXJlbnRcIl0gPSBcInRyYWNlcGFyZW50XCI7XG4gICAgaGVhZGVyS2V5c1tcIlRyYWNlU3RhdGVcIl0gPSBcInRyYWNlc3RhdGVcIjtcbn0pKGhlYWRlcktleXMgfHwgKGV4cG9ydHMuaGVhZGVyS2V5cyA9IGhlYWRlcktleXMgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLmlubmdlc3QuY29tL1wiO1xuZXhwb3J0cy5kZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCA9IFwiaHR0cHM6Ly9pbm4uZ3MvXCI7XG5leHBvcnRzLmRlZmF1bHREZXZTZXJ2ZXJIb3N0ID0gXCJodHRwOi8vbG9jYWxob3N0OjgyODgvXCI7XG4vKipcbiAqIEV2ZW50cyB0aGF0IElubmdlc3QgbWF5IHNlbmQgaW50ZXJuYWxseSB0aGF0IGNhbiBiZSB1c2VkIHRvIHRyaWdnZXJcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBpbnRlcm5hbEV2ZW50cztcbihmdW5jdGlvbiAoaW50ZXJuYWxFdmVudHMpIHtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYWZ0ZXIgZXhoYXVzdGluZyBhbGwgYXZhaWxhYmxlIHJldHJpZXMuIFRoaXMgZXZlbnRcbiAgICAgKiB3aWxsIGNvbnRhaW4gdGhlIG9yaWdpbmFsIGV2ZW50IGFuZCB0aGUgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIGZhaWx1cmUuXG4gICAgICovXG4gICAgaW50ZXJuYWxFdmVudHNbXCJGdW5jdGlvbkZhaWxlZFwiXSA9IFwiaW5uZ2VzdC9mdW5jdGlvbi5mYWlsZWRcIjtcbiAgICBpbnRlcm5hbEV2ZW50c1tcIkZ1bmN0aW9uSW52b2tlZFwiXSA9IFwiaW5uZ2VzdC9mdW5jdGlvbi5pbnZva2VkXCI7XG4gICAgaW50ZXJuYWxFdmVudHNbXCJGdW5jdGlvbkZpbmlzaGVkXCJdID0gXCJpbm5nZXN0L2Z1bmN0aW9uLmZpbmlzaGVkXCI7XG4gICAgaW50ZXJuYWxFdmVudHNbXCJGdW5jdGlvbkNhbmNlbGxlZFwiXSA9IFwiaW5uZ2VzdC9mdW5jdGlvbi5jYW5jZWxsZWRcIjtcbiAgICBpbnRlcm5hbEV2ZW50c1tcIlNjaGVkdWxlZFRpbWVyXCJdID0gXCJpbm5nZXN0L3NjaGVkdWxlZC50aW1lclwiO1xufSkoaW50ZXJuYWxFdmVudHMgfHwgKGV4cG9ydHMuaW50ZXJuYWxFdmVudHMgPSBpbnRlcm5hbEV2ZW50cyA9IHt9KSk7XG5leHBvcnRzLmxvZ1ByZWZpeCA9IGNoYWxrXzEuZGVmYXVsdC5tYWdlbnRhLmJvbGQoXCJbSW5uZ2VzdF1cIik7XG5leHBvcnRzLmRlYnVnUHJlZml4ID0gXCJpbm5nZXN0XCI7XG5leHBvcnRzLmR1bW15RXZlbnRLZXkgPSBcIk5PX0VWRU5UX0tFWV9TRVRcIjtcbnZhciBzZXJ2ZXJLaW5kO1xuKGZ1bmN0aW9uIChzZXJ2ZXJLaW5kKSB7XG4gICAgc2VydmVyS2luZFtcIkRldlwiXSA9IFwiZGV2XCI7XG4gICAgc2VydmVyS2luZFtcIkNsb3VkXCJdID0gXCJjbG91ZFwiO1xufSkoc2VydmVyS2luZCB8fCAoZXhwb3J0cy5zZXJ2ZXJLaW5kID0gc2VydmVyS2luZCA9IHt9KSk7XG52YXIgc3luY0tpbmQ7XG4oZnVuY3Rpb24gKHN5bmNLaW5kKSB7XG4gICAgc3luY0tpbmRbXCJJbkJhbmRcIl0gPSBcImluX2JhbmRcIjtcbiAgICBzeW5jS2luZFtcIk91dE9mQmFuZFwiXSA9IFwib3V0X29mX2JhbmRcIjtcbn0pKHN5bmNLaW5kIHx8IChleHBvcnRzLnN5bmNLaW5kID0gc3luY0tpbmQgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/consts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/crypto.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/crypto.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createEntropy = createEntropy;\n/**\n * Create a cryptographically secure random value.\n *\n * @throws {Error} If the crypto module is not available.\n */\nfunction createEntropy(byteLength) {\n    const bytes = new Uint8Array(byteLength);\n    // https://developer.mozilla.org/en-US/docs/Web/API/Crypto#browser_compatibility\n    const { crypto } = globalThis;\n    if (!crypto) {\n        // This should only happen in Node <19.\n        throw new Error(\"missing crypto module\");\n    }\n    if (!crypto.getRandomValues) {\n        throw new Error(\"missing crypto.getRandomValues\");\n    }\n    crypto.getRandomValues(bytes);\n    return bytes;\n}\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9jcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUVudHJvcHkgPSBjcmVhdGVFbnRyb3B5O1xuLyoqXG4gKiBDcmVhdGUgYSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tIHZhbHVlLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY3J5cHRvIG1vZHVsZSBpcyBub3QgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbnRyb3B5KGJ5dGVMZW5ndGgpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8jYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgY29uc3QgeyBjcnlwdG8gfSA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKCFjcnlwdG8pIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaW4gTm9kZSA8MTkuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY3J5cHRvIG1vZHVsZVwiKTtcbiAgICB9XG4gICAgaWYgKCFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1wiKTtcbiAgICB9XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/devserver.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/helpers/devserver.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.devServerHost = exports.devServerUrl = exports.devServerAvailable = void 0;\nconst consts_js_1 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst env_js_1 = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/**\n * Attempts to contact the dev server, returning a boolean indicating whether or\n * not it was successful.\n *\n * @example devServerUrl(process.env[envKeys.DevServerUrl], \"/your-path\")\n */\nconst devServerAvailable = async (\n/**\n * The host of the dev server. You should pass in an environment variable as\n * this parameter.\n */\nhost = consts_js_1.defaultDevServerHost, \n/**\n * The fetch implementation to use to communicate with the dev server.\n */\nfetch) => {\n    try {\n        const url = (0, exports.devServerUrl)(host, \"/dev\");\n        const result = await fetch(url.toString());\n        await result.json();\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.devServerAvailable = devServerAvailable;\n/**\n * devServerUrl returns a full URL for the given path name.\n *\n * Because Cloudflare/V8 platforms don't allow process.env, you are expected\n * to pass in the host from the dev server env key:\n *\n * @example devServerUrl(processEnv(envKeys.DevServerUrl), \"/your-path\")\n * @example devServerUrl(\"http://localhost:8288/\", \"/your-path\")\n */\nconst devServerUrl = (host = (0, exports.devServerHost)(), pathname = \"\") => {\n    return new URL(pathname, host.includes(\"://\") ? host : `http://${host}`);\n};\nexports.devServerUrl = devServerUrl;\n/**\n * devServerHost exports the development server's domain by inspecting env\n * variables, or returns the default development server URL.\n *\n * This guarantees a specific URL as a string, as opposed to the env export\n * which only returns a value of the env var is set.\n */\nconst devServerHost = () => (0, env_js_1.devServerHost)() || consts_js_1.defaultDevServerHost;\nexports.devServerHost = devServerHost;\n//# sourceMappingURL=devserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2RldnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEI7QUFDekUsb0JBQW9CLG1CQUFPLENBQUMsbUVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9kZXZzZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRldlNlcnZlckhvc3QgPSBleHBvcnRzLmRldlNlcnZlclVybCA9IGV4cG9ydHMuZGV2U2VydmVyQXZhaWxhYmxlID0gdm9pZCAwO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi9jb25zdHMuanNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuL2Vudi5qc1wiKTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gY29udGFjdCB0aGUgZGV2IHNlcnZlciwgcmV0dXJuaW5nIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3JcbiAqIG5vdCBpdCB3YXMgc3VjY2Vzc2Z1bC5cbiAqXG4gKiBAZXhhbXBsZSBkZXZTZXJ2ZXJVcmwocHJvY2Vzcy5lbnZbZW52S2V5cy5EZXZTZXJ2ZXJVcmxdLCBcIi95b3VyLXBhdGhcIilcbiAqL1xuY29uc3QgZGV2U2VydmVyQXZhaWxhYmxlID0gYXN5bmMgKFxuLyoqXG4gKiBUaGUgaG9zdCBvZiB0aGUgZGV2IHNlcnZlci4gWW91IHNob3VsZCBwYXNzIGluIGFuIGVudmlyb25tZW50IHZhcmlhYmxlIGFzXG4gKiB0aGlzIHBhcmFtZXRlci5cbiAqL1xuaG9zdCA9IGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0LCBcbi8qKlxuICogVGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHRvIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBkZXYgc2VydmVyLlxuICovXG5mZXRjaCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9ICgwLCBleHBvcnRzLmRldlNlcnZlclVybCkoaG9zdCwgXCIvZGV2XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSk7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuZGV2U2VydmVyQXZhaWxhYmxlID0gZGV2U2VydmVyQXZhaWxhYmxlO1xuLyoqXG4gKiBkZXZTZXJ2ZXJVcmwgcmV0dXJucyBhIGZ1bGwgVVJMIGZvciB0aGUgZ2l2ZW4gcGF0aCBuYW1lLlxuICpcbiAqIEJlY2F1c2UgQ2xvdWRmbGFyZS9WOCBwbGF0Zm9ybXMgZG9uJ3QgYWxsb3cgcHJvY2Vzcy5lbnYsIHlvdSBhcmUgZXhwZWN0ZWRcbiAqIHRvIHBhc3MgaW4gdGhlIGhvc3QgZnJvbSB0aGUgZGV2IHNlcnZlciBlbnYga2V5OlxuICpcbiAqIEBleGFtcGxlIGRldlNlcnZlclVybChwcm9jZXNzRW52KGVudktleXMuRGV2U2VydmVyVXJsKSwgXCIveW91ci1wYXRoXCIpXG4gKiBAZXhhbXBsZSBkZXZTZXJ2ZXJVcmwoXCJodHRwOi8vbG9jYWxob3N0OjgyODgvXCIsIFwiL3lvdXItcGF0aFwiKVxuICovXG5jb25zdCBkZXZTZXJ2ZXJVcmwgPSAoaG9zdCA9ICgwLCBleHBvcnRzLmRldlNlcnZlckhvc3QpKCksIHBhdGhuYW1lID0gXCJcIikgPT4ge1xuICAgIHJldHVybiBuZXcgVVJMKHBhdGhuYW1lLCBob3N0LmluY2x1ZGVzKFwiOi8vXCIpID8gaG9zdCA6IGBodHRwOi8vJHtob3N0fWApO1xufTtcbmV4cG9ydHMuZGV2U2VydmVyVXJsID0gZGV2U2VydmVyVXJsO1xuLyoqXG4gKiBkZXZTZXJ2ZXJIb3N0IGV4cG9ydHMgdGhlIGRldmVsb3BtZW50IHNlcnZlcidzIGRvbWFpbiBieSBpbnNwZWN0aW5nIGVudlxuICogdmFyaWFibGVzLCBvciByZXR1cm5zIHRoZSBkZWZhdWx0IGRldmVsb3BtZW50IHNlcnZlciBVUkwuXG4gKlxuICogVGhpcyBndWFyYW50ZWVzIGEgc3BlY2lmaWMgVVJMIGFzIGEgc3RyaW5nLCBhcyBvcHBvc2VkIHRvIHRoZSBlbnYgZXhwb3J0XG4gKiB3aGljaCBvbmx5IHJldHVybnMgYSB2YWx1ZSBvZiB0aGUgZW52IHZhciBpcyBzZXQuXG4gKi9cbmNvbnN0IGRldlNlcnZlckhvc3QgPSAoKSA9PiAoMCwgZW52X2pzXzEuZGV2U2VydmVySG9zdCkoKSB8fCBjb25zdHNfanNfMS5kZWZhdWx0RGV2U2VydmVySG9zdDtcbmV4cG9ydHMuZGV2U2VydmVySG9zdCA9IGRldlNlcnZlckhvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXZzZXJ2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/devserver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/enum.js":
/*!**********************************************!*\
  !*** ./node_modules/inngest/helpers/enum.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumFromValue = void 0;\n/**\n * Returns the value of an enum from a string value.\n *\n * If the value given is not a value from the enum, `undefined` is returned.\n */\nconst enumFromValue = (enumType, value) => {\n    if (Object.values(enumType).includes(value)) {\n        return value;\n    }\n};\nexports.enumFromValue = enumFromValue;\n//# sourceMappingURL=enum.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2VudW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvZW51bS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW51bUZyb21WYWx1ZSA9IHZvaWQgMDtcbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYW4gZW51bSBmcm9tIGEgc3RyaW5nIHZhbHVlLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBnaXZlbiBpcyBub3QgYSB2YWx1ZSBmcm9tIHRoZSBlbnVtLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAqL1xuY29uc3QgZW51bUZyb21WYWx1ZSA9IChlbnVtVHlwZSwgdmFsdWUpID0+IHtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhlbnVtVHlwZSkuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0cy5lbnVtRnJvbVZhbHVlID0gZW51bUZyb21WYWx1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW0uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/enum.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/env.js":
/*!*********************************************!*\
  !*** ./node_modules/inngest/helpers/env.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// This file exists to help normalize process.env amongst the backend\n// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin\n// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`\n// string in order to read variables.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseAsBoolean = exports.getResponse = exports.getFetch = exports.platformSupportsStreaming = exports.getPlatformName = exports.inngestHeaders = exports.allProcessEnv = exports.processEnv = exports.getEnvironmentName = exports.getMode = exports.Mode = exports.devServerHost = void 0;\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst consts_js_1 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/**\n * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL\n * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).\n *\n * If not found this returns undefined, indicating that the env var has not been set.\n *\n * @example devServerHost()\n */\nconst devServerHost = (env = (0, exports.allProcessEnv)()) => {\n    // devServerKeys are the env keys we search for to discover the dev server\n    // URL.  This includes the standard key first, then includes prefixed keys\n    // for use within common frameworks (eg. CRA, next).\n    //\n    // We have to fully write these using process.env as they're typically\n    // processed using webpack's DefinePlugin, which is dumb and does a straight\n    // text replacement instead of actually understanding the AST, despite webpack\n    // being fully capable of understanding the AST.\n    const prefixes = [\"REACT_APP_\", \"NEXT_PUBLIC_\"];\n    const keys = [consts_js_1.envKeys.InngestBaseUrl, consts_js_1.envKeys.InngestDevMode];\n    const values = keys.flatMap((key) => {\n        return prefixes.map((prefix) => {\n            return env[prefix + key];\n        });\n    });\n    return values.find((v) => {\n        if (!v) {\n            return;\n        }\n        try {\n            return Boolean(new URL(v));\n        }\n        catch (_a) {\n            // no-op\n        }\n    });\n};\nexports.devServerHost = devServerHost;\nconst checkFns = ((checks) => checks)({\n    equals: (actual, expected) => actual === expected,\n    \"starts with\": (actual, expected) => { var _a; return expected ? (_a = actual === null || actual === void 0 ? void 0 : actual.startsWith(expected)) !== null && _a !== void 0 ? _a : false : false; },\n    \"is truthy\": (actual) => Boolean(actual),\n    \"is truthy but not\": (actual, expected) => Boolean(actual) && actual !== expected,\n});\nconst prodChecks = [\n    [\"CF_PAGES\", \"equals\", \"1\"],\n    [\"CONTEXT\", \"starts with\", \"prod\"],\n    [\"ENVIRONMENT\", \"starts with\", \"prod\"],\n    [\"NODE_ENV\", \"starts with\", \"prod\"],\n    [\"VERCEL_ENV\", \"starts with\", \"prod\"],\n    [\"DENO_DEPLOYMENT_ID\", \"is truthy\"],\n    [consts_js_1.envKeys.VercelEnvKey, \"is truthy but not\", \"development\"],\n    [consts_js_1.envKeys.IsNetlify, \"is truthy\"],\n    [consts_js_1.envKeys.IsRender, \"is truthy\"],\n    [consts_js_1.envKeys.RailwayBranch, \"is truthy\"],\n    [consts_js_1.envKeys.IsCloudflarePages, \"is truthy\"],\n];\nclass Mode {\n    constructor({ type, isExplicit, explicitDevUrl, env = (0, exports.allProcessEnv)(), }) {\n        this.env = env;\n        this.type = type;\n        this.isExplicit = isExplicit || Boolean(explicitDevUrl);\n        this.explicitDevUrl = explicitDevUrl;\n    }\n    get isDev() {\n        return this.type === \"dev\";\n    }\n    get isCloud() {\n        return this.type === \"cloud\";\n    }\n    get isInferred() {\n        return !this.isExplicit;\n    }\n    /**\n     * If we are explicitly in a particular mode, retrieve the URL that we are\n     * sure we should be using, not considering any environment variables or other\n     * influences.\n     */\n    getExplicitUrl(defaultCloudUrl) {\n        if (!this.isExplicit) {\n            return undefined;\n        }\n        if (this.explicitDevUrl) {\n            return this.explicitDevUrl.href;\n        }\n        if (this.isCloud) {\n            return defaultCloudUrl;\n        }\n        if (this.isDev) {\n            return consts_js_1.defaultDevServerHost;\n        }\n        return undefined;\n    }\n}\nexports.Mode = Mode;\n/**\n * Returns the mode of the current environment, based off of either passed\n * environment variables or `process.env`, or explicit settings.\n */\nconst getMode = ({ env = (0, exports.allProcessEnv)(), client, explicitMode, } = {}) => {\n    if (explicitMode) {\n        return new Mode({ type: explicitMode, isExplicit: true, env });\n    }\n    if (client === null || client === void 0 ? void 0 : client[\"mode\"].isExplicit) {\n        return client[\"mode\"];\n    }\n    if (consts_js_1.envKeys.InngestDevMode in env) {\n        if (typeof env[consts_js_1.envKeys.InngestDevMode] === \"string\") {\n            try {\n                const explicitDevUrl = new URL(env[consts_js_1.envKeys.InngestDevMode]);\n                return new Mode({ type: \"dev\", isExplicit: true, explicitDevUrl, env });\n            }\n            catch (_a) {\n                // no-op\n            }\n        }\n        const envIsDev = (0, exports.parseAsBoolean)(env[consts_js_1.envKeys.InngestDevMode]);\n        if (typeof envIsDev === \"boolean\") {\n            return new Mode({\n                type: envIsDev ? \"dev\" : \"cloud\",\n                isExplicit: true,\n                env,\n            });\n        }\n    }\n    const isProd = prodChecks.some(([key, checkKey, expected]) => {\n        return checkFns[checkKey]((0, strings_js_1.stringifyUnknown)(env[key]), expected);\n    });\n    return new Mode({ type: isProd ? \"cloud\" : \"dev\", isExplicit: false, env });\n};\nexports.getMode = getMode;\n/**\n * getEnvironmentName returns the suspected branch name for this environment by\n * searching through a set of common environment variables.\n *\n * This could be used to determine if we're on a branch deploy or not, though it\n * should be noted that we don't know if this is the default branch or not.\n */\nconst getEnvironmentName = (env = (0, exports.allProcessEnv)()) => {\n    /**\n     * Order is important; more than one of these env vars may be set, so ensure\n     * that we check the most specific, most reliable env vars first.\n     */\n    return (env[consts_js_1.envKeys.InngestEnvironment] ||\n        env[consts_js_1.envKeys.BranchName] ||\n        env[consts_js_1.envKeys.VercelBranch] ||\n        env[consts_js_1.envKeys.NetlifyBranch] ||\n        env[consts_js_1.envKeys.CloudflarePagesBranch] ||\n        env[consts_js_1.envKeys.RenderBranch] ||\n        env[consts_js_1.envKeys.RailwayBranch]);\n};\nexports.getEnvironmentName = getEnvironmentName;\nconst processEnv = (key) => {\n    return (0, exports.allProcessEnv)()[key];\n};\nexports.processEnv = processEnv;\n/**\n * allProcessEnv returns the current process environment variables, or an empty\n * object if they cannot be read, making sure we support environments other than\n * Node such as Deno, too.\n *\n * Using this ensures we don't dangerously access `process.env` in environments\n * where it may not be defined, such as Deno or the browser.\n */\nconst allProcessEnv = () => {\n    // Node, or Node-like environments\n    try {\n        // eslint-disable-next-line @inngest/internal/process-warn\n        if (process.env) {\n            // eslint-disable-next-line @inngest/internal/process-warn\n            return process.env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    // Deno\n    try {\n        const env = Deno.env.toObject();\n        if (env) {\n            return env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    // Netlify\n    try {\n        const env = Netlify.env.toObject();\n        if (env) {\n            return env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    return {};\n};\nexports.allProcessEnv = allProcessEnv;\n/**\n * Generate a standardised set of headers based on input and environment\n * variables.\n *\n *\n */\nconst inngestHeaders = (opts) => {\n    var _a;\n    const sdkVersion = `inngest-js:v${version_js_1.version}`;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": sdkVersion,\n        [consts_js_1.headerKeys.SdkVersion]: sdkVersion,\n    };\n    if (opts === null || opts === void 0 ? void 0 : opts.framework) {\n        headers[consts_js_1.headerKeys.Framework] = opts.framework;\n    }\n    if (opts === null || opts === void 0 ? void 0 : opts.expectedServerKind) {\n        headers[consts_js_1.headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;\n    }\n    const env = Object.assign(Object.assign({}, (0, exports.allProcessEnv)()), opts === null || opts === void 0 ? void 0 : opts.env);\n    const inngestEnv = (opts === null || opts === void 0 ? void 0 : opts.inngestEnv) || (0, exports.getEnvironmentName)(env);\n    if (inngestEnv) {\n        headers[consts_js_1.headerKeys.Environment] = inngestEnv;\n    }\n    const platform = (0, exports.getPlatformName)(env);\n    if (platform) {\n        headers[consts_js_1.headerKeys.Platform] = platform;\n    }\n    return Object.assign(Object.assign(Object.assign({}, headers), (_a = opts === null || opts === void 0 ? void 0 : opts.client) === null || _a === void 0 ? void 0 : _a[\"headers\"]), opts === null || opts === void 0 ? void 0 : opts.extras);\n};\nexports.inngestHeaders = inngestHeaders;\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment is running on the platform with the given name.\n */\nconst platformChecks = {\n    /**\n     * Vercel Edge Functions don't have access to environment variables unless\n     * they are explicitly referenced in the top level code, but they do have a\n     * global `EdgeRuntime` variable set that we can use to detect this.\n     */\n    vercel: (env) => env[consts_js_1.envKeys.IsVercel] === \"1\" || typeof EdgeRuntime === \"string\",\n    netlify: (env) => env[consts_js_1.envKeys.IsNetlify] === \"true\",\n    \"cloudflare-pages\": (env) => env[consts_js_1.envKeys.IsCloudflarePages] === \"1\",\n    render: (env) => env[consts_js_1.envKeys.IsRender] === \"true\",\n    railway: (env) => Boolean(env[consts_js_1.envKeys.RailwayEnvironment]),\n};\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment and platform supports streaming responses back to Inngest.\n *\n * Streaming capability is both framework and platform-based. Frameworks are\n * supported in serve handlers, and platforms are checked here.\n *\n * As such, this record declares which platforms we explicitly support for\n * streaming and is used by {@link platformSupportsStreaming}.\n */\nconst streamingChecks = {\n    /**\n     * \"Vercel supports streaming for Serverless Functions, Edge Functions, and\n     * React Server Components in Next.js projects.\"\n     *\n     * In practice, however, there are many reports of streaming not working as\n     * expected on Serverless Functions, so we resort to only allowing streaming\n     * for Edge Functions here.\n     *\n     * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}\n     */\n    vercel: (_framework, _env) => typeof EdgeRuntime === \"string\",\n    \"cloudflare-pages\": () => true,\n};\nconst getPlatformName = (env) => {\n    return Object.keys(platformChecks).find((key) => {\n        return platformChecks[key](env);\n    });\n};\nexports.getPlatformName = getPlatformName;\n/**\n * Returns `true` if we believe the current environment supports streaming\n * responses back to Inngest.\n *\n * We run a check directly related to the platform we believe we're running on,\n * usually based on environment variables.\n */\nconst platformSupportsStreaming = (framework, env = (0, exports.allProcessEnv)()) => {\n    var _a, _b;\n    return ((_b = (_a = streamingChecks[(0, exports.getPlatformName)(env)]) === null || _a === void 0 ? void 0 : _a.call(streamingChecks, framework, env)) !== null && _b !== void 0 ? _b : false);\n};\nexports.platformSupportsStreaming = platformSupportsStreaming;\n/**\n * A unique symbol used to mark a custom fetch implementation. We wrap the\n * implementations to provide some extra control when handling errors.\n */\nconst CUSTOM_FETCH_MARKER = Symbol(\"Custom fetch implementation\");\n/**\n * Given a potential fetch function, return the fetch function to use based on\n * this and the environment.\n */\nconst getFetch = (givenFetch) => {\n    /**\n     * If we've explicitly been given a fetch function, use that.\n     */\n    if (givenFetch) {\n        if (CUSTOM_FETCH_MARKER in givenFetch) {\n            return givenFetch;\n        }\n        /**\n         * We wrap the given fetch function to provide some extra control when\n         * handling errors.\n         */\n        const customFetch = async (...args) => {\n            var _a;\n            try {\n                return await givenFetch(...args);\n            }\n            catch (err) {\n                /**\n                 * Capture warnings that are not simple fetch failures and highlight\n                 * them for the user.\n                 *\n                 * We also use this opportunity to log the causing error, as code higher\n                 * up the stack will likely abstract this.\n                 */\n                if (!(err instanceof Error) ||\n                    !((_a = err.message) === null || _a === void 0 ? void 0 : _a.startsWith(\"fetch failed\"))) {\n                    console.warn(\"A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.\");\n                    console.error(err);\n                }\n                throw err;\n            }\n        };\n        /**\n         * Mark the custom fetch implementation so that we can identify it later, in\n         * addition to adding some runtime properties to it to make it seem as much\n         * like the original fetch as possible.\n         */\n        Object.defineProperties(customFetch, {\n            [CUSTOM_FETCH_MARKER]: {},\n            name: { value: givenFetch.name },\n            length: { value: givenFetch.length },\n        });\n        return customFetch;\n    }\n    /**\n     * Browser or Node 18+\n     */\n    try {\n        if (typeof globalThis !== \"undefined\" && \"fetch\" in globalThis) {\n            return fetch.bind(globalThis);\n        }\n    }\n    catch (err) {\n        // no-op\n    }\n    /**\n     * Existing polyfilled fetch\n     */\n    if (typeof fetch !== \"undefined\") {\n        return fetch;\n    }\n    /**\n     * Environments where fetch cannot be found and must be polyfilled\n     */\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return __webpack_require__(/*! cross-fetch */ \"(rsc)/./node_modules/cross-fetch/dist/node-ponyfill.js\");\n};\nexports.getFetch = getFetch;\n/**\n * If `Response` isn't included in this environment, it's probably an earlier\n * Node env that isn't already polyfilling. This function returns either the\n * native `Response` or a polyfilled one.\n */\nconst getResponse = () => {\n    if (typeof Response !== \"undefined\") {\n        return Response;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-var-requires\n    return (__webpack_require__(/*! cross-fetch */ \"(rsc)/./node_modules/cross-fetch/dist/node-ponyfill.js\").Response);\n};\nexports.getResponse = getResponse;\n/**\n * Given an unknown value, try to parse it as a `boolean`. Useful for parsing\n * environment variables that could be a selection of different values such as\n * `\"true\"`, `\"1\"`.\n *\n * If the value could not be confidently parsed as a `boolean` or was seen to be\n * `undefined`, this function returns `undefined`.\n */\nconst parseAsBoolean = (value) => {\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return Boolean(value);\n    }\n    if (typeof value === \"string\") {\n        const trimmed = value.trim().toLowerCase();\n        if (trimmed === \"undefined\") {\n            return undefined;\n        }\n        if ([\"true\", \"1\"].includes(trimmed)) {\n            return true;\n        }\n        return false;\n    }\n    return undefined;\n};\nexports.parseAsBoolean = parseAsBoolean;\n//# sourceMappingURL=env.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vudi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLGlDQUFpQyxHQUFHLHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcscUJBQXFCO0FBQ3pSLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFlO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLHFFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsc0pBQXNKO0FBQ3pNO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RUFBdUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBNEQsSUFBSTtBQUNuRjtBQUNBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBb0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0Isd0RBQXdEO0FBQzlFO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsb0JBQW9CLHdCQUF3QjtBQUM1QyxzQkFBc0IsMEJBQTBCO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLDJFQUFhO0FBQ2hDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyR0FBK0I7QUFDMUM7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvZW52LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gVGhpcyBmaWxlIGV4aXN0cyB0byBoZWxwIG5vcm1hbGl6ZSBwcm9jZXNzLmVudiBhbW9uZ3N0IHRoZSBiYWNrZW5kXG4vLyBhbmQgZnJvbnRlbmQuICBNYW55IGZyb250ZW5kcyAoZWcuIE5leHQsIENSQSkgdXRpbGl6ZSB3ZWJwYWNrJ3MgRGVmaW5lUGx1Z2luXG4vLyBhbG9uZyB3aXRoIHByZWZpeGVzLCBtZWFuaW5nIHdlIGhhdmUgdG8gZXhwbGljaXRseSB1c2UgdGhlIGZ1bGwgYHByb2Nlc3MuZW52LkZPT2Bcbi8vIHN0cmluZyBpbiBvcmRlciB0byByZWFkIHZhcmlhYmxlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VBc0Jvb2xlYW4gPSBleHBvcnRzLmdldFJlc3BvbnNlID0gZXhwb3J0cy5nZXRGZXRjaCA9IGV4cG9ydHMucGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZyA9IGV4cG9ydHMuZ2V0UGxhdGZvcm1OYW1lID0gZXhwb3J0cy5pbm5nZXN0SGVhZGVycyA9IGV4cG9ydHMuYWxsUHJvY2Vzc0VudiA9IGV4cG9ydHMucHJvY2Vzc0VudiA9IGV4cG9ydHMuZ2V0RW52aXJvbm1lbnROYW1lID0gZXhwb3J0cy5nZXRNb2RlID0gZXhwb3J0cy5Nb2RlID0gZXhwb3J0cy5kZXZTZXJ2ZXJIb3N0ID0gdm9pZCAwO1xuY29uc3QgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL3ZlcnNpb24uanNcIik7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0cy5qc1wiKTtcbmNvbnN0IHN0cmluZ3NfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ3MuanNcIik7XG4vKipcbiAqIGRldlNlcnZlckhvc3QgcmV0dXJucyB0aGUgZGV2IHNlcnZlciBob3N0IGJ5IHNlYXJjaGluZyBmb3IgdGhlIElOTkdFU1RfREVWU0VSVkVSX1VSTFxuICogZW52aXJvbm1lbnQgdmFyaWFibGUgKHBsdXMgcHJvamVjdCBwcmVmaXhjZXMgZm9yIGVnLiByZWFjdCwgc3VjaCBhcyBSRUFDVF9BUFBfSU5OR0VTVF9ERVZTRVJWRVJfVVJMKS5cbiAqXG4gKiBJZiBub3QgZm91bmQgdGhpcyByZXR1cm5zIHVuZGVmaW5lZCwgaW5kaWNhdGluZyB0aGF0IHRoZSBlbnYgdmFyIGhhcyBub3QgYmVlbiBzZXQuXG4gKlxuICogQGV4YW1wbGUgZGV2U2VydmVySG9zdCgpXG4gKi9cbmNvbnN0IGRldlNlcnZlckhvc3QgPSAoZW52ID0gKDAsIGV4cG9ydHMuYWxsUHJvY2Vzc0VudikoKSkgPT4ge1xuICAgIC8vIGRldlNlcnZlcktleXMgYXJlIHRoZSBlbnYga2V5cyB3ZSBzZWFyY2ggZm9yIHRvIGRpc2NvdmVyIHRoZSBkZXYgc2VydmVyXG4gICAgLy8gVVJMLiAgVGhpcyBpbmNsdWRlcyB0aGUgc3RhbmRhcmQga2V5IGZpcnN0LCB0aGVuIGluY2x1ZGVzIHByZWZpeGVkIGtleXNcbiAgICAvLyBmb3IgdXNlIHdpdGhpbiBjb21tb24gZnJhbWV3b3JrcyAoZWcuIENSQSwgbmV4dCkuXG4gICAgLy9cbiAgICAvLyBXZSBoYXZlIHRvIGZ1bGx5IHdyaXRlIHRoZXNlIHVzaW5nIHByb2Nlc3MuZW52IGFzIHRoZXkncmUgdHlwaWNhbGx5XG4gICAgLy8gcHJvY2Vzc2VkIHVzaW5nIHdlYnBhY2sncyBEZWZpbmVQbHVnaW4sIHdoaWNoIGlzIGR1bWIgYW5kIGRvZXMgYSBzdHJhaWdodFxuICAgIC8vIHRleHQgcmVwbGFjZW1lbnQgaW5zdGVhZCBvZiBhY3R1YWxseSB1bmRlcnN0YW5kaW5nIHRoZSBBU1QsIGRlc3BpdGUgd2VicGFja1xuICAgIC8vIGJlaW5nIGZ1bGx5IGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZyB0aGUgQVNULlxuICAgIGNvbnN0IHByZWZpeGVzID0gW1wiUkVBQ1RfQVBQX1wiLCBcIk5FWFRfUFVCTElDX1wiXTtcbiAgICBjb25zdCBrZXlzID0gW2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEJhc2VVcmwsIGNvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdERldk1vZGVdO1xuICAgIGNvbnN0IHZhbHVlcyA9IGtleXMuZmxhdE1hcCgoa2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBwcmVmaXhlcy5tYXAoKHByZWZpeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVudltwcmVmaXggKyBrZXldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzLmZpbmQoKHYpID0+IHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG5ldyBVUkwodikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuZGV2U2VydmVySG9zdCA9IGRldlNlcnZlckhvc3Q7XG5jb25zdCBjaGVja0ZucyA9ICgoY2hlY2tzKSA9PiBjaGVja3MpKHtcbiAgICBlcXVhbHM6IChhY3R1YWwsIGV4cGVjdGVkKSA9PiBhY3R1YWwgPT09IGV4cGVjdGVkLFxuICAgIFwic3RhcnRzIHdpdGhcIjogKGFjdHVhbCwgZXhwZWN0ZWQpID0+IHsgdmFyIF9hOyByZXR1cm4gZXhwZWN0ZWQgPyAoX2EgPSBhY3R1YWwgPT09IG51bGwgfHwgYWN0dWFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3R1YWwuc3RhcnRzV2l0aChleHBlY3RlZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlIDogZmFsc2U7IH0sXG4gICAgXCJpcyB0cnV0aHlcIjogKGFjdHVhbCkgPT4gQm9vbGVhbihhY3R1YWwpLFxuICAgIFwiaXMgdHJ1dGh5IGJ1dCBub3RcIjogKGFjdHVhbCwgZXhwZWN0ZWQpID0+IEJvb2xlYW4oYWN0dWFsKSAmJiBhY3R1YWwgIT09IGV4cGVjdGVkLFxufSk7XG5jb25zdCBwcm9kQ2hlY2tzID0gW1xuICAgIFtcIkNGX1BBR0VTXCIsIFwiZXF1YWxzXCIsIFwiMVwiXSxcbiAgICBbXCJDT05URVhUXCIsIFwic3RhcnRzIHdpdGhcIiwgXCJwcm9kXCJdLFxuICAgIFtcIkVOVklST05NRU5UXCIsIFwic3RhcnRzIHdpdGhcIiwgXCJwcm9kXCJdLFxuICAgIFtcIk5PREVfRU5WXCIsIFwic3RhcnRzIHdpdGhcIiwgXCJwcm9kXCJdLFxuICAgIFtcIlZFUkNFTF9FTlZcIiwgXCJzdGFydHMgd2l0aFwiLCBcInByb2RcIl0sXG4gICAgW1wiREVOT19ERVBMT1lNRU5UX0lEXCIsIFwiaXMgdHJ1dGh5XCJdLFxuICAgIFtjb25zdHNfanNfMS5lbnZLZXlzLlZlcmNlbEVudktleSwgXCJpcyB0cnV0aHkgYnV0IG5vdFwiLCBcImRldmVsb3BtZW50XCJdLFxuICAgIFtjb25zdHNfanNfMS5lbnZLZXlzLklzTmV0bGlmeSwgXCJpcyB0cnV0aHlcIl0sXG4gICAgW2NvbnN0c19qc18xLmVudktleXMuSXNSZW5kZXIsIFwiaXMgdHJ1dGh5XCJdLFxuICAgIFtjb25zdHNfanNfMS5lbnZLZXlzLlJhaWx3YXlCcmFuY2gsIFwiaXMgdHJ1dGh5XCJdLFxuICAgIFtjb25zdHNfanNfMS5lbnZLZXlzLklzQ2xvdWRmbGFyZVBhZ2VzLCBcImlzIHRydXRoeVwiXSxcbl07XG5jbGFzcyBNb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHR5cGUsIGlzRXhwbGljaXQsIGV4cGxpY2l0RGV2VXJsLCBlbnYgPSAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpLCB9KSB7XG4gICAgICAgIHRoaXMuZW52ID0gZW52O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmlzRXhwbGljaXQgPSBpc0V4cGxpY2l0IHx8IEJvb2xlYW4oZXhwbGljaXREZXZVcmwpO1xuICAgICAgICB0aGlzLmV4cGxpY2l0RGV2VXJsID0gZXhwbGljaXREZXZVcmw7XG4gICAgfVxuICAgIGdldCBpc0RldigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJkZXZcIjtcbiAgICB9XG4gICAgZ2V0IGlzQ2xvdWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiY2xvdWRcIjtcbiAgICB9XG4gICAgZ2V0IGlzSW5mZXJyZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0V4cGxpY2l0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBhcmUgZXhwbGljaXRseSBpbiBhIHBhcnRpY3VsYXIgbW9kZSwgcmV0cmlldmUgdGhlIFVSTCB0aGF0IHdlIGFyZVxuICAgICAqIHN1cmUgd2Ugc2hvdWxkIGJlIHVzaW5nLCBub3QgY29uc2lkZXJpbmcgYW55IGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBvdGhlclxuICAgICAqIGluZmx1ZW5jZXMuXG4gICAgICovXG4gICAgZ2V0RXhwbGljaXRVcmwoZGVmYXVsdENsb3VkVXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0V4cGxpY2l0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4cGxpY2l0RGV2VXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBsaWNpdERldlVybC5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvdWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q2xvdWRVcmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zdHNfanNfMS5kZWZhdWx0RGV2U2VydmVySG9zdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuTW9kZSA9IE1vZGU7XG4vKipcbiAqIFJldHVybnMgdGhlIG1vZGUgb2YgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQsIGJhc2VkIG9mZiBvZiBlaXRoZXIgcGFzc2VkXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb3IgYHByb2Nlc3MuZW52YCwgb3IgZXhwbGljaXQgc2V0dGluZ3MuXG4gKi9cbmNvbnN0IGdldE1vZGUgPSAoeyBlbnYgPSAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpLCBjbGllbnQsIGV4cGxpY2l0TW9kZSwgfSA9IHt9KSA9PiB7XG4gICAgaWYgKGV4cGxpY2l0TW9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vZGUoeyB0eXBlOiBleHBsaWNpdE1vZGUsIGlzRXhwbGljaXQ6IHRydWUsIGVudiB9KTtcbiAgICB9XG4gICAgaWYgKGNsaWVudCA9PT0gbnVsbCB8fCBjbGllbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaWVudFtcIm1vZGVcIl0uaXNFeHBsaWNpdCkge1xuICAgICAgICByZXR1cm4gY2xpZW50W1wibW9kZVwiXTtcbiAgICB9XG4gICAgaWYgKGNvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdERldk1vZGUgaW4gZW52KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdERldk1vZGVdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGxpY2l0RGV2VXJsID0gbmV3IFVSTChlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RGV2TW9kZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZSh7IHR5cGU6IFwiZGV2XCIsIGlzRXhwbGljaXQ6IHRydWUsIGV4cGxpY2l0RGV2VXJsLCBlbnYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudklzRGV2ID0gKDAsIGV4cG9ydHMucGFyc2VBc0Jvb2xlYW4pKGVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3REZXZNb2RlXSk7XG4gICAgICAgIGlmICh0eXBlb2YgZW52SXNEZXYgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudklzRGV2ID8gXCJkZXZcIiA6IFwiY2xvdWRcIixcbiAgICAgICAgICAgICAgICBpc0V4cGxpY2l0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzUHJvZCA9IHByb2RDaGVja3Muc29tZSgoW2tleSwgY2hlY2tLZXksIGV4cGVjdGVkXSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hlY2tGbnNbY2hlY2tLZXldKCgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5VW5rbm93bikoZW52W2tleV0pLCBleHBlY3RlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNb2RlKHsgdHlwZTogaXNQcm9kID8gXCJjbG91ZFwiIDogXCJkZXZcIiwgaXNFeHBsaWNpdDogZmFsc2UsIGVudiB9KTtcbn07XG5leHBvcnRzLmdldE1vZGUgPSBnZXRNb2RlO1xuLyoqXG4gKiBnZXRFbnZpcm9ubWVudE5hbWUgcmV0dXJucyB0aGUgc3VzcGVjdGVkIGJyYW5jaCBuYW1lIGZvciB0aGlzIGVudmlyb25tZW50IGJ5XG4gKiBzZWFyY2hpbmcgdGhyb3VnaCBhIHNldCBvZiBjb21tb24gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqIFRoaXMgY291bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UncmUgb24gYSBicmFuY2ggZGVwbG95IG9yIG5vdCwgdGhvdWdoIGl0XG4gKiBzaG91bGQgYmUgbm90ZWQgdGhhdCB3ZSBkb24ndCBrbm93IGlmIHRoaXMgaXMgdGhlIGRlZmF1bHQgYnJhbmNoIG9yIG5vdC5cbiAqL1xuY29uc3QgZ2V0RW52aXJvbm1lbnROYW1lID0gKGVudiA9ICgwLCBleHBvcnRzLmFsbFByb2Nlc3NFbnYpKCkpID0+IHtcbiAgICAvKipcbiAgICAgKiBPcmRlciBpcyBpbXBvcnRhbnQ7IG1vcmUgdGhhbiBvbmUgb2YgdGhlc2UgZW52IHZhcnMgbWF5IGJlIHNldCwgc28gZW5zdXJlXG4gICAgICogdGhhdCB3ZSBjaGVjayB0aGUgbW9zdCBzcGVjaWZpYywgbW9zdCByZWxpYWJsZSBlbnYgdmFycyBmaXJzdC5cbiAgICAgKi9cbiAgICByZXR1cm4gKGVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RFbnZpcm9ubWVudF0gfHxcbiAgICAgICAgZW52W2NvbnN0c19qc18xLmVudktleXMuQnJhbmNoTmFtZV0gfHxcbiAgICAgICAgZW52W2NvbnN0c19qc18xLmVudktleXMuVmVyY2VsQnJhbmNoXSB8fFxuICAgICAgICBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5OZXRsaWZ5QnJhbmNoXSB8fFxuICAgICAgICBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5DbG91ZGZsYXJlUGFnZXNCcmFuY2hdIHx8XG4gICAgICAgIGVudltjb25zdHNfanNfMS5lbnZLZXlzLlJlbmRlckJyYW5jaF0gfHxcbiAgICAgICAgZW52W2NvbnN0c19qc18xLmVudktleXMuUmFpbHdheUJyYW5jaF0pO1xufTtcbmV4cG9ydHMuZ2V0RW52aXJvbm1lbnROYW1lID0gZ2V0RW52aXJvbm1lbnROYW1lO1xuY29uc3QgcHJvY2Vzc0VudiA9IChrZXkpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuYWxsUHJvY2Vzc0VudikoKVtrZXldO1xufTtcbmV4cG9ydHMucHJvY2Vzc0VudiA9IHByb2Nlc3NFbnY7XG4vKipcbiAqIGFsbFByb2Nlc3NFbnYgcmV0dXJucyB0aGUgY3VycmVudCBwcm9jZXNzIGVudmlyb25tZW50IHZhcmlhYmxlcywgb3IgYW4gZW1wdHlcbiAqIG9iamVjdCBpZiB0aGV5IGNhbm5vdCBiZSByZWFkLCBtYWtpbmcgc3VyZSB3ZSBzdXBwb3J0IGVudmlyb25tZW50cyBvdGhlciB0aGFuXG4gKiBOb2RlIHN1Y2ggYXMgRGVubywgdG9vLlxuICpcbiAqIFVzaW5nIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBkYW5nZXJvdXNseSBhY2Nlc3MgYHByb2Nlc3MuZW52YCBpbiBlbnZpcm9ubWVudHNcbiAqIHdoZXJlIGl0IG1heSBub3QgYmUgZGVmaW5lZCwgc3VjaCBhcyBEZW5vIG9yIHRoZSBicm93c2VyLlxuICovXG5jb25zdCBhbGxQcm9jZXNzRW52ID0gKCkgPT4ge1xuICAgIC8vIE5vZGUsIG9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudHNcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGlubmdlc3QvaW50ZXJuYWwvcHJvY2Vzcy13YXJuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBpbm5nZXN0L2ludGVybmFsL3Byb2Nlc3Mtd2FyblxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9XG4gICAgLy8gRGVub1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVudiA9IERlbm8uZW52LnRvT2JqZWN0KCk7XG4gICAgICAgIGlmIChlbnYpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH1cbiAgICAvLyBOZXRsaWZ5XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZW52ID0gTmV0bGlmeS5lbnYudG9PYmplY3QoKTtcbiAgICAgICAgaWYgKGVudikge1xuICAgICAgICAgICAgcmV0dXJuIGVudjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICAvLyBub29wXG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5leHBvcnRzLmFsbFByb2Nlc3NFbnYgPSBhbGxQcm9jZXNzRW52O1xuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YW5kYXJkaXNlZCBzZXQgb2YgaGVhZGVycyBiYXNlZCBvbiBpbnB1dCBhbmQgZW52aXJvbm1lbnRcbiAqIHZhcmlhYmxlcy5cbiAqXG4gKlxuICovXG5jb25zdCBpbm5nZXN0SGVhZGVycyA9IChvcHRzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNka1ZlcnNpb24gPSBgaW5uZ2VzdC1qczp2JHt2ZXJzaW9uX2pzXzEudmVyc2lvbn1gO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIlVzZXItQWdlbnRcIjogc2RrVmVyc2lvbixcbiAgICAgICAgW2NvbnN0c19qc18xLmhlYWRlcktleXMuU2RrVmVyc2lvbl06IHNka1ZlcnNpb24sXG4gICAgfTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZyYW1ld29yaykge1xuICAgICAgICBoZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuRnJhbWV3b3JrXSA9IG9wdHMuZnJhbWV3b3JrO1xuICAgIH1cbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmV4cGVjdGVkU2VydmVyS2luZCkge1xuICAgICAgICBoZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuSW5uZ2VzdEV4cGVjdGVkU2VydmVyS2luZF0gPSBvcHRzLmV4cGVjdGVkU2VydmVyS2luZDtcbiAgICB9XG4gICAgY29uc3QgZW52ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpKSwgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmVudik7XG4gICAgY29uc3QgaW5uZ2VzdEVudiA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuaW5uZ2VzdEVudikgfHwgKDAsIGV4cG9ydHMuZ2V0RW52aXJvbm1lbnROYW1lKShlbnYpO1xuICAgIGlmIChpbm5nZXN0RW52KSB7XG4gICAgICAgIGhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5FbnZpcm9ubWVudF0gPSBpbm5nZXN0RW52O1xuICAgIH1cbiAgICBjb25zdCBwbGF0Zm9ybSA9ICgwLCBleHBvcnRzLmdldFBsYXRmb3JtTmFtZSkoZW52KTtcbiAgICBpZiAocGxhdGZvcm0pIHtcbiAgICAgICAgaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlBsYXRmb3JtXSA9IHBsYXRmb3JtO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMpLCAoX2EgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuY2xpZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbXCJoZWFkZXJzXCJdKSwgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmV4dHJhcyk7XG59O1xuZXhwb3J0cy5pbm5nZXN0SGVhZGVycyA9IGlubmdlc3RIZWFkZXJzO1xuLyoqXG4gKiBBIHNldCBvZiBjaGVja3MgdGhhdCwgZ2l2ZW4gYW4gZW52aXJvbm1lbnQsIHdpbGwgcmV0dXJuIGB0cnVlYCBpZiB0aGUgY3VycmVudFxuICogZW52aXJvbm1lbnQgaXMgcnVubmluZyBvbiB0aGUgcGxhdGZvcm0gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqL1xuY29uc3QgcGxhdGZvcm1DaGVja3MgPSB7XG4gICAgLyoqXG4gICAgICogVmVyY2VsIEVkZ2UgRnVuY3Rpb25zIGRvbid0IGhhdmUgYWNjZXNzIHRvIGVudmlyb25tZW50IHZhcmlhYmxlcyB1bmxlc3NcbiAgICAgKiB0aGV5IGFyZSBleHBsaWNpdGx5IHJlZmVyZW5jZWQgaW4gdGhlIHRvcCBsZXZlbCBjb2RlLCBidXQgdGhleSBkbyBoYXZlIGFcbiAgICAgKiBnbG9iYWwgYEVkZ2VSdW50aW1lYCB2YXJpYWJsZSBzZXQgdGhhdCB3ZSBjYW4gdXNlIHRvIGRldGVjdCB0aGlzLlxuICAgICAqL1xuICAgIHZlcmNlbDogKGVudikgPT4gZW52W2NvbnN0c19qc18xLmVudktleXMuSXNWZXJjZWxdID09PSBcIjFcIiB8fCB0eXBlb2YgRWRnZVJ1bnRpbWUgPT09IFwic3RyaW5nXCIsXG4gICAgbmV0bGlmeTogKGVudikgPT4gZW52W2NvbnN0c19qc18xLmVudktleXMuSXNOZXRsaWZ5XSA9PT0gXCJ0cnVlXCIsXG4gICAgXCJjbG91ZGZsYXJlLXBhZ2VzXCI6IChlbnYpID0+IGVudltjb25zdHNfanNfMS5lbnZLZXlzLklzQ2xvdWRmbGFyZVBhZ2VzXSA9PT0gXCIxXCIsXG4gICAgcmVuZGVyOiAoZW52KSA9PiBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jc1JlbmRlcl0gPT09IFwidHJ1ZVwiLFxuICAgIHJhaWx3YXk6IChlbnYpID0+IEJvb2xlYW4oZW52W2NvbnN0c19qc18xLmVudktleXMuUmFpbHdheUVudmlyb25tZW50XSksXG59O1xuLyoqXG4gKiBBIHNldCBvZiBjaGVja3MgdGhhdCwgZ2l2ZW4gYW4gZW52aXJvbm1lbnQsIHdpbGwgcmV0dXJuIGB0cnVlYCBpZiB0aGUgY3VycmVudFxuICogZW52aXJvbm1lbnQgYW5kIHBsYXRmb3JtIHN1cHBvcnRzIHN0cmVhbWluZyByZXNwb25zZXMgYmFjayB0byBJbm5nZXN0LlxuICpcbiAqIFN0cmVhbWluZyBjYXBhYmlsaXR5IGlzIGJvdGggZnJhbWV3b3JrIGFuZCBwbGF0Zm9ybS1iYXNlZC4gRnJhbWV3b3JrcyBhcmVcbiAqIHN1cHBvcnRlZCBpbiBzZXJ2ZSBoYW5kbGVycywgYW5kIHBsYXRmb3JtcyBhcmUgY2hlY2tlZCBoZXJlLlxuICpcbiAqIEFzIHN1Y2gsIHRoaXMgcmVjb3JkIGRlY2xhcmVzIHdoaWNoIHBsYXRmb3JtcyB3ZSBleHBsaWNpdGx5IHN1cHBvcnQgZm9yXG4gKiBzdHJlYW1pbmcgYW5kIGlzIHVzZWQgYnkge0BsaW5rIHBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmd9LlxuICovXG5jb25zdCBzdHJlYW1pbmdDaGVja3MgPSB7XG4gICAgLyoqXG4gICAgICogXCJWZXJjZWwgc3VwcG9ydHMgc3RyZWFtaW5nIGZvciBTZXJ2ZXJsZXNzIEZ1bmN0aW9ucywgRWRnZSBGdW5jdGlvbnMsIGFuZFxuICAgICAqIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIGluIE5leHQuanMgcHJvamVjdHMuXCJcbiAgICAgKlxuICAgICAqIEluIHByYWN0aWNlLCBob3dldmVyLCB0aGVyZSBhcmUgbWFueSByZXBvcnRzIG9mIHN0cmVhbWluZyBub3Qgd29ya2luZyBhc1xuICAgICAqIGV4cGVjdGVkIG9uIFNlcnZlcmxlc3MgRnVuY3Rpb25zLCBzbyB3ZSByZXNvcnQgdG8gb25seSBhbGxvd2luZyBzdHJlYW1pbmdcbiAgICAgKiBmb3IgRWRnZSBGdW5jdGlvbnMgaGVyZS5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvZnJhbWV3b3Jrcy9uZXh0anMjc3RyZWFtaW5nfVxuICAgICAqL1xuICAgIHZlcmNlbDogKF9mcmFtZXdvcmssIF9lbnYpID0+IHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIixcbiAgICBcImNsb3VkZmxhcmUtcGFnZXNcIjogKCkgPT4gdHJ1ZSxcbn07XG5jb25zdCBnZXRQbGF0Zm9ybU5hbWUgPSAoZW52KSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBsYXRmb3JtQ2hlY2tzKS5maW5kKChrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtQ2hlY2tzW2tleV0oZW52KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldFBsYXRmb3JtTmFtZSA9IGdldFBsYXRmb3JtTmFtZTtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgd2UgYmVsaWV2ZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0cyBzdHJlYW1pbmdcbiAqIHJlc3BvbnNlcyBiYWNrIHRvIElubmdlc3QuXG4gKlxuICogV2UgcnVuIGEgY2hlY2sgZGlyZWN0bHkgcmVsYXRlZCB0byB0aGUgcGxhdGZvcm0gd2UgYmVsaWV2ZSB3ZSdyZSBydW5uaW5nIG9uLFxuICogdXN1YWxseSBiYXNlZCBvbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmNvbnN0IHBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmcgPSAoZnJhbWV3b3JrLCBlbnYgPSAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKChfYiA9IChfYSA9IHN0cmVhbWluZ0NoZWNrc1soMCwgZXhwb3J0cy5nZXRQbGF0Zm9ybU5hbWUpKGVudildKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdHJlYW1pbmdDaGVja3MsIGZyYW1ld29yaywgZW52KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpO1xufTtcbmV4cG9ydHMucGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZyA9IHBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmc7XG4vKipcbiAqIEEgdW5pcXVlIHN5bWJvbCB1c2VkIHRvIG1hcmsgYSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uIFdlIHdyYXAgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbnMgdG8gcHJvdmlkZSBzb21lIGV4dHJhIGNvbnRyb2wgd2hlbiBoYW5kbGluZyBlcnJvcnMuXG4gKi9cbmNvbnN0IENVU1RPTV9GRVRDSF9NQVJLRVIgPSBTeW1ib2woXCJDdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cIik7XG4vKipcbiAqIEdpdmVuIGEgcG90ZW50aWFsIGZldGNoIGZ1bmN0aW9uLCByZXR1cm4gdGhlIGZldGNoIGZ1bmN0aW9uIHRvIHVzZSBiYXNlZCBvblxuICogdGhpcyBhbmQgdGhlIGVudmlyb25tZW50LlxuICovXG5jb25zdCBnZXRGZXRjaCA9IChnaXZlbkZldGNoKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgd2UndmUgZXhwbGljaXRseSBiZWVuIGdpdmVuIGEgZmV0Y2ggZnVuY3Rpb24sIHVzZSB0aGF0LlxuICAgICAqL1xuICAgIGlmIChnaXZlbkZldGNoKSB7XG4gICAgICAgIGlmIChDVVNUT01fRkVUQ0hfTUFSS0VSIGluIGdpdmVuRmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBnaXZlbkZldGNoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSB3cmFwIHRoZSBnaXZlbiBmZXRjaCBmdW5jdGlvbiB0byBwcm92aWRlIHNvbWUgZXh0cmEgY29udHJvbCB3aGVuXG4gICAgICAgICAqIGhhbmRsaW5nIGVycm9ycy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGN1c3RvbUZldGNoID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdpdmVuRmV0Y2goLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2FwdHVyZSB3YXJuaW5ncyB0aGF0IGFyZSBub3Qgc2ltcGxlIGZldGNoIGZhaWx1cmVzIGFuZCBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICAgKiB0aGVtIGZvciB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFdlIGFsc28gdXNlIHRoaXMgb3Bwb3J0dW5pdHkgdG8gbG9nIHRoZSBjYXVzaW5nIGVycm9yLCBhcyBjb2RlIGhpZ2hlclxuICAgICAgICAgICAgICAgICAqIHVwIHRoZSBzdGFjayB3aWxsIGxpa2VseSBhYnN0cmFjdCB0aGlzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSB8fFxuICAgICAgICAgICAgICAgICAgICAhKChfYSA9IGVyci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRzV2l0aChcImZldGNoIGZhaWxlZFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSByZXF1ZXN0IGZhaWxlZCB3aGVuIHVzaW5nIGEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uOyB0aGlzIG1heSBiZSBhIG1pc2NvbmZpZ3VyYXRpb24uIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZmV0Y2ggY2xpZW50IGlzIGNvcnJlY3RseSBib3VuZCB0byB0aGUgZ2xvYmFsIHNjb3BlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIHRoZSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24gc28gdGhhdCB3ZSBjYW4gaWRlbnRpZnkgaXQgbGF0ZXIsIGluXG4gICAgICAgICAqIGFkZGl0aW9uIHRvIGFkZGluZyBzb21lIHJ1bnRpbWUgcHJvcGVydGllcyB0byBpdCB0byBtYWtlIGl0IHNlZW0gYXMgbXVjaFxuICAgICAgICAgKiBsaWtlIHRoZSBvcmlnaW5hbCBmZXRjaCBhcyBwb3NzaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGN1c3RvbUZldGNoLCB7XG4gICAgICAgICAgICBbQ1VTVE9NX0ZFVENIX01BUktFUl06IHt9LFxuICAgICAgICAgICAgbmFtZTogeyB2YWx1ZTogZ2l2ZW5GZXRjaC5uYW1lIH0sXG4gICAgICAgICAgICBsZW5ndGg6IHsgdmFsdWU6IGdpdmVuRmV0Y2gubGVuZ3RoIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VzdG9tRmV0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb3dzZXIgb3IgTm9kZSAxOCtcbiAgICAgKi9cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJmZXRjaFwiIGluIGdsb2JhbFRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gbm8tb3BcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhpc3RpbmcgcG9seWZpbGxlZCBmZXRjaFxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnZpcm9ubWVudHMgd2hlcmUgZmV0Y2ggY2Fubm90IGJlIGZvdW5kIGFuZCBtdXN0IGJlIHBvbHlmaWxsZWRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIHJldHVybiByZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIik7XG59O1xuZXhwb3J0cy5nZXRGZXRjaCA9IGdldEZldGNoO1xuLyoqXG4gKiBJZiBgUmVzcG9uc2VgIGlzbid0IGluY2x1ZGVkIGluIHRoaXMgZW52aXJvbm1lbnQsIGl0J3MgcHJvYmFibHkgYW4gZWFybGllclxuICogTm9kZSBlbnYgdGhhdCBpc24ndCBhbHJlYWR5IHBvbHlmaWxsaW5nLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgZWl0aGVyIHRoZVxuICogbmF0aXZlIGBSZXNwb25zZWAgb3IgYSBwb2x5ZmlsbGVkIG9uZS5cbiAqL1xuY29uc3QgZ2V0UmVzcG9uc2UgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gUmVzcG9uc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgcmV0dXJuIHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKS5SZXNwb25zZTtcbn07XG5leHBvcnRzLmdldFJlc3BvbnNlID0gZ2V0UmVzcG9uc2U7XG4vKipcbiAqIEdpdmVuIGFuIHVua25vd24gdmFsdWUsIHRyeSB0byBwYXJzZSBpdCBhcyBhIGBib29sZWFuYC4gVXNlZnVsIGZvciBwYXJzaW5nXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBjb3VsZCBiZSBhIHNlbGVjdGlvbiBvZiBkaWZmZXJlbnQgdmFsdWVzIHN1Y2ggYXNcbiAqIGBcInRydWVcImAsIGBcIjFcImAuXG4gKlxuICogSWYgdGhlIHZhbHVlIGNvdWxkIG5vdCBiZSBjb25maWRlbnRseSBwYXJzZWQgYXMgYSBgYm9vbGVhbmAgb3Igd2FzIHNlZW4gdG8gYmVcbiAqIGB1bmRlZmluZWRgLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKi9cbmNvbnN0IHBhcnNlQXNCb29sZWFuID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gdmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0cmltbWVkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChbXCJ0cnVlXCIsIFwiMVwiXS5pbmNsdWRlcyh0cmltbWVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMucGFyc2VBc0Jvb2xlYW4gPSBwYXJzZUFzQm9vbGVhbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/errors.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/errors.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.functionStoppedRunningErr = exports.rethrowError = exports.OutgoingResultError = exports.fixEventKeyMissingSteps = exports.prettyError = exports.getErrorMessage = exports.minifyPrettyError = exports.prettyErrorSplitter = exports.ErrCode = exports.deserializeError = exports.isSerializedError = exports.serializeError = void 0;\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ \"(rsc)/./node_modules/chalk/source/index.js\"));\nconst json_stringify_safe_1 = __importDefault(__webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\"));\nconst serialize_error_cjs_1 = __webpack_require__(/*! serialize-error-cjs */ \"(rsc)/./node_modules/serialize-error-cjs/dist/index.js\");\nconst strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ \"(rsc)/./node_modules/strip-ansi/index.js\"));\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../components/NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst SERIALIZED_KEY = \"__serialized\";\nconst SERIALIZED_VALUE = true;\n/**\n * Add first-class support for certain errors that we control, in addition to\n * built-in errors such as `TypeError`.\n *\n * Adding these allows these non-standard errors to be correctly serialized,\n * sent to Inngest, then deserialized back into the correct error type for users\n * to react to correctly.\n *\n * Note that these errors only support `message?: string | undefined` as the\n * input; more custom errors are not supported with this current strategy.\n */\nserialize_error_cjs_1.errorConstructors.set(\"NonRetriableError\", NonRetriableError_js_1.NonRetriableError);\n/**\n * Serialise an error to a serialized JSON string.\n *\n * Errors do not serialise nicely to JSON, so we use this function to convert\n * them to a serialized JSON string. Doing this is also non-trivial for some\n * errors, so we use the `serialize-error` package to do it for us.\n *\n * See {@link https://www.npmjs.com/package/serialize-error}\n *\n * This function is a small wrapper around that package to also add a `type`\n * property to the serialised error, so that we can distinguish between\n * serialised errors and other objects.\n *\n * Will not reserialise existing serialised errors.\n */\nconst serializeError = (\n/**\n * The suspected error to serialize.\n */\nsubject, \n/**\n * If `true` and the error is not serializable, will return the original value\n * as `unknown` instead of coercing it to a serialized error.\n */\nallowUnknown = false) => {\n    try {\n        // Try to understand if this is already done.\n        // Will handle stringified errors.\n        const existingSerializedError = (0, exports.isSerializedError)(subject);\n        if (existingSerializedError) {\n            return existingSerializedError;\n        }\n        if (typeof subject === \"object\" && subject !== null) {\n            // Is an object, so let's try and serialize it.\n            const serializedErr = (0, serialize_error_cjs_1.serializeError)(subject);\n            // Not a proper error was caught, so give us a chance to return `unknown`.\n            if (!serializedErr.name && allowUnknown) {\n                return subject;\n            }\n            // Serialization can succeed but assign no name or message, so we'll\n            // map over the result here to ensure we have everything.\n            // We'll just stringify the entire subject for the message, as this at\n            // least provides some context for the user.\n            const ret = Object.assign(Object.assign({}, serializedErr), { name: serializedErr.name || \"Error\", message: serializedErr.message ||\n                    (0, json_stringify_safe_1.default)(subject) ||\n                    \"Unknown error; error serialization could not find a message.\", stack: serializedErr.stack || \"\", [SERIALIZED_KEY]: SERIALIZED_VALUE });\n            // If we have a cause, make sure we recursively serialize them too. We are\n            // lighter with causes though; attempt to recursively serialize them, but\n            // stop if we find something that doesn't work and just return `unknown`.\n            let target = ret;\n            const maxDepth = 5;\n            for (let i = 0; i < maxDepth; i++) {\n                if (typeof target === \"object\" &&\n                    target !== null &&\n                    \"cause\" in target &&\n                    target.cause) {\n                    target = target.cause = (0, exports.serializeError)(target.cause, true);\n                    continue;\n                }\n                break;\n            }\n            return ret;\n        }\n        // If it's not an object, it's hard to parse this as an Error. In this case,\n        // we'll throw an error to start attempting backup strategies.\n        throw new Error(\"Error is not an object; strange throw value.\");\n    }\n    catch (err) {\n        if (allowUnknown) {\n            // If we are allowed to return unknown, we'll just return the original\n            // value.\n            return subject;\n        }\n        try {\n            // If serialization fails, fall back to a regular Error and use the\n            // original object as the message for an Error. We don't know what this\n            // object looks like, so we can't do anything else with it.\n            return Object.assign(Object.assign({}, (0, exports.serializeError)(new Error(typeof subject === \"string\" ? subject : (0, json_stringify_safe_1.default)(subject)), false)), { \n                // Remove the stack; it's not relevant here\n                stack: \"\", [SERIALIZED_KEY]: SERIALIZED_VALUE });\n        }\n        catch (err) {\n            // If this failed, then stringifying the object also failed, so we'll just\n            // return a completely generic error.\n            // Failing to stringify the object is very unlikely.\n            return {\n                name: \"Could not serialize source error\",\n                message: \"Serializing the source error failed.\",\n                stack: \"\",\n                [SERIALIZED_KEY]: SERIALIZED_VALUE,\n            };\n        }\n    }\n};\nexports.serializeError = serializeError;\n/**\n * Check if an object or a string is a serialised error created by\n * {@link serializeError}.\n */\nconst isSerializedError = (value) => {\n    try {\n        if (typeof value === \"string\") {\n            const parsed = zod_1.z\n                .object({\n                [SERIALIZED_KEY]: zod_1.z.literal(SERIALIZED_VALUE),\n                name: zod_1.z.enum([...Array.from(serialize_error_cjs_1.errorConstructors.keys())]),\n                message: zod_1.z.string(),\n                stack: zod_1.z.string(),\n            })\n                .passthrough()\n                .safeParse(JSON.parse(value));\n            if (parsed.success) {\n                return parsed.data;\n            }\n        }\n        if (typeof value === \"object\" && value !== null) {\n            const objIsSerializedErr = Object.prototype.hasOwnProperty.call(value, SERIALIZED_KEY) &&\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                value[SERIALIZED_KEY] ===\n                    SERIALIZED_VALUE;\n            if (objIsSerializedErr) {\n                return value;\n            }\n        }\n    }\n    catch (_a) {\n        // no-op; we'll return undefined if parsing failed, as it isn't a serialized\n        // error\n    }\n};\nexports.isSerializedError = isSerializedError;\n/**\n * Deserialise an error created by {@link serializeError}.\n *\n * Ensures we only deserialise errors that meet a minimum level of\n * applicability, inclusive of error handling to ensure that badly serialized\n * errors are still handled.\n */\nconst deserializeError = (subject, allowUnknown = false) => {\n    const requiredFields = [\"name\", \"message\"];\n    try {\n        const hasRequiredFields = requiredFields.every((field) => {\n            return Object.prototype.hasOwnProperty.call(subject, field);\n        });\n        if (!hasRequiredFields) {\n            throw new Error();\n        }\n        const deserializedErr = (0, serialize_error_cjs_1.deserializeError)(subject);\n        if (\"cause\" in deserializedErr) {\n            deserializedErr.cause = (0, exports.deserializeError)(deserializedErr.cause, true);\n        }\n        return deserializedErr;\n    }\n    catch (_a) {\n        if (allowUnknown) {\n            // If we are allowed to return unknown, we'll just return the original\n            // value.\n            return subject;\n        }\n        const err = new Error(\"Unknown error; could not reserialize\");\n        /**\n         * Remove the stack so that it's not misleadingly shown as the Inngest\n         * internals.\n         */\n        err.stack = undefined;\n        return err;\n    }\n};\nexports.deserializeError = deserializeError;\nvar ErrCode;\n(function (ErrCode) {\n    ErrCode[\"NESTING_STEPS\"] = \"NESTING_STEPS\";\n    /**\n     * Legacy v0 execution error code for when a function has changed and no\n     * longer matches its in-progress state.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"NON_DETERMINISTIC_FUNCTION\"] = \"NON_DETERMINISTIC_FUNCTION\";\n    /**\n     * Legacy v0 execution error code for when a function is found to be using\n     * async actions after memoziation has occurred, which v0 doesn't support.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"ASYNC_DETECTED_AFTER_MEMOIZATION\"] = \"ASYNC_DETECTED_AFTER_MEMOIZATION\";\n    /**\n     * Legacy v0 execution error code for when a function is found to be using\n     * steps after a non-step async action has occurred.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"STEP_USED_AFTER_ASYNC\"] = \"STEP_USED_AFTER_ASYNC\";\n    ErrCode[\"AUTOMATIC_PARALLEL_INDEXING\"] = \"AUTOMATIC_PARALLEL_INDEXING\";\n})(ErrCode || (exports.ErrCode = ErrCode = {}));\nexports.prettyErrorSplitter = \"=================================================\";\n/**\n * Given an unknown `err`, mutate it to minify any pretty errors that it\n * contains.\n */\nconst minifyPrettyError = (err) => {\n    var _a, _b, _c, _d;\n    try {\n        if (!isError(err)) {\n            return err;\n        }\n        const isPrettyError = err.message.includes(exports.prettyErrorSplitter);\n        if (!isPrettyError) {\n            return err;\n        }\n        const sanitizedMessage = (0, strip_ansi_1.default)(err.message);\n        const message = ((_b = (_a = sanitizedMessage.split(\"  \")[1]) === null || _a === void 0 ? void 0 : _a.split(\"\\n\")[0]) === null || _b === void 0 ? void 0 : _b.trim()) || err.message;\n        const code = ((_d = (_c = sanitizedMessage.split(\"\\n\\nCode: \")[1]) === null || _c === void 0 ? void 0 : _c.split(\"\\n\\n\")[0]) === null || _d === void 0 ? void 0 : _d.trim()) ||\n            undefined;\n        err.message = [code, message].filter(Boolean).join(\" - \");\n        if (err.stack) {\n            const sanitizedStack = (0, strip_ansi_1.default)(err.stack);\n            const stackRest = sanitizedStack\n                .split(`${exports.prettyErrorSplitter}\\n`)\n                .slice(2)\n                .join(\"\\n\");\n            err.stack = `${err.name}: ${err.message}\\n${stackRest}`;\n        }\n        return err;\n    }\n    catch (noopErr) {\n        return err;\n    }\n};\nexports.minifyPrettyError = minifyPrettyError;\n/**\n * Given an `err`, return a boolean representing whether it is in the shape of\n * an `Error` or not.\n */\nconst isError = (err) => {\n    try {\n        if (err instanceof Error) {\n            return true;\n        }\n        const hasName = Object.prototype.hasOwnProperty.call(err, \"name\");\n        const hasMessage = Object.prototype.hasOwnProperty.call(err, \"message\");\n        return hasName && hasMessage;\n    }\n    catch (noopErr) {\n        return false;\n    }\n};\n/**\n * Given an `unknown` object, retrieve the `message` property from it, or fall\n * back to the `fallback` string if it doesn't exist or is empty.\n */\nconst getErrorMessage = (err, fallback) => {\n    const { message } = zod_1.z\n        .object({ message: zod_1.z.string().min(1) })\n        .catch({ message: fallback })\n        .parse(err);\n    return message;\n};\nexports.getErrorMessage = getErrorMessage;\n/**\n * Given a {@link PrettyError}, return a nicely-formatted string ready to log\n * or throw.\n *\n * Useful for ensuring that errors are logged in a consistent, helpful format\n * across the SDK by prompting for key pieces of information.\n */\nconst prettyError = ({ type = \"error\", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code, }) => {\n    var _a, _b;\n    const { icon, colorFn } = {\n        error: { icon: \"❌\", colorFn: chalk_1.default.red },\n        warn: { icon: \"⚠️\", colorFn: chalk_1.default.yellow },\n    }[type];\n    let header = `${icon}  ${chalk_1.default.bold.underline(whatHappened.trim())}`;\n    if (stack) {\n        header +=\n            \"\\n\" +\n                [...(((_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\").slice(1).filter(Boolean)) || [])].join(\"\\n\");\n    }\n    let toFixNowStr = (_b = (Array.isArray(toFixNow)\n        ? toFixNow\n            .map((s) => s.trim())\n            .filter(Boolean)\n            .map((s, i) => `\\t${i + 1}. ${s}`)\n            .join(\"\\n\")\n        : toFixNow === null || toFixNow === void 0 ? void 0 : toFixNow.trim())) !== null && _b !== void 0 ? _b : \"\";\n    if (Array.isArray(toFixNow) && toFixNowStr) {\n        toFixNowStr = `To fix this, you can take one of the following courses of action:\\n\\n${toFixNowStr}`;\n    }\n    let body = [reassurance === null || reassurance === void 0 ? void 0 : reassurance.trim(), why === null || why === void 0 ? void 0 : why.trim(), consequences === null || consequences === void 0 ? void 0 : consequences.trim()]\n        .filter(Boolean)\n        .join(\" \");\n    body += body ? `\\n\\n${toFixNowStr}` : toFixNowStr;\n    const trailer = [otherwise === null || otherwise === void 0 ? void 0 : otherwise.trim()].filter(Boolean).join(\" \");\n    const message = [\n        exports.prettyErrorSplitter,\n        header,\n        body,\n        trailer,\n        code ? `Code: ${code}` : \"\",\n        exports.prettyErrorSplitter,\n    ]\n        .filter(Boolean)\n        .join(\"\\n\\n\");\n    return colorFn(message);\n};\nexports.prettyError = prettyError;\nexports.fixEventKeyMissingSteps = [\n    \"Set the `INNGEST_EVENT_KEY` environment variable\",\n    `Pass a key to the \\`new Inngest()\\` constructor using the \\`${\"eventKey\"}\\` option`,\n    `Use \\`inngest.${\"setEventKey\"}()\\` at runtime`,\n];\n/**\n * An error that, when thrown, indicates internally that an outgoing operation\n * contains an error.\n *\n * We use this because serialized `data` sent back to Inngest may differ from\n * the error instance itself due to middleware.\n *\n * @internal\n */\nclass OutgoingResultError extends Error {\n    constructor(result) {\n        super(\"OutgoingOpError\");\n        this.result = result;\n    }\n}\nexports.OutgoingResultError = OutgoingResultError;\n/**\n * Create a function that will rethrow an error with a prefix added to the\n * message.\n *\n * Useful for adding context to errors that are rethrown.\n *\n * @example\n * ```ts\n * await doSomeAction().catch(rethrowError(\"Failed to do some action\"));\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst rethrowError = (prefix) => {\n    return (err) => {\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions\n            err.message && (err.message = `${prefix}; ${err.message}`);\n        }\n        catch (noopErr) {\n            // no-op\n        }\n        finally {\n            // eslint-disable-next-line no-unsafe-finally\n            throw err;\n        }\n    };\n};\nexports.rethrowError = rethrowError;\n/**\n * Legacy v0 execution error for functions that don't support mixing steps and\n * regular async actions.\n */\nconst functionStoppedRunningErr = (code) => {\n    return (0, exports.prettyError)({\n        whatHappened: \"Your function was stopped from running\",\n        why: \"We detected a mix of asynchronous logic, some using step tooling and some not.\",\n        consequences: \"This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!\",\n        stack: true,\n        toFixNow: \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n        otherwise: \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n        code,\n    });\n};\nexports.functionStoppedRunningErr = functionStoppedRunningErr;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLGVBQWUsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDcFUsZ0NBQWdDLG1CQUFPLENBQUMseURBQU87QUFDL0MsOENBQThDLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzNFLDhCQUE4QixtQkFBTyxDQUFDLG1GQUFxQjtBQUMzRCxxQ0FBcUMsbUJBQU8sQ0FBQyw0REFBWTtBQUN6RCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IsK0JBQStCLG1CQUFPLENBQUMsd0dBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0Esb0NBQW9DLHNIQUFzSDtBQUMxSjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHFDQUFxQztBQUNyQywrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxjQUFjLGVBQWUsZUFBZTtBQUM3QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUyxJQUFJLFlBQVksSUFBSSxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGtCQUFrQixrQ0FBa0M7QUFDcEQsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlHQUFpRztBQUN4SDtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLGlCQUFpQix5Q0FBeUM7QUFDMUQsZ0JBQWdCLDZDQUE2QztBQUM3RCxLQUFLO0FBQ0wsb0JBQW9CLE9BQU8sRUFBRSxvREFBb0Q7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU0sSUFBSSxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixZQUFZO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLCtCQUErQjtBQUMvQjtBQUNBLG1FQUFtRSxXQUFXO0FBQzlFLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsRUFBRSxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0k7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIgPSBleHBvcnRzLnJldGhyb3dFcnJvciA9IGV4cG9ydHMuT3V0Z29pbmdSZXN1bHRFcnJvciA9IGV4cG9ydHMuZml4RXZlbnRLZXlNaXNzaW5nU3RlcHMgPSBleHBvcnRzLnByZXR0eUVycm9yID0gZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBleHBvcnRzLm1pbmlmeVByZXR0eUVycm9yID0gZXhwb3J0cy5wcmV0dHlFcnJvclNwbGl0dGVyID0gZXhwb3J0cy5FcnJDb2RlID0gZXhwb3J0cy5kZXNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5pc1NlcmlhbGl6ZWRFcnJvciA9IGV4cG9ydHMuc2VyaWFsaXplRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjaGFsa18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjaGFsa1wiKSk7XG5jb25zdCBqc29uX3N0cmluZ2lmeV9zYWZlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tc3RyaW5naWZ5LXNhZmVcIikpO1xuY29uc3Qgc2VyaWFsaXplX2Vycm9yX2Nqc18xID0gcmVxdWlyZShcInNlcmlhbGl6ZS1lcnJvci1janNcIik7XG5jb25zdCBzdHJpcF9hbnNpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInN0cmlwLWFuc2lcIikpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgTm9uUmV0cmlhYmxlRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzXCIpO1xuY29uc3QgU0VSSUFMSVpFRF9LRVkgPSBcIl9fc2VyaWFsaXplZFwiO1xuY29uc3QgU0VSSUFMSVpFRF9WQUxVRSA9IHRydWU7XG4vKipcbiAqIEFkZCBmaXJzdC1jbGFzcyBzdXBwb3J0IGZvciBjZXJ0YWluIGVycm9ycyB0aGF0IHdlIGNvbnRyb2wsIGluIGFkZGl0aW9uIHRvXG4gKiBidWlsdC1pbiBlcnJvcnMgc3VjaCBhcyBgVHlwZUVycm9yYC5cbiAqXG4gKiBBZGRpbmcgdGhlc2UgYWxsb3dzIHRoZXNlIG5vbi1zdGFuZGFyZCBlcnJvcnMgdG8gYmUgY29ycmVjdGx5IHNlcmlhbGl6ZWQsXG4gKiBzZW50IHRvIElubmdlc3QsIHRoZW4gZGVzZXJpYWxpemVkIGJhY2sgaW50byB0aGUgY29ycmVjdCBlcnJvciB0eXBlIGZvciB1c2Vyc1xuICogdG8gcmVhY3QgdG8gY29ycmVjdGx5LlxuICpcbiAqIE5vdGUgdGhhdCB0aGVzZSBlcnJvcnMgb25seSBzdXBwb3J0IGBtZXNzYWdlPzogc3RyaW5nIHwgdW5kZWZpbmVkYCBhcyB0aGVcbiAqIGlucHV0OyBtb3JlIGN1c3RvbSBlcnJvcnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0aGlzIGN1cnJlbnQgc3RyYXRlZ3kuXG4gKi9cbnNlcmlhbGl6ZV9lcnJvcl9janNfMS5lcnJvckNvbnN0cnVjdG9ycy5zZXQoXCJOb25SZXRyaWFibGVFcnJvclwiLCBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKTtcbi8qKlxuICogU2VyaWFsaXNlIGFuIGVycm9yIHRvIGEgc2VyaWFsaXplZCBKU09OIHN0cmluZy5cbiAqXG4gKiBFcnJvcnMgZG8gbm90IHNlcmlhbGlzZSBuaWNlbHkgdG8gSlNPTiwgc28gd2UgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY29udmVydFxuICogdGhlbSB0byBhIHNlcmlhbGl6ZWQgSlNPTiBzdHJpbmcuIERvaW5nIHRoaXMgaXMgYWxzbyBub24tdHJpdmlhbCBmb3Igc29tZVxuICogZXJyb3JzLCBzbyB3ZSB1c2UgdGhlIGBzZXJpYWxpemUtZXJyb3JgIHBhY2thZ2UgdG8gZG8gaXQgZm9yIHVzLlxuICpcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2VyaWFsaXplLWVycm9yfVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCB0aGF0IHBhY2thZ2UgdG8gYWxzbyBhZGQgYSBgdHlwZWBcbiAqIHByb3BlcnR5IHRvIHRoZSBzZXJpYWxpc2VkIGVycm9yLCBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gKiBzZXJpYWxpc2VkIGVycm9ycyBhbmQgb3RoZXIgb2JqZWN0cy5cbiAqXG4gKiBXaWxsIG5vdCByZXNlcmlhbGlzZSBleGlzdGluZyBzZXJpYWxpc2VkIGVycm9ycy5cbiAqL1xuY29uc3Qgc2VyaWFsaXplRXJyb3IgPSAoXG4vKipcbiAqIFRoZSBzdXNwZWN0ZWQgZXJyb3IgdG8gc2VyaWFsaXplLlxuICovXG5zdWJqZWN0LCBcbi8qKlxuICogSWYgYHRydWVgIGFuZCB0aGUgZXJyb3IgaXMgbm90IHNlcmlhbGl6YWJsZSwgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlXG4gKiBhcyBgdW5rbm93bmAgaW5zdGVhZCBvZiBjb2VyY2luZyBpdCB0byBhIHNlcmlhbGl6ZWQgZXJyb3IuXG4gKi9cbmFsbG93VW5rbm93biA9IGZhbHNlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIHVuZGVyc3RhbmQgaWYgdGhpcyBpcyBhbHJlYWR5IGRvbmUuXG4gICAgICAgIC8vIFdpbGwgaGFuZGxlIHN0cmluZ2lmaWVkIGVycm9ycy5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdTZXJpYWxpemVkRXJyb3IgPSAoMCwgZXhwb3J0cy5pc1NlcmlhbGl6ZWRFcnJvcikoc3ViamVjdCk7XG4gICAgICAgIGlmIChleGlzdGluZ1NlcmlhbGl6ZWRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VyaWFsaXplZEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc3ViamVjdCA9PT0gXCJvYmplY3RcIiAmJiBzdWJqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJcyBhbiBvYmplY3QsIHNvIGxldCdzIHRyeSBhbmQgc2VyaWFsaXplIGl0LlxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVyciA9ICgwLCBzZXJpYWxpemVfZXJyb3JfY2pzXzEuc2VyaWFsaXplRXJyb3IpKHN1YmplY3QpO1xuICAgICAgICAgICAgLy8gTm90IGEgcHJvcGVyIGVycm9yIHdhcyBjYXVnaHQsIHNvIGdpdmUgdXMgYSBjaGFuY2UgdG8gcmV0dXJuIGB1bmtub3duYC5cbiAgICAgICAgICAgIGlmICghc2VyaWFsaXplZEVyci5uYW1lICYmIGFsbG93VW5rbm93bikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VyaWFsaXphdGlvbiBjYW4gc3VjY2VlZCBidXQgYXNzaWduIG5vIG5hbWUgb3IgbWVzc2FnZSwgc28gd2UnbGxcbiAgICAgICAgICAgIC8vIG1hcCBvdmVyIHRoZSByZXN1bHQgaGVyZSB0byBlbnN1cmUgd2UgaGF2ZSBldmVyeXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UnbGwganVzdCBzdHJpbmdpZnkgdGhlIGVudGlyZSBzdWJqZWN0IGZvciB0aGUgbWVzc2FnZSwgYXMgdGhpcyBhdFxuICAgICAgICAgICAgLy8gbGVhc3QgcHJvdmlkZXMgc29tZSBjb250ZXh0IGZvciB0aGUgdXNlci5cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWFsaXplZEVyciksIHsgbmFtZTogc2VyaWFsaXplZEVyci5uYW1lIHx8IFwiRXJyb3JcIiwgbWVzc2FnZTogc2VyaWFsaXplZEVyci5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgICgwLCBqc29uX3N0cmluZ2lmeV9zYWZlXzEuZGVmYXVsdCkoc3ViamVjdCkgfHxcbiAgICAgICAgICAgICAgICAgICAgXCJVbmtub3duIGVycm9yOyBlcnJvciBzZXJpYWxpemF0aW9uIGNvdWxkIG5vdCBmaW5kIGEgbWVzc2FnZS5cIiwgc3RhY2s6IHNlcmlhbGl6ZWRFcnIuc3RhY2sgfHwgXCJcIiwgW1NFUklBTElaRURfS0VZXTogU0VSSUFMSVpFRF9WQUxVRSB9KTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBjYXVzZSwgbWFrZSBzdXJlIHdlIHJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSB0aGVtIHRvby4gV2UgYXJlXG4gICAgICAgICAgICAvLyBsaWdodGVyIHdpdGggY2F1c2VzIHRob3VnaDsgYXR0ZW1wdCB0byByZWN1cnNpdmVseSBzZXJpYWxpemUgdGhlbSwgYnV0XG4gICAgICAgICAgICAvLyBzdG9wIGlmIHdlIGZpbmQgc29tZXRoaW5nIHRoYXQgZG9lc24ndCB3b3JrIGFuZCBqdXN0IHJldHVybiBgdW5rbm93bmAuXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcmV0O1xuICAgICAgICAgICAgY29uc3QgbWF4RGVwdGggPSA1O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhEZXB0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIFwiY2F1c2VcIiBpbiB0YXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5jYXVzZSA9ICgwLCBleHBvcnRzLnNlcmlhbGl6ZUVycm9yKSh0YXJnZXQuY2F1c2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIG9iamVjdCwgaXQncyBoYXJkIHRvIHBhcnNlIHRoaXMgYXMgYW4gRXJyb3IuIEluIHRoaXMgY2FzZSxcbiAgICAgICAgLy8gd2UnbGwgdGhyb3cgYW4gZXJyb3IgdG8gc3RhcnQgYXR0ZW1wdGluZyBiYWNrdXAgc3RyYXRlZ2llcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaXMgbm90IGFuIG9iamVjdDsgc3RyYW5nZSB0aHJvdyB2YWx1ZS5cIik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGFsbG93VW5rbm93bikge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGFsbG93ZWQgdG8gcmV0dXJuIHVua25vd24sIHdlJ2xsIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgc2VyaWFsaXphdGlvbiBmYWlscywgZmFsbCBiYWNrIHRvIGEgcmVndWxhciBFcnJvciBhbmQgdXNlIHRoZVxuICAgICAgICAgICAgLy8gb3JpZ2luYWwgb2JqZWN0IGFzIHRoZSBtZXNzYWdlIGZvciBhbiBFcnJvci4gV2UgZG9uJ3Qga25vdyB3aGF0IHRoaXNcbiAgICAgICAgICAgIC8vIG9iamVjdCBsb29rcyBsaWtlLCBzbyB3ZSBjYW4ndCBkbyBhbnl0aGluZyBlbHNlIHdpdGggaXQuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgZXhwb3J0cy5zZXJpYWxpemVFcnJvcikobmV3IEVycm9yKHR5cGVvZiBzdWJqZWN0ID09PSBcInN0cmluZ1wiID8gc3ViamVjdCA6ICgwLCBqc29uX3N0cmluZ2lmeV9zYWZlXzEuZGVmYXVsdCkoc3ViamVjdCkpLCBmYWxzZSkpLCB7IFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhY2s7IGl0J3Mgbm90IHJlbGV2YW50IGhlcmVcbiAgICAgICAgICAgICAgICBzdGFjazogXCJcIiwgW1NFUklBTElaRURfS0VZXTogU0VSSUFMSVpFRF9WQUxVRSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGZhaWxlZCwgdGhlbiBzdHJpbmdpZnlpbmcgdGhlIG9iamVjdCBhbHNvIGZhaWxlZCwgc28gd2UnbGwganVzdFxuICAgICAgICAgICAgLy8gcmV0dXJuIGEgY29tcGxldGVseSBnZW5lcmljIGVycm9yLlxuICAgICAgICAgICAgLy8gRmFpbGluZyB0byBzdHJpbmdpZnkgdGhlIG9iamVjdCBpcyB2ZXJ5IHVubGlrZWx5LlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvdWxkIG5vdCBzZXJpYWxpemUgc291cmNlIGVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJTZXJpYWxpemluZyB0aGUgc291cmNlIGVycm9yIGZhaWxlZC5cIixcbiAgICAgICAgICAgICAgICBzdGFjazogXCJcIixcbiAgICAgICAgICAgICAgICBbU0VSSUFMSVpFRF9LRVldOiBTRVJJQUxJWkVEX1ZBTFVFLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gc2VyaWFsaXplRXJyb3I7XG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBvciBhIHN0cmluZyBpcyBhIHNlcmlhbGlzZWQgZXJyb3IgY3JlYXRlZCBieVxuICoge0BsaW5rIHNlcmlhbGl6ZUVycm9yfS5cbiAqL1xuY29uc3QgaXNTZXJpYWxpemVkRXJyb3IgPSAodmFsdWUpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgW1NFUklBTElaRURfS0VZXTogem9kXzEuei5saXRlcmFsKFNFUklBTElaRURfVkFMVUUpLFxuICAgICAgICAgICAgICAgIG5hbWU6IHpvZF8xLnouZW51bShbLi4uQXJyYXkuZnJvbShzZXJpYWxpemVfZXJyb3JfY2pzXzEuZXJyb3JDb25zdHJ1Y3RvcnMua2V5cygpKV0pLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc3RhY2s6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgLnNhZmVQYXJzZShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqSXNTZXJpYWxpemVkRXJyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBTRVJJQUxJWkVEX0tFWSkgJiZcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgdmFsdWVbU0VSSUFMSVpFRF9LRVldID09PVxuICAgICAgICAgICAgICAgICAgICBTRVJJQUxJWkVEX1ZBTFVFO1xuICAgICAgICAgICAgaWYgKG9iaklzU2VyaWFsaXplZEVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gbm8tb3A7IHdlJ2xsIHJldHVybiB1bmRlZmluZWQgaWYgcGFyc2luZyBmYWlsZWQsIGFzIGl0IGlzbid0IGEgc2VyaWFsaXplZFxuICAgICAgICAvLyBlcnJvclxuICAgIH1cbn07XG5leHBvcnRzLmlzU2VyaWFsaXplZEVycm9yID0gaXNTZXJpYWxpemVkRXJyb3I7XG4vKipcbiAqIERlc2VyaWFsaXNlIGFuIGVycm9yIGNyZWF0ZWQgYnkge0BsaW5rIHNlcmlhbGl6ZUVycm9yfS5cbiAqXG4gKiBFbnN1cmVzIHdlIG9ubHkgZGVzZXJpYWxpc2UgZXJyb3JzIHRoYXQgbWVldCBhIG1pbmltdW0gbGV2ZWwgb2ZcbiAqIGFwcGxpY2FiaWxpdHksIGluY2x1c2l2ZSBvZiBlcnJvciBoYW5kbGluZyB0byBlbnN1cmUgdGhhdCBiYWRseSBzZXJpYWxpemVkXG4gKiBlcnJvcnMgYXJlIHN0aWxsIGhhbmRsZWQuXG4gKi9cbmNvbnN0IGRlc2VyaWFsaXplRXJyb3IgPSAoc3ViamVjdCwgYWxsb3dVbmtub3duID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IFtcIm5hbWVcIiwgXCJtZXNzYWdlXCJdO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhhc1JlcXVpcmVkRmllbGRzID0gcmVxdWlyZWRGaWVsZHMuZXZlcnkoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN1YmplY3QsIGZpZWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFzUmVxdWlyZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEVyciA9ICgwLCBzZXJpYWxpemVfZXJyb3JfY2pzXzEuZGVzZXJpYWxpemVFcnJvcikoc3ViamVjdCk7XG4gICAgICAgIGlmIChcImNhdXNlXCIgaW4gZGVzZXJpYWxpemVkRXJyKSB7XG4gICAgICAgICAgICBkZXNlcmlhbGl6ZWRFcnIuY2F1c2UgPSAoMCwgZXhwb3J0cy5kZXNlcmlhbGl6ZUVycm9yKShkZXNlcmlhbGl6ZWRFcnIuY2F1c2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZWRFcnI7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICBpZiAoYWxsb3dVbmtub3duKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYWxsb3dlZCB0byByZXR1cm4gdW5rbm93biwgd2UnbGwganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIlVua25vd24gZXJyb3I7IGNvdWxkIG5vdCByZXNlcmlhbGl6ZVwiKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgc3RhY2sgc28gdGhhdCBpdCdzIG5vdCBtaXNsZWFkaW5nbHkgc2hvd24gYXMgdGhlIElubmdlc3RcbiAgICAgICAgICogaW50ZXJuYWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyLnN0YWNrID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbn07XG5leHBvcnRzLmRlc2VyaWFsaXplRXJyb3IgPSBkZXNlcmlhbGl6ZUVycm9yO1xudmFyIEVyckNvZGU7XG4oZnVuY3Rpb24gKEVyckNvZGUpIHtcbiAgICBFcnJDb2RlW1wiTkVTVElOR19TVEVQU1wiXSA9IFwiTkVTVElOR19TVEVQU1wiO1xuICAgIC8qKlxuICAgICAqIExlZ2FjeSB2MCBleGVjdXRpb24gZXJyb3IgY29kZSBmb3Igd2hlbiBhIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkIGFuZCBub1xuICAgICAqIGxvbmdlciBtYXRjaGVzIGl0cyBpbi1wcm9ncmVzcyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIE5vdCBmb3IgdXNlIGluIGxhdGVzdCBleGVjdXRpb24gbWV0aG9kLlxuICAgICAqL1xuICAgIEVyckNvZGVbXCJOT05fREVURVJNSU5JU1RJQ19GVU5DVElPTlwiXSA9IFwiTk9OX0RFVEVSTUlOSVNUSUNfRlVOQ1RJT05cIjtcbiAgICAvKipcbiAgICAgKiBMZWdhY3kgdjAgZXhlY3V0aW9uIGVycm9yIGNvZGUgZm9yIHdoZW4gYSBmdW5jdGlvbiBpcyBmb3VuZCB0byBiZSB1c2luZ1xuICAgICAqIGFzeW5jIGFjdGlvbnMgYWZ0ZXIgbWVtb3ppYXRpb24gaGFzIG9jY3VycmVkLCB3aGljaCB2MCBkb2Vzbid0IHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBOb3QgZm9yIHVzZSBpbiBsYXRlc3QgZXhlY3V0aW9uIG1ldGhvZC5cbiAgICAgKi9cbiAgICBFcnJDb2RlW1wiQVNZTkNfREVURUNURURfQUZURVJfTUVNT0laQVRJT05cIl0gPSBcIkFTWU5DX0RFVEVDVEVEX0FGVEVSX01FTU9JWkFUSU9OXCI7XG4gICAgLyoqXG4gICAgICogTGVnYWN5IHYwIGV4ZWN1dGlvbiBlcnJvciBjb2RlIGZvciB3aGVuIGEgZnVuY3Rpb24gaXMgZm91bmQgdG8gYmUgdXNpbmdcbiAgICAgKiBzdGVwcyBhZnRlciBhIG5vbi1zdGVwIGFzeW5jIGFjdGlvbiBoYXMgb2NjdXJyZWQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBOb3QgZm9yIHVzZSBpbiBsYXRlc3QgZXhlY3V0aW9uIG1ldGhvZC5cbiAgICAgKi9cbiAgICBFcnJDb2RlW1wiU1RFUF9VU0VEX0FGVEVSX0FTWU5DXCJdID0gXCJTVEVQX1VTRURfQUZURVJfQVNZTkNcIjtcbiAgICBFcnJDb2RlW1wiQVVUT01BVElDX1BBUkFMTEVMX0lOREVYSU5HXCJdID0gXCJBVVRPTUFUSUNfUEFSQUxMRUxfSU5ERVhJTkdcIjtcbn0pKEVyckNvZGUgfHwgKGV4cG9ydHMuRXJyQ29kZSA9IEVyckNvZGUgPSB7fSkpO1xuZXhwb3J0cy5wcmV0dHlFcnJvclNwbGl0dGVyID0gXCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCI7XG4vKipcbiAqIEdpdmVuIGFuIHVua25vd24gYGVycmAsIG11dGF0ZSBpdCB0byBtaW5pZnkgYW55IHByZXR0eSBlcnJvcnMgdGhhdCBpdFxuICogY29udGFpbnMuXG4gKi9cbmNvbnN0IG1pbmlmeVByZXR0eUVycm9yID0gKGVycikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWlzRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1ByZXR0eUVycm9yID0gZXJyLm1lc3NhZ2UuaW5jbHVkZXMoZXhwb3J0cy5wcmV0dHlFcnJvclNwbGl0dGVyKTtcbiAgICAgICAgaWYgKCFpc1ByZXR0eUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhbml0aXplZE1lc3NhZ2UgPSAoMCwgc3RyaXBfYW5zaV8xLmRlZmF1bHQpKGVyci5tZXNzYWdlKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgoX2IgPSAoX2EgPSBzYW5pdGl6ZWRNZXNzYWdlLnNwbGl0KFwiICBcIilbMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdChcIlxcblwiKVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRyaW0oKSkgfHwgZXJyLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGNvZGUgPSAoKF9kID0gKF9jID0gc2FuaXRpemVkTWVzc2FnZS5zcGxpdChcIlxcblxcbkNvZGU6IFwiKVsxXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwbGl0KFwiXFxuXFxuXCIpWzBdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudHJpbSgpKSB8fFxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICBlcnIubWVzc2FnZSA9IFtjb2RlLCBtZXNzYWdlXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiAtIFwiKTtcbiAgICAgICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkU3RhY2sgPSAoMCwgc3RyaXBfYW5zaV8xLmRlZmF1bHQpKGVyci5zdGFjayk7XG4gICAgICAgICAgICBjb25zdCBzdGFja1Jlc3QgPSBzYW5pdGl6ZWRTdGFja1xuICAgICAgICAgICAgICAgIC5zcGxpdChgJHtleHBvcnRzLnByZXR0eUVycm9yU3BsaXR0ZXJ9XFxuYClcbiAgICAgICAgICAgICAgICAuc2xpY2UoMilcbiAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IGAke2Vyci5uYW1lfTogJHtlcnIubWVzc2FnZX1cXG4ke3N0YWNrUmVzdH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIGNhdGNoIChub29wRXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcbmV4cG9ydHMubWluaWZ5UHJldHR5RXJyb3IgPSBtaW5pZnlQcmV0dHlFcnJvcjtcbi8qKlxuICogR2l2ZW4gYW4gYGVycmAsIHJldHVybiBhIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgaXQgaXMgaW4gdGhlIHNoYXBlIG9mXG4gKiBhbiBgRXJyb3JgIG9yIG5vdC5cbiAqL1xuY29uc3QgaXNFcnJvciA9IChlcnIpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc05hbWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCBcIm5hbWVcIik7XG4gICAgICAgIGNvbnN0IGhhc01lc3NhZ2UgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCBcIm1lc3NhZ2VcIik7XG4gICAgICAgIHJldHVybiBoYXNOYW1lICYmIGhhc01lc3NhZ2U7XG4gICAgfVxuICAgIGNhdGNoIChub29wRXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuLyoqXG4gKiBHaXZlbiBhbiBgdW5rbm93bmAgb2JqZWN0LCByZXRyaWV2ZSB0aGUgYG1lc3NhZ2VgIHByb3BlcnR5IGZyb20gaXQsIG9yIGZhbGxcbiAqIGJhY2sgdG8gdGhlIGBmYWxsYmFja2Agc3RyaW5nIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaXMgZW1wdHkuXG4gKi9cbmNvbnN0IGdldEVycm9yTWVzc2FnZSA9IChlcnIsIGZhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgeyBtZXNzYWdlIH0gPSB6b2RfMS56XG4gICAgICAgIC5vYmplY3QoeyBtZXNzYWdlOiB6b2RfMS56LnN0cmluZygpLm1pbigxKSB9KVxuICAgICAgICAuY2F0Y2goeyBtZXNzYWdlOiBmYWxsYmFjayB9KVxuICAgICAgICAucGFyc2UoZXJyKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbn07XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbi8qKlxuICogR2l2ZW4gYSB7QGxpbmsgUHJldHR5RXJyb3J9LCByZXR1cm4gYSBuaWNlbHktZm9ybWF0dGVkIHN0cmluZyByZWFkeSB0byBsb2dcbiAqIG9yIHRocm93LlxuICpcbiAqIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBlcnJvcnMgYXJlIGxvZ2dlZCBpbiBhIGNvbnNpc3RlbnQsIGhlbHBmdWwgZm9ybWF0XG4gKiBhY3Jvc3MgdGhlIFNESyBieSBwcm9tcHRpbmcgZm9yIGtleSBwaWVjZXMgb2YgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IHByZXR0eUVycm9yID0gKHsgdHlwZSA9IFwiZXJyb3JcIiwgd2hhdEhhcHBlbmVkLCBvdGhlcndpc2UsIHJlYXNzdXJhbmNlLCB0b0ZpeE5vdywgd2h5LCBjb25zZXF1ZW5jZXMsIHN0YWNrLCBjb2RlLCB9KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGljb24sIGNvbG9yRm4gfSA9IHtcbiAgICAgICAgZXJyb3I6IHsgaWNvbjogXCLinYxcIiwgY29sb3JGbjogY2hhbGtfMS5kZWZhdWx0LnJlZCB9LFxuICAgICAgICB3YXJuOiB7IGljb246IFwi4pqg77iPXCIsIGNvbG9yRm46IGNoYWxrXzEuZGVmYXVsdC55ZWxsb3cgfSxcbiAgICB9W3R5cGVdO1xuICAgIGxldCBoZWFkZXIgPSBgJHtpY29ufSAgJHtjaGFsa18xLmRlZmF1bHQuYm9sZC51bmRlcmxpbmUod2hhdEhhcHBlbmVkLnRyaW0oKSl9YDtcbiAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgaGVhZGVyICs9XG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICBbLi4uKCgoX2EgPSBuZXcgRXJyb3IoKS5zdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpLmZpbHRlcihCb29sZWFuKSkgfHwgW10pXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBsZXQgdG9GaXhOb3dTdHIgPSAoX2IgPSAoQXJyYXkuaXNBcnJheSh0b0ZpeE5vdylcbiAgICAgICAgPyB0b0ZpeE5vd1xuICAgICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAubWFwKChzLCBpKSA9PiBgXFx0JHtpICsgMX0uICR7c31gKVxuICAgICAgICAgICAgLmpvaW4oXCJcXG5cIilcbiAgICAgICAgOiB0b0ZpeE5vdyA9PT0gbnVsbCB8fCB0b0ZpeE5vdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG9GaXhOb3cudHJpbSgpKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b0ZpeE5vdykgJiYgdG9GaXhOb3dTdHIpIHtcbiAgICAgICAgdG9GaXhOb3dTdHIgPSBgVG8gZml4IHRoaXMsIHlvdSBjYW4gdGFrZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjb3Vyc2VzIG9mIGFjdGlvbjpcXG5cXG4ke3RvRml4Tm93U3RyfWA7XG4gICAgfVxuICAgIGxldCBib2R5ID0gW3JlYXNzdXJhbmNlID09PSBudWxsIHx8IHJlYXNzdXJhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWFzc3VyYW5jZS50cmltKCksIHdoeSA9PT0gbnVsbCB8fCB3aHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdoeS50cmltKCksIGNvbnNlcXVlbmNlcyA9PT0gbnVsbCB8fCBjb25zZXF1ZW5jZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnNlcXVlbmNlcy50cmltKCldXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIGJvZHkgKz0gYm9keSA/IGBcXG5cXG4ke3RvRml4Tm93U3RyfWAgOiB0b0ZpeE5vd1N0cjtcbiAgICBjb25zdCB0cmFpbGVyID0gW290aGVyd2lzZSA9PT0gbnVsbCB8fCBvdGhlcndpc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG90aGVyd2lzZS50cmltKCldLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICBleHBvcnRzLnByZXR0eUVycm9yU3BsaXR0ZXIsXG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgYm9keSxcbiAgICAgICAgdHJhaWxlcixcbiAgICAgICAgY29kZSA/IGBDb2RlOiAke2NvZGV9YCA6IFwiXCIsXG4gICAgICAgIGV4cG9ydHMucHJldHR5RXJyb3JTcGxpdHRlcixcbiAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCJcXG5cXG5cIik7XG4gICAgcmV0dXJuIGNvbG9yRm4obWVzc2FnZSk7XG59O1xuZXhwb3J0cy5wcmV0dHlFcnJvciA9IHByZXR0eUVycm9yO1xuZXhwb3J0cy5maXhFdmVudEtleU1pc3NpbmdTdGVwcyA9IFtcbiAgICBcIlNldCB0aGUgYElOTkdFU1RfRVZFTlRfS0VZYCBlbnZpcm9ubWVudCB2YXJpYWJsZVwiLFxuICAgIGBQYXNzIGEga2V5IHRvIHRoZSBcXGBuZXcgSW5uZ2VzdCgpXFxgIGNvbnN0cnVjdG9yIHVzaW5nIHRoZSBcXGAke1wiZXZlbnRLZXlcIn1cXGAgb3B0aW9uYCxcbiAgICBgVXNlIFxcYGlubmdlc3QuJHtcInNldEV2ZW50S2V5XCJ9KClcXGAgYXQgcnVudGltZWAsXG5dO1xuLyoqXG4gKiBBbiBlcnJvciB0aGF0LCB3aGVuIHRocm93biwgaW5kaWNhdGVzIGludGVybmFsbHkgdGhhdCBhbiBvdXRnb2luZyBvcGVyYXRpb25cbiAqIGNvbnRhaW5zIGFuIGVycm9yLlxuICpcbiAqIFdlIHVzZSB0aGlzIGJlY2F1c2Ugc2VyaWFsaXplZCBgZGF0YWAgc2VudCBiYWNrIHRvIElubmdlc3QgbWF5IGRpZmZlciBmcm9tXG4gKiB0aGUgZXJyb3IgaW5zdGFuY2UgaXRzZWxmIGR1ZSB0byBtaWRkbGV3YXJlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBPdXRnb2luZ1Jlc3VsdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3VsdCkge1xuICAgICAgICBzdXBlcihcIk91dGdvaW5nT3BFcnJvclwiKTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRnb2luZ1Jlc3VsdEVycm9yID0gT3V0Z29pbmdSZXN1bHRFcnJvcjtcbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldGhyb3cgYW4gZXJyb3Igd2l0aCBhIHByZWZpeCBhZGRlZCB0byB0aGVcbiAqIG1lc3NhZ2UuXG4gKlxuICogVXNlZnVsIGZvciBhZGRpbmcgY29udGV4dCB0byBlcnJvcnMgdGhhdCBhcmUgcmV0aHJvd24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBhd2FpdCBkb1NvbWVBY3Rpb24oKS5jYXRjaChyZXRocm93RXJyb3IoXCJGYWlsZWQgdG8gZG8gc29tZSBhY3Rpb25cIikpO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCByZXRocm93RXJyb3IgPSAocHJlZml4KSA9PiB7XG4gICAgcmV0dXJuIChlcnIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgJiYgKGVyci5tZXNzYWdlID0gYCR7cHJlZml4fTsgJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAobm9vcEVycikge1xuICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnNhZmUtZmluYWxseVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLnJldGhyb3dFcnJvciA9IHJldGhyb3dFcnJvcjtcbi8qKlxuICogTGVnYWN5IHYwIGV4ZWN1dGlvbiBlcnJvciBmb3IgZnVuY3Rpb25zIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtaXhpbmcgc3RlcHMgYW5kXG4gKiByZWd1bGFyIGFzeW5jIGFjdGlvbnMuXG4gKi9cbmNvbnN0IGZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIgPSAoY29kZSkgPT4ge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5wcmV0dHlFcnJvcikoe1xuICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiWW91ciBmdW5jdGlvbiB3YXMgc3RvcHBlZCBmcm9tIHJ1bm5pbmdcIixcbiAgICAgICAgd2h5OiBcIldlIGRldGVjdGVkIGEgbWl4IG9mIGFzeW5jaHJvbm91cyBsb2dpYywgc29tZSB1c2luZyBzdGVwIHRvb2xpbmcgYW5kIHNvbWUgbm90LlwiLFxuICAgICAgICBjb25zZXF1ZW5jZXM6IFwiVGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIgd2hlbiBhIGZ1bmN0aW9uIGlzIHBhdXNlZCBhbmQgcmVzdW1lZCBhbmQgaXMgdGhlcmVmb3JlIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkOyB3ZSBzdG9wcGVkIHlvdXIgZnVuY3Rpb24gdG8gZW5zdXJlIG5vdGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZCFcIixcbiAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgIHRvRml4Tm93OiBcIkVuc3VyZSB0aGF0IHlvdXIgZnVuY3Rpb24gaXMgZWl0aGVyIGVudGlyZWx5IHN0ZXAtYmFzZWQgb3IgZW50aXJlbHkgbm9uLXN0ZXAtYmFzZWQsIGJ5IGVpdGhlciB3cmFwcGluZyBhbGwgYXN5bmNocm9ub3VzIGxvZ2ljIGluIGBzdGVwLnJ1bigpYCBjYWxscyBvciBieSByZW1vdmluZyBhbGwgYHN0ZXAuKigpYCBjYWxscy5cIixcbiAgICAgICAgb3RoZXJ3aXNlOiBcIkZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoeSBzdGVwIGZ1bmN0aW9ucyB3b3JrIGluIHRoaXMgbWFubmVyLCBzZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9mdW5jdGlvbnMvbXVsdGktc3RlcCNnb3RjaGFzXCIsXG4gICAgICAgIGNvZGUsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5mdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyID0gZnVuY3Rpb25TdG9wcGVkUnVubmluZ0Vycjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/functions.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/helpers/functions.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchAllFnData = exports.parseFnData = exports.undefinedToNull = exports.waterfall = exports.cacheFn = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst schema_js_1 = __webpack_require__(/*! ../api/schema.js */ \"(rsc)/./node_modules/inngest/api/schema.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ../components/execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/**\n * Wraps a function with a cache. When the returned function is run, it will\n * cache the result and return it on subsequent calls.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst cacheFn = (fn) => {\n    const key = \"value\";\n    const cache = new Map();\n    return ((...args) => {\n        if (!cache.has(key)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            cache.set(key, fn(...args));\n        }\n        return cache.get(key);\n    });\n};\nexports.cacheFn = cacheFn;\n/**\n * Given an array of functions, return a new function that will run each\n * function in series and return the result of the final function. Regardless of\n * if the functions are synchronous or asynchronous, they'll be made into an\n * async promise chain.\n *\n * If an error is thrown, the waterfall will stop and return the error.\n *\n * Because this needs to support both sync and async functions, it only allows\n * functions that accept a single argument.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst waterfall = (fns, \n/**\n * A function that transforms the result of each function in the waterfall,\n * ready for the next function.\n *\n * Will not be called on the final function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntransform) => {\n    return (...args) => {\n        const chain = fns.reduce(async (acc, fn) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const prev = await acc;\n            const output = (await fn(prev));\n            if (transform) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return await transform(prev, output);\n            }\n            if (typeof output === \"undefined\") {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return prev;\n            }\n            return output;\n        }, Promise.resolve(args[0]));\n        return chain;\n    };\n};\nexports.waterfall = waterfall;\n/**\n * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.\n */\nconst undefinedToNull = (v) => {\n    const isUndefined = typeof v === \"undefined\";\n    return isUndefined ? null : v;\n};\nexports.undefinedToNull = undefinedToNull;\nconst fnDataVersionSchema = zod_1.z.object({\n    version: zod_1.z\n        .literal(-1)\n        .or(zod_1.z.literal(0))\n        .or(zod_1.z.literal(1))\n        .or(zod_1.z.literal(2))\n        .optional()\n        .transform((v) => {\n        if (typeof v === \"undefined\") {\n            console.debug(`No request version specified by executor; defaulting to v${InngestExecution_js_1.PREFERRED_EXECUTION_VERSION}`);\n            return InngestExecution_js_1.PREFERRED_EXECUTION_VERSION;\n        }\n        return v === -1 ? InngestExecution_js_1.PREFERRED_EXECUTION_VERSION : v;\n    }),\n});\nconst parseFnData = (data) => {\n    let version;\n    try {\n        ({ version } = fnDataVersionSchema.parse(data));\n        const versionHandlers = {\n            [InngestExecution_js_1.ExecutionVersion.V0]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V0 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V0],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n                use_api: zod_1.z.boolean().default(false),\n            })\n                .parse(data))),\n            [InngestExecution_js_1.ExecutionVersion.V1]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V1 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V1],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    disable_immediate_execution: zod_1.z.boolean().default(false),\n                    use_api: zod_1.z.boolean().default(false),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n            })\n                .parse(data))),\n            [InngestExecution_js_1.ExecutionVersion.V2]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V2 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V2],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    disable_immediate_execution: zod_1.z.boolean().default(false),\n                    use_api: zod_1.z.boolean().default(false),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n            })\n                .parse(data))),\n        };\n        return versionHandlers[version]();\n    }\n    catch (err) {\n        throw new Error(parseFailureErr(err));\n    }\n};\nexports.parseFnData = parseFnData;\nconst fetchAllFnData = async ({ data, api, version, }) => {\n    var _a, _b, _c, _d;\n    const result = Object.assign({}, data);\n    try {\n        if ((result.version === InngestExecution_js_1.ExecutionVersion.V0 && result.use_api) ||\n            (result.version === InngestExecution_js_1.ExecutionVersion.V1 && ((_a = result.ctx) === null || _a === void 0 ? void 0 : _a.use_api))) {\n            if (!((_b = result.ctx) === null || _b === void 0 ? void 0 : _b.run_id)) {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to attempt retrieving data from API\",\n                    consequences: \"function execution can't continue\",\n                    why: \"run_id is missing from context\",\n                    stack: true,\n                }));\n            }\n            const [evtResp, stepResp] = await Promise.all([\n                api.getRunBatch(result.ctx.run_id),\n                api.getRunSteps(result.ctx.run_id, version),\n            ]);\n            if (evtResp.ok) {\n                result.events = evtResp.value;\n            }\n            else {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to retrieve list of events\",\n                    consequences: \"function execution can't continue\",\n                    why: (_c = evtResp.error) === null || _c === void 0 ? void 0 : _c.error,\n                    stack: true,\n                }));\n            }\n            if (stepResp.ok) {\n                result.steps = stepResp.value;\n            }\n            else {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to retrieve steps for function run\",\n                    consequences: \"function execution can't continue\",\n                    why: (_d = stepResp.error) === null || _d === void 0 ? void 0 : _d.error,\n                    stack: true,\n                }));\n            }\n        }\n        return (0, types_js_1.ok)(result);\n    }\n    catch (error) {\n        // print it out for now.\n        // move to something like protobuf so we don't have to deal with this\n        console.error(error);\n        return (0, types_js_1.err)(parseFailureErr(error));\n    }\n};\nexports.fetchAllFnData = fetchAllFnData;\nconst parseFailureErr = (err) => {\n    let why;\n    if (err instanceof zod_1.ZodError) {\n        why = err.toString();\n    }\n    return (0, errors_js_1.prettyError)({\n        whatHappened: \"Failed to parse data from executor.\",\n        consequences: \"Function execution can't continue.\",\n        toFixNow: \"Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).\",\n        stack: true,\n        why,\n    });\n};\n//# sourceMappingURL=functions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Z1bmN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxlQUFlO0FBQzVHLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDOUMsOEJBQThCLG1CQUFPLENBQUMsMEhBQTZDO0FBQ25GLG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGlCQUFpQixrREFBa0Q7QUFDeEk7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxnRkFBZ0Ysb0RBQW9EO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0ZBQWdGLG9EQUFvRDtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0ZBQWdGLG9EQUFvRDtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Z1bmN0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmV0Y2hBbGxGbkRhdGEgPSBleHBvcnRzLnBhcnNlRm5EYXRhID0gZXhwb3J0cy51bmRlZmluZWRUb051bGwgPSBleHBvcnRzLndhdGVyZmFsbCA9IGV4cG9ydHMuY2FjaGVGbiA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IHNjaGVtYV9qc18xID0gcmVxdWlyZShcIi4uL2FwaS9zY2hlbWEuanNcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB3aXRoIGEgY2FjaGUuIFdoZW4gdGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIHJ1biwgaXQgd2lsbFxuICogY2FjaGUgdGhlIHJlc3VsdCBhbmQgcmV0dXJuIGl0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBjYWNoZUZuID0gKGZuKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gXCJ2YWx1ZVwiO1xuICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiAoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIGNhY2hlLnNldChrZXksIGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5jYWNoZUZuID0gY2FjaGVGbjtcbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgZnVuY3Rpb25zLCByZXR1cm4gYSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biBlYWNoXG4gKiBmdW5jdGlvbiBpbiBzZXJpZXMgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5hbCBmdW5jdGlvbi4gUmVnYXJkbGVzcyBvZlxuICogaWYgdGhlIGZ1bmN0aW9ucyBhcmUgc3luY2hyb25vdXMgb3IgYXN5bmNocm9ub3VzLCB0aGV5J2xsIGJlIG1hZGUgaW50byBhblxuICogYXN5bmMgcHJvbWlzZSBjaGFpbi5cbiAqXG4gKiBJZiBhbiBlcnJvciBpcyB0aHJvd24sIHRoZSB3YXRlcmZhbGwgd2lsbCBzdG9wIGFuZCByZXR1cm4gdGhlIGVycm9yLlxuICpcbiAqIEJlY2F1c2UgdGhpcyBuZWVkcyB0byBzdXBwb3J0IGJvdGggc3luYyBhbmQgYXN5bmMgZnVuY3Rpb25zLCBpdCBvbmx5IGFsbG93c1xuICogZnVuY3Rpb25zIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFyZ3VtZW50LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3Qgd2F0ZXJmYWxsID0gKGZucywgXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSByZXN1bHQgb2YgZWFjaCBmdW5jdGlvbiBpbiB0aGUgd2F0ZXJmYWxsLFxuICogcmVhZHkgZm9yIHRoZSBuZXh0IGZ1bmN0aW9uLlxuICpcbiAqIFdpbGwgbm90IGJlIGNhbGxlZCBvbiB0aGUgZmluYWwgZnVuY3Rpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50cmFuc2Zvcm0pID0+IHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgY2hhaW4gPSBmbnMucmVkdWNlKGFzeW5jIChhY2MsIGZuKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYXdhaXQgYWNjO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gKGF3YWl0IGZuKHByZXYpKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdHJhbnNmb3JtKHByZXYsIG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG91dHB1dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKGFyZ3NbMF0pKTtcbiAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH07XG59O1xuZXhwb3J0cy53YXRlcmZhbGwgPSB3YXRlcmZhbGw7XG4vKipcbiAqIEdpdmVuIGEgdmFsdWUgYHZgLCByZXR1cm4gYHZgIGlmIGl0J3Mgbm90IHVuZGVmaW5lZCwgb3RoZXJ3aXNlIHJldHVybiBgbnVsbGAuXG4gKi9cbmNvbnN0IHVuZGVmaW5lZFRvTnVsbCA9ICh2KSA9PiB7XG4gICAgY29uc3QgaXNVbmRlZmluZWQgPSB0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQgPyBudWxsIDogdjtcbn07XG5leHBvcnRzLnVuZGVmaW5lZFRvTnVsbCA9IHVuZGVmaW5lZFRvTnVsbDtcbmNvbnN0IGZuRGF0YVZlcnNpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgdmVyc2lvbjogem9kXzEuelxuICAgICAgICAubGl0ZXJhbCgtMSlcbiAgICAgICAgLm9yKHpvZF8xLnoubGl0ZXJhbCgwKSlcbiAgICAgICAgLm9yKHpvZF8xLnoubGl0ZXJhbCgxKSlcbiAgICAgICAgLm9yKHpvZF8xLnoubGl0ZXJhbCgyKSlcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLnRyYW5zZm9ybSgodikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYE5vIHJlcXVlc3QgdmVyc2lvbiBzcGVjaWZpZWQgYnkgZXhlY3V0b3I7IGRlZmF1bHRpbmcgdG8gdiR7SW5uZ2VzdEV4ZWN1dGlvbl9qc18xLlBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTn1gKTtcbiAgICAgICAgICAgIHJldHVybiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ID09PSAtMSA/IElubmdlc3RFeGVjdXRpb25fanNfMS5QUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT04gOiB2O1xuICAgIH0pLFxufSk7XG5jb25zdCBwYXJzZUZuRGF0YSA9IChkYXRhKSA9PiB7XG4gICAgbGV0IHZlcnNpb247XG4gICAgdHJ5IHtcbiAgICAgICAgKHsgdmVyc2lvbiB9ID0gZm5EYXRhVmVyc2lvblNjaGVtYS5wYXJzZShkYXRhKSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb25IYW5kbGVycyA9IHtcbiAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMF06ICgpID0+IChPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjAgfSwgem9kXzEuelxuICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiB6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKSxcbiAgICAgICAgICAgICAgICBldmVudHM6IHpvZF8xLnouYXJyYXkoem9kXzEuei5yZWNvcmQoem9kXzEuei5hbnkoKSkpLmRlZmF1bHQoW10pLFxuICAgICAgICAgICAgICAgIHN0ZXBzOiBzY2hlbWFfanNfMS5zdGVwc1NjaGVtYXNbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjBdLFxuICAgICAgICAgICAgICAgIGN0eDogem9kXzEuelxuICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiB6b2RfMS56LnN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiB6b2RfMS56Lm51bWJlcigpLmRlZmF1bHQoMCksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFycmF5KHpvZF8xLnouc3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKCh2KSA9PiAoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICAgICAgdXNlX2FwaTogem9kXzEuei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5wYXJzZShkYXRhKSkpLFxuICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxXTogKCkgPT4gKE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMSB9LCB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpLFxuICAgICAgICAgICAgICAgIGV2ZW50czogem9kXzEuei5hcnJheSh6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKSkuZGVmYXVsdChbXSksXG4gICAgICAgICAgICAgICAgc3RlcHM6IHNjaGVtYV9qc18xLnN0ZXBzU2NoZW1hc1tJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMV0sXG4gICAgICAgICAgICAgICAgY3R4OiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IHpvZF8xLnoubnVtYmVyKCkuZGVmYXVsdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZV9pbW1lZGlhdGVfZXhlY3V0aW9uOiB6b2RfMS56LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlX2FwaTogem9kXzEuei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFycmF5KHpvZF8xLnouc3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKCh2KSA9PiAoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5wYXJzZShkYXRhKSkpLFxuICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYyXTogKCkgPT4gKE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMiB9LCB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpLFxuICAgICAgICAgICAgICAgIGV2ZW50czogem9kXzEuei5hcnJheSh6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKSkuZGVmYXVsdChbXSksXG4gICAgICAgICAgICAgICAgc3RlcHM6IHNjaGVtYV9qc18xLnN0ZXBzU2NoZW1hc1tJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMl0sXG4gICAgICAgICAgICAgICAgY3R4OiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IHpvZF8xLnoubnVtYmVyKCkuZGVmYXVsdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZV9pbW1lZGlhdGVfZXhlY3V0aW9uOiB6b2RfMS56LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlX2FwaTogem9kXzEuei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFycmF5KHpvZF8xLnouc3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKCh2KSA9PiAoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgICAgICAgLm51bGxhYmxlKCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5wYXJzZShkYXRhKSkpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdmVyc2lvbkhhbmRsZXJzW3ZlcnNpb25dKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlRmFpbHVyZUVycihlcnIpKTtcbiAgICB9XG59O1xuZXhwb3J0cy5wYXJzZUZuRGF0YSA9IHBhcnNlRm5EYXRhO1xuY29uc3QgZmV0Y2hBbGxGbkRhdGEgPSBhc3luYyAoeyBkYXRhLCBhcGksIHZlcnNpb24sIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKChyZXN1bHQudmVyc2lvbiA9PT0gSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjAgJiYgcmVzdWx0LnVzZV9hcGkpIHx8XG4gICAgICAgICAgICAocmVzdWx0LnZlcnNpb24gPT09IElubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxICYmICgoX2EgPSByZXN1bHQuY3R4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlX2FwaSkpKSB7XG4gICAgICAgICAgICBpZiAoISgoX2IgPSByZXN1bHQuY3R4KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucnVuX2lkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiZmFpbGVkIHRvIGF0dGVtcHQgcmV0cmlldmluZyBkYXRhIGZyb20gQVBJXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJmdW5jdGlvbiBleGVjdXRpb24gY2FuJ3QgY29udGludWVcIixcbiAgICAgICAgICAgICAgICAgICAgd2h5OiBcInJ1bl9pZCBpcyBtaXNzaW5nIGZyb20gY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbZXZ0UmVzcCwgc3RlcFJlc3BdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGFwaS5nZXRSdW5CYXRjaChyZXN1bHQuY3R4LnJ1bl9pZCksXG4gICAgICAgICAgICAgICAgYXBpLmdldFJ1blN0ZXBzKHJlc3VsdC5jdHgucnVuX2lkLCB2ZXJzaW9uKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKGV2dFJlc3Aub2spIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXZlbnRzID0gZXZ0UmVzcC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiZmFpbGVkIHRvIHJldHJpZXZlIGxpc3Qgb2YgZXZlbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJmdW5jdGlvbiBleGVjdXRpb24gY2FuJ3QgY29udGludWVcIixcbiAgICAgICAgICAgICAgICAgICAgd2h5OiAoX2MgPSBldnRSZXNwLmVycm9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGVwUmVzcC5vaykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGVwcyA9IHN0ZXBSZXNwLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJmYWlsZWQgdG8gcmV0cmlldmUgc3RlcHMgZm9yIGZ1bmN0aW9uIHJ1blwiLFxuICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiZnVuY3Rpb24gZXhlY3V0aW9uIGNhbid0IGNvbnRpbnVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHdoeTogKF9kID0gc3RlcFJlc3AuZXJyb3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykocmVzdWx0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIHByaW50IGl0IG91dCBmb3Igbm93LlxuICAgICAgICAvLyBtb3ZlIHRvIHNvbWV0aGluZyBsaWtlIHByb3RvYnVmIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVhbCB3aXRoIHRoaXNcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHBhcnNlRmFpbHVyZUVycihlcnJvcikpO1xuICAgIH1cbn07XG5leHBvcnRzLmZldGNoQWxsRm5EYXRhID0gZmV0Y2hBbGxGbkRhdGE7XG5jb25zdCBwYXJzZUZhaWx1cmVFcnIgPSAoZXJyKSA9PiB7XG4gICAgbGV0IHdoeTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2Ygem9kXzEuWm9kRXJyb3IpIHtcbiAgICAgICAgd2h5ID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgd2hhdEhhcHBlbmVkOiBcIkZhaWxlZCB0byBwYXJzZSBkYXRhIGZyb20gZXhlY3V0b3IuXCIsXG4gICAgICAgIGNvbnNlcXVlbmNlczogXCJGdW5jdGlvbiBleGVjdXRpb24gY2FuJ3QgY29udGludWUuXCIsXG4gICAgICAgIHRvRml4Tm93OiBcIk1ha2Ugc3VyZSB0aGF0IHlvdXIgQVBJIGlzIHNldCB1cCB0byBwYXJzZSBpbmNvbWluZyByZXF1ZXN0IGJvZGllcyBhcyBKU09OLCBsaWtlIGJvZHktcGFyc2VyIGZvciBFeHByZXNzIChodHRwczovL2V4cHJlc3Nqcy5jb20vZW4vcmVzb3VyY2VzL21pZGRsZXdhcmUvYm9keS1wYXJzZXIuaHRtbCkuXCIsXG4gICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICB3aHksXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/functions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/net.js":
/*!*********************************************!*\
  !*** ./node_modules/inngest/helpers/net.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchWithAuthFallback = fetchWithAuthFallback;\nexports.signDataWithKey = signDataWithKey;\nconst canonicalize_1 = __importDefault(__webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\"));\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\n/**\n * Send an HTTP request with the given signing key. If the response is a 401 or\n * 403, then try again with the fallback signing key\n */\nasync function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url, }) {\n    let res = await fetch(url, Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { Authorization: `Bearer ${authToken}` }) }));\n    if ([401, 403].includes(res.status) && authTokenFallback) {\n        res = await fetch(url, Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { Authorization: `Bearer ${authTokenFallback}` }) }));\n    }\n    return res;\n}\nfunction signDataWithKey(data, signingKey, ts) {\n    // Calculate the HMAC of the request body ourselves.\n    // We make the assumption here that a stringified body is the same as the\n    // raw bytes; it may be pertinent in the future to always parse, then\n    // canonicalize the body to ensure it's consistent.\n    const encoded = typeof data === \"string\" ? data : (0, canonicalize_1.default)(data);\n    // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.\n    const key = signingKey.replace(/signkey-\\w+-/, \"\");\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n    const mac = (0, hash_js_1.hmac)(hash_js_1.sha256, key)\n        .update(encoded)\n        .update(ts)\n        .digest(\"hex\");\n    return mac;\n}\n//# sourceMappingURL=net.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL25ldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIsdUNBQXVDLG1CQUFPLENBQUMsMkVBQWM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0RBQW9EO0FBQzNGLDZEQUE2RCxjQUFjLHVDQUF1Qyx3RUFBd0UseUJBQXlCLFVBQVUsR0FBRyxHQUFHO0FBQ25PO0FBQ0EsNkRBQTZELGNBQWMsdUNBQXVDLHdFQUF3RSx5QkFBeUIsa0JBQWtCLEdBQUcsR0FBRztBQUMzTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvbmV0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaFdpdGhBdXRoRmFsbGJhY2sgPSBmZXRjaFdpdGhBdXRoRmFsbGJhY2s7XG5leHBvcnRzLnNpZ25EYXRhV2l0aEtleSA9IHNpZ25EYXRhV2l0aEtleTtcbmNvbnN0IGNhbm9uaWNhbGl6ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjYW5vbmljYWxpemVcIikpO1xuY29uc3QgaGFzaF9qc18xID0gcmVxdWlyZShcImhhc2guanNcIik7XG4vKipcbiAqIFNlbmQgYW4gSFRUUCByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIHNpZ25pbmcga2V5LiBJZiB0aGUgcmVzcG9uc2UgaXMgYSA0MDEgb3JcbiAqIDQwMywgdGhlbiB0cnkgYWdhaW4gd2l0aCB0aGUgZmFsbGJhY2sgc2lnbmluZyBrZXlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKHsgYXV0aFRva2VuLCBhdXRoVG9rZW5GYWxsYmFjaywgZmV0Y2gsIG9wdGlvbnMsIHVybCwgfSkge1xuICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyksIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGhUb2tlbn1gIH0pIH0pKTtcbiAgICBpZiAoWzQwMSwgNDAzXS5pbmNsdWRlcyhyZXMuc3RhdHVzKSAmJiBhdXRoVG9rZW5GYWxsYmFjaykge1xuICAgICAgICByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyksIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGhUb2tlbkZhbGxiYWNrfWAgfSkgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc2lnbkRhdGFXaXRoS2V5KGRhdGEsIHNpZ25pbmdLZXksIHRzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBITUFDIG9mIHRoZSByZXF1ZXN0IGJvZHkgb3Vyc2VsdmVzLlxuICAgIC8vIFdlIG1ha2UgdGhlIGFzc3VtcHRpb24gaGVyZSB0aGF0IGEgc3RyaW5naWZpZWQgYm9keSBpcyB0aGUgc2FtZSBhcyB0aGVcbiAgICAvLyByYXcgYnl0ZXM7IGl0IG1heSBiZSBwZXJ0aW5lbnQgaW4gdGhlIGZ1dHVyZSB0byBhbHdheXMgcGFyc2UsIHRoZW5cbiAgICAvLyBjYW5vbmljYWxpemUgdGhlIGJvZHkgdG8gZW5zdXJlIGl0J3MgY29uc2lzdGVudC5cbiAgICBjb25zdCBlbmNvZGVkID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBkYXRhIDogKDAsIGNhbm9uaWNhbGl6ZV8xLmRlZmF1bHQpKGRhdGEpO1xuICAgIC8vIFJlbW92ZSB0aGUgYC9zaWdua2V5LVt0ZXN0fHByb2RdLS9gIHByZWZpeCBmcm9tIG91ciBzaWduaW5nIGtleSB0byBjYWxjdWxhdGUgdGhlIEhNQUMuXG4gICAgY29uc3Qga2V5ID0gc2lnbmluZ0tleS5yZXBsYWNlKC9zaWdua2V5LVxcdystLywgXCJcIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBtYWMgPSAoMCwgaGFzaF9qc18xLmhtYWMpKGhhc2hfanNfMS5zaGEyNTYsIGtleSlcbiAgICAgICAgLnVwZGF0ZShlbmNvZGVkKVxuICAgICAgICAudXBkYXRlKHRzKVxuICAgICAgICAuZGlnZXN0KFwiaGV4XCIpO1xuICAgIHJldHVybiBtYWM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/net.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/promises.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/helpers/promises.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.retryWithBackoff = exports.resolveNextTick = exports.runAsPromise = exports.createTimeoutPromise = exports.createDeferredPromiseWithStack = exports.createDeferredPromise = exports.resolveAfterPending = exports.createFrozenPromise = void 0;\n/**\n * Some environments don't allow access to the global queueMicrotask(). While we\n * had assumed this was only true for those powered by earlier versions of Node\n * (<14) that we don't officially support, Vercel's Edge Functions also obscure\n * the function in dev, even though the platform it's based on (Cloudflare\n * Workers) appropriately exposes it. Even worse, production Vercel Edge\n * Functions can see the function, but it immediately blows up the function when\n * used.\n *\n * Therefore, we can fall back to a reasonable alternative of\n * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern\n * environments, but at least we can still work in these environments.\n */\nconst shimQueueMicrotask = (callback) => {\n    void Promise.resolve().then(callback);\n};\n/**\n * A helper function to create a `Promise` that will never settle.\n *\n * It purposefully creates no references to `resolve` or `reject` so that the\n * returned `Promise` will remain unsettled until it falls out of scope and is\n * garbage collected.\n *\n * This should be used within transient closures to fake asynchronous action, so\n * long as it's guaranteed that they will fall out of scope.\n */\nconst createFrozenPromise = () => {\n    return new Promise(() => undefined);\n};\nexports.createFrozenPromise = createFrozenPromise;\n/**\n * Returns a Promise that resolves after the current event loop's microtasks\n * have finished, but before the next event loop tick.\n */\nconst resolveAfterPending = (count = 100) => {\n    /**\n     * This uses a brute force implementation that will continue to enqueue\n     * microtasks 10 times before resolving. This is to ensure that the microtask\n     * queue is drained, even if the microtask queue is being manipulated by other\n     * code.\n     *\n     * While this still doesn't guarantee that the microtask queue is drained,\n     * it's our best bet for giving other non-controlled promises a chance to\n     * resolve before we continue without resorting to falling in to the next\n     * tick.\n     */\n    return new Promise((resolve) => {\n        let i = 0;\n        const iterate = () => {\n            shimQueueMicrotask(() => {\n                if (i++ > count) {\n                    return resolve();\n                }\n                iterate();\n            });\n        };\n        iterate();\n    });\n};\nexports.resolveAfterPending = resolveAfterPending;\n/**\n * Creates and returns Promise that can be resolved or rejected with the\n * returned `resolve` and `reject` functions.\n *\n * Resolving or rejecting the function will return a new set of Promise control\n * functions. These can be ignored if the original Promise is all that's needed.\n */\nconst createDeferredPromise = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n        resolve = (value) => {\n            _resolve(value);\n            return (0, exports.createDeferredPromise)();\n        };\n        reject = (reason) => {\n            _reject(reason);\n            return (0, exports.createDeferredPromise)();\n        };\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return { promise, resolve: resolve, reject: reject };\n};\nexports.createDeferredPromise = createDeferredPromise;\n/**\n * Creates and returns a deferred Promise that can be resolved or rejected with\n * the returned `resolve` and `reject` functions.\n *\n * For each Promise resolved or rejected this way, this will also keep a stack\n * of all unhandled Promises, resolved or rejected.\n *\n * Once a Promise is read, it is removed from the stack.\n */\nconst createDeferredPromiseWithStack = () => {\n    const settledPromises = [];\n    let rotateQueue = () => { };\n    const results = (function () {\n        return __asyncGenerator(this, arguments, function* () {\n            while (true) {\n                const next = settledPromises.shift();\n                if (next) {\n                    yield yield __await(next);\n                }\n                else {\n                    yield __await(new Promise((resolve) => {\n                        rotateQueue = resolve;\n                    }));\n                }\n            }\n        });\n    })();\n    const shimDeferredPromise = (deferred) => {\n        const originalResolve = deferred.resolve;\n        const originalReject = deferred.reject;\n        deferred.resolve = (value) => {\n            settledPromises.push(deferred.promise);\n            rotateQueue();\n            return shimDeferredPromise(originalResolve(value));\n        };\n        deferred.reject = (reason) => {\n            settledPromises.push(deferred.promise);\n            rotateQueue();\n            return shimDeferredPromise(originalReject(reason));\n        };\n        return deferred;\n    };\n    const deferred = shimDeferredPromise((0, exports.createDeferredPromise)());\n    return { deferred, results };\n};\nexports.createDeferredPromiseWithStack = createDeferredPromiseWithStack;\n/**\n * Creates a Promise that will resolve after the given duration, along with\n * methods to start, clear, and reset the timeout.\n */\nconst createTimeoutPromise = (duration) => {\n    const { promise, resolve } = (0, exports.createDeferredPromise)();\n    let timeout;\n    // eslint-disable-next-line prefer-const\n    let ret;\n    const start = () => {\n        if (timeout)\n            return ret;\n        timeout = setTimeout(() => {\n            resolve();\n        }, duration);\n        return ret;\n    };\n    const clear = () => {\n        clearTimeout(timeout);\n        timeout = undefined;\n    };\n    const reset = () => {\n        clear();\n        return start();\n    };\n    ret = Object.assign(promise, { start, clear, reset });\n    return ret;\n};\nexports.createTimeoutPromise = createTimeoutPromise;\n/**\n * Take any function and safely promisify such that both synchronous and\n * asynchronous errors are caught and returned as a rejected Promise.\n *\n * The passed `fn` can be undefined to support functions that may conditionally\n * be defined.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst runAsPromise = (fn\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return Promise.resolve().then(fn);\n};\nexports.runAsPromise = runAsPromise;\n/**\n * Returns a Promise that resolve after the current event loop tick.\n */\nconst resolveNextTick = () => {\n    return new Promise((resolve) => setTimeout(resolve));\n};\nexports.resolveNextTick = resolveNextTick;\nconst retryWithBackoff = async (fn, opts) => {\n    var _a;\n    const maxAttempts = (opts === null || opts === void 0 ? void 0 : opts.maxAttempts) || 5;\n    const baseDelay = (_a = opts === null || opts === void 0 ? void 0 : opts.baseDelay) !== null && _a !== void 0 ? _a : 100;\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n        try {\n            return await fn();\n        }\n        catch (err) {\n            if (attempt >= maxAttempts) {\n                throw err;\n            }\n            const jitter = Math.random() * baseDelay;\n            const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n    }\n    throw new Error(\"Max retries reached; this should be unreachable.\");\n};\nexports.retryWithBackoff = retryWithBackoff;\n//# sourceMappingURL=promises.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3Byb21pc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcsNEJBQTRCLEdBQUcsc0NBQXNDLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3Byb21pc2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmV0cnlXaXRoQmFja29mZiA9IGV4cG9ydHMucmVzb2x2ZU5leHRUaWNrID0gZXhwb3J0cy5ydW5Bc1Byb21pc2UgPSBleHBvcnRzLmNyZWF0ZVRpbWVvdXRQcm9taXNlID0gZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2sgPSBleHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZSA9IGV4cG9ydHMucmVzb2x2ZUFmdGVyUGVuZGluZyA9IGV4cG9ydHMuY3JlYXRlRnJvemVuUHJvbWlzZSA9IHZvaWQgMDtcbi8qKlxuICogU29tZSBlbnZpcm9ubWVudHMgZG9uJ3QgYWxsb3cgYWNjZXNzIHRvIHRoZSBnbG9iYWwgcXVldWVNaWNyb3Rhc2soKS4gV2hpbGUgd2VcbiAqIGhhZCBhc3N1bWVkIHRoaXMgd2FzIG9ubHkgdHJ1ZSBmb3IgdGhvc2UgcG93ZXJlZCBieSBlYXJsaWVyIHZlcnNpb25zIG9mIE5vZGVcbiAqICg8MTQpIHRoYXQgd2UgZG9uJ3Qgb2ZmaWNpYWxseSBzdXBwb3J0LCBWZXJjZWwncyBFZGdlIEZ1bmN0aW9ucyBhbHNvIG9ic2N1cmVcbiAqIHRoZSBmdW5jdGlvbiBpbiBkZXYsIGV2ZW4gdGhvdWdoIHRoZSBwbGF0Zm9ybSBpdCdzIGJhc2VkIG9uIChDbG91ZGZsYXJlXG4gKiBXb3JrZXJzKSBhcHByb3ByaWF0ZWx5IGV4cG9zZXMgaXQuIEV2ZW4gd29yc2UsIHByb2R1Y3Rpb24gVmVyY2VsIEVkZ2VcbiAqIEZ1bmN0aW9ucyBjYW4gc2VlIHRoZSBmdW5jdGlvbiwgYnV0IGl0IGltbWVkaWF0ZWx5IGJsb3dzIHVwIHRoZSBmdW5jdGlvbiB3aGVuXG4gKiB1c2VkLlxuICpcbiAqIFRoZXJlZm9yZSwgd2UgY2FuIGZhbGwgYmFjayB0byBhIHJlYXNvbmFibGUgYWx0ZXJuYXRpdmUgb2ZcbiAqIGBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKWAgaW5zdGVhZC4gVGhpcyBfbWF5XyBiZSBzbGlnaHRseSBzbG93ZXIgaW4gbW9kZXJuXG4gKiBlbnZpcm9ubWVudHMsIGJ1dCBhdCBsZWFzdCB3ZSBjYW4gc3RpbGwgd29yayBpbiB0aGVzZSBlbnZpcm9ubWVudHMuXG4gKi9cbmNvbnN0IHNoaW1RdWV1ZU1pY3JvdGFzayA9IChjYWxsYmFjaykgPT4ge1xuICAgIHZvaWQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBgUHJvbWlzZWAgdGhhdCB3aWxsIG5ldmVyIHNldHRsZS5cbiAqXG4gKiBJdCBwdXJwb3NlZnVsbHkgY3JlYXRlcyBubyByZWZlcmVuY2VzIHRvIGByZXNvbHZlYCBvciBgcmVqZWN0YCBzbyB0aGF0IHRoZVxuICogcmV0dXJuZWQgYFByb21pc2VgIHdpbGwgcmVtYWluIHVuc2V0dGxlZCB1bnRpbCBpdCBmYWxscyBvdXQgb2Ygc2NvcGUgYW5kIGlzXG4gKiBnYXJiYWdlIGNvbGxlY3RlZC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIHdpdGhpbiB0cmFuc2llbnQgY2xvc3VyZXMgdG8gZmFrZSBhc3luY2hyb25vdXMgYWN0aW9uLCBzb1xuICogbG9uZyBhcyBpdCdzIGd1YXJhbnRlZWQgdGhhdCB0aGV5IHdpbGwgZmFsbCBvdXQgb2Ygc2NvcGUuXG4gKi9cbmNvbnN0IGNyZWF0ZUZyb3plblByb21pc2UgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHVuZGVmaW5lZCk7XG59O1xuZXhwb3J0cy5jcmVhdGVGcm96ZW5Qcm9taXNlID0gY3JlYXRlRnJvemVuUHJvbWlzZTtcbi8qKlxuICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgY3VycmVudCBldmVudCBsb29wJ3MgbWljcm90YXNrc1xuICogaGF2ZSBmaW5pc2hlZCwgYnV0IGJlZm9yZSB0aGUgbmV4dCBldmVudCBsb29wIHRpY2suXG4gKi9cbmNvbnN0IHJlc29sdmVBZnRlclBlbmRpbmcgPSAoY291bnQgPSAxMDApID0+IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHVzZXMgYSBicnV0ZSBmb3JjZSBpbXBsZW1lbnRhdGlvbiB0aGF0IHdpbGwgY29udGludWUgdG8gZW5xdWV1ZVxuICAgICAqIG1pY3JvdGFza3MgMTAgdGltZXMgYmVmb3JlIHJlc29sdmluZy4gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgbWljcm90YXNrXG4gICAgICogcXVldWUgaXMgZHJhaW5lZCwgZXZlbiBpZiB0aGUgbWljcm90YXNrIHF1ZXVlIGlzIGJlaW5nIG1hbmlwdWxhdGVkIGJ5IG90aGVyXG4gICAgICogY29kZS5cbiAgICAgKlxuICAgICAqIFdoaWxlIHRoaXMgc3RpbGwgZG9lc24ndCBndWFyYW50ZWUgdGhhdCB0aGUgbWljcm90YXNrIHF1ZXVlIGlzIGRyYWluZWQsXG4gICAgICogaXQncyBvdXIgYmVzdCBiZXQgZm9yIGdpdmluZyBvdGhlciBub24tY29udHJvbGxlZCBwcm9taXNlcyBhIGNoYW5jZSB0b1xuICAgICAqIHJlc29sdmUgYmVmb3JlIHdlIGNvbnRpbnVlIHdpdGhvdXQgcmVzb3J0aW5nIHRvIGZhbGxpbmcgaW4gdG8gdGhlIG5leHRcbiAgICAgKiB0aWNrLlxuICAgICAqL1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBzaGltUXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpKysgPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVyYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaXRlcmF0ZSgpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMucmVzb2x2ZUFmdGVyUGVuZGluZyA9IHJlc29sdmVBZnRlclBlbmRpbmc7XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgUHJvbWlzZSB0aGF0IGNhbiBiZSByZXNvbHZlZCBvciByZWplY3RlZCB3aXRoIHRoZVxuICogcmV0dXJuZWQgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBmdW5jdGlvbnMuXG4gKlxuICogUmVzb2x2aW5nIG9yIHJlamVjdGluZyB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBuZXcgc2V0IG9mIFByb21pc2UgY29udHJvbFxuICogZnVuY3Rpb25zLiBUaGVzZSBjYW4gYmUgaWdub3JlZCBpZiB0aGUgb3JpZ2luYWwgUHJvbWlzZSBpcyBhbGwgdGhhdCdzIG5lZWRlZC5cbiAqL1xuY29uc3QgY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gKCkgPT4ge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgICAgICByZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBfcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgpO1xuICAgICAgICB9O1xuICAgICAgICByZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBfcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogcmVzb2x2ZSwgcmVqZWN0OiByZWplY3QgfTtcbn07XG5leHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZTtcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGRlZmVycmVkIFByb21pc2UgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgd2l0aFxuICogdGhlIHJldHVybmVkIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zLlxuICpcbiAqIEZvciBlYWNoIFByb21pc2UgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgdGhpcyB3YXksIHRoaXMgd2lsbCBhbHNvIGtlZXAgYSBzdGFja1xuICogb2YgYWxsIHVuaGFuZGxlZCBQcm9taXNlcywgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXG4gKlxuICogT25jZSBhIFByb21pc2UgaXMgcmVhZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjay5cbiAqL1xuY29uc3QgY3JlYXRlRGVmZXJyZWRQcm9taXNlV2l0aFN0YWNrID0gKCkgPT4ge1xuICAgIGNvbnN0IHNldHRsZWRQcm9taXNlcyA9IFtdO1xuICAgIGxldCByb3RhdGVRdWV1ZSA9ICgpID0+IHsgfTtcbiAgICBjb25zdCByZXN1bHRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gc2V0dGxlZFByb21pc2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF9fYXdhaXQobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZVF1ZXVlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICBjb25zdCBzaGltRGVmZXJyZWRQcm9taXNlID0gKGRlZmVycmVkKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmVzb2x2ZSA9IGRlZmVycmVkLnJlc29sdmU7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmVqZWN0ID0gZGVmZXJyZWQucmVqZWN0O1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzZXR0bGVkUHJvbWlzZXMucHVzaChkZWZlcnJlZC5wcm9taXNlKTtcbiAgICAgICAgICAgIHJvdGF0ZVF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm4gc2hpbURlZmVycmVkUHJvbWlzZShvcmlnaW5hbFJlc29sdmUodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgc2V0dGxlZFByb21pc2VzLnB1c2goZGVmZXJyZWQucHJvbWlzZSk7XG4gICAgICAgICAgICByb3RhdGVRdWV1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNoaW1EZWZlcnJlZFByb21pc2Uob3JpZ2luYWxSZWplY3QocmVhc29uKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9O1xuICAgIGNvbnN0IGRlZmVycmVkID0gc2hpbURlZmVycmVkUHJvbWlzZSgoMCwgZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCkpO1xuICAgIHJldHVybiB7IGRlZmVycmVkLCByZXN1bHRzIH07XG59O1xuZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2sgPSBjcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2s7XG4vKipcbiAqIENyZWF0ZXMgYSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIGFmdGVyIHRoZSBnaXZlbiBkdXJhdGlvbiwgYWxvbmcgd2l0aFxuICogbWV0aG9kcyB0byBzdGFydCwgY2xlYXIsIGFuZCByZXNldCB0aGUgdGltZW91dC5cbiAqL1xuY29uc3QgY3JlYXRlVGltZW91dFByb21pc2UgPSAoZHVyYXRpb24pID0+IHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9ICgwLCBleHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKTtcbiAgICBsZXQgdGltZW91dDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHJldDtcbiAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0KCk7XG4gICAgfTtcbiAgICByZXQgPSBPYmplY3QuYXNzaWduKHByb21pc2UsIHsgc3RhcnQsIGNsZWFyLCByZXNldCB9KTtcbiAgICByZXR1cm4gcmV0O1xufTtcbmV4cG9ydHMuY3JlYXRlVGltZW91dFByb21pc2UgPSBjcmVhdGVUaW1lb3V0UHJvbWlzZTtcbi8qKlxuICogVGFrZSBhbnkgZnVuY3Rpb24gYW5kIHNhZmVseSBwcm9taXNpZnkgc3VjaCB0aGF0IGJvdGggc3luY2hyb25vdXMgYW5kXG4gKiBhc3luY2hyb25vdXMgZXJyb3JzIGFyZSBjYXVnaHQgYW5kIHJldHVybmVkIGFzIGEgcmVqZWN0ZWQgUHJvbWlzZS5cbiAqXG4gKiBUaGUgcGFzc2VkIGBmbmAgY2FuIGJlIHVuZGVmaW5lZCB0byBzdXBwb3J0IGZ1bmN0aW9ucyB0aGF0IG1heSBjb25kaXRpb25hbGx5XG4gKiBiZSBkZWZpbmVkLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgcnVuQXNQcm9taXNlID0gKGZuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pO1xufTtcbmV4cG9ydHMucnVuQXNQcm9taXNlID0gcnVuQXNQcm9taXNlO1xuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgbG9vcCB0aWNrLlxuICovXG5jb25zdCByZXNvbHZlTmV4dFRpY2sgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUpKTtcbn07XG5leHBvcnRzLnJlc29sdmVOZXh0VGljayA9IHJlc29sdmVOZXh0VGljaztcbmNvbnN0IHJldHJ5V2l0aEJhY2tvZmYgPSBhc3luYyAoZm4sIG9wdHMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLm1heEF0dGVtcHRzKSB8fCA1O1xuICAgIGNvbnN0IGJhc2VEZWxheSA9IChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5iYXNlRGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEwMDtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+PSBtYXhBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGppdHRlciA9IE1hdGgucmFuZG9tKCkgKiBiYXNlRGVsYXk7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSArIGppdHRlcjtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWF4IHJldHJpZXMgcmVhY2hlZDsgdGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXCIpO1xufTtcbmV4cG9ydHMucmV0cnlXaXRoQmFja29mZiA9IHJldHJ5V2l0aEJhY2tvZmY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/promises.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/stream.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/stream.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createStream = void 0;\nconst strings_js_1 = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/**\n * Creates a {@link ReadableStream} that sends a `value` every `interval`\n * milliseconds as a heartbeat, intended to keep a stream open.\n *\n * Returns the `stream` itself and a `finalize` function that can be used to\n * close the stream and send a final value.\n */\nconst createStream = (opts) => {\n    var _a, _b;\n    /**\n     * We need to resolve this promise with both the stream and the `finalize`\n     * function, but having them both instantiated synchronously is difficult, as\n     * we need access to the stream's internals too.\n     *\n     * We create this cheeky deferred promise to grab the internal `finalize`\n     * value. Be warned that simpler solutions may appear to compile, but fail at\n     * runtime due to variables not being assigned; make sure to test your code!\n     */\n    let passFinalize;\n    const finalizeP = new Promise((resolve) => {\n        passFinalize = resolve;\n    });\n    const interval = (_a = opts === null || opts === void 0 ? void 0 : opts.interval) !== null && _a !== void 0 ? _a : 3000;\n    const value = (_b = opts === null || opts === void 0 ? void 0 : opts.value) !== null && _b !== void 0 ? _b : \" \";\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n        try {\n            const stream = new ReadableStream({\n                start(controller) {\n                    const encoder = new TextEncoder();\n                    const heartbeat = setInterval(() => {\n                        controller.enqueue(encoder.encode(value));\n                    }, interval);\n                    const finalize = (data) => {\n                        clearInterval(heartbeat);\n                        // `data` may be a `Promise`. If it is, we need to wait for it to\n                        // resolve before sending it. To support this elegantly we'll always\n                        // assume it's a promise and handle that case.\n                        void Promise.resolve(data).then((resolvedData) => {\n                            controller.enqueue(encoder.encode((0, strings_js_1.stringify)(resolvedData)));\n                            controller.close();\n                        });\n                    };\n                    passFinalize(finalize);\n                },\n            });\n            resolve({ stream, finalize: await finalizeP });\n        }\n        catch (err) {\n            reject(err);\n        }\n    });\n};\nexports.createStream = createStream;\n//# sourceMappingURL=stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIscUJBQXFCLG1CQUFPLENBQUMscUVBQWM7QUFDM0M7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2Isc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4vc3RyaW5ncy5qc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0gdGhhdCBzZW5kcyBhIGB2YWx1ZWAgZXZlcnkgYGludGVydmFsYFxuICogbWlsbGlzZWNvbmRzIGFzIGEgaGVhcnRiZWF0LCBpbnRlbmRlZCB0byBrZWVwIGEgc3RyZWFtIG9wZW4uXG4gKlxuICogUmV0dXJucyB0aGUgYHN0cmVhbWAgaXRzZWxmIGFuZCBhIGBmaW5hbGl6ZWAgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0b1xuICogY2xvc2UgdGhlIHN0cmVhbSBhbmQgc2VuZCBhIGZpbmFsIHZhbHVlLlxuICovXG5jb25zdCBjcmVhdGVTdHJlYW0gPSAob3B0cykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byByZXNvbHZlIHRoaXMgcHJvbWlzZSB3aXRoIGJvdGggdGhlIHN0cmVhbSBhbmQgdGhlIGBmaW5hbGl6ZWBcbiAgICAgKiBmdW5jdGlvbiwgYnV0IGhhdmluZyB0aGVtIGJvdGggaW5zdGFudGlhdGVkIHN5bmNocm9ub3VzbHkgaXMgZGlmZmljdWx0LCBhc1xuICAgICAqIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBzdHJlYW0ncyBpbnRlcm5hbHMgdG9vLlxuICAgICAqXG4gICAgICogV2UgY3JlYXRlIHRoaXMgY2hlZWt5IGRlZmVycmVkIHByb21pc2UgdG8gZ3JhYiB0aGUgaW50ZXJuYWwgYGZpbmFsaXplYFxuICAgICAqIHZhbHVlLiBCZSB3YXJuZWQgdGhhdCBzaW1wbGVyIHNvbHV0aW9ucyBtYXkgYXBwZWFyIHRvIGNvbXBpbGUsIGJ1dCBmYWlsIGF0XG4gICAgICogcnVudGltZSBkdWUgdG8gdmFyaWFibGVzIG5vdCBiZWluZyBhc3NpZ25lZDsgbWFrZSBzdXJlIHRvIHRlc3QgeW91ciBjb2RlIVxuICAgICAqL1xuICAgIGxldCBwYXNzRmluYWxpemU7XG4gICAgY29uc3QgZmluYWxpemVQID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcGFzc0ZpbmFsaXplID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5pbnRlcnZhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMzAwMDtcbiAgICBjb25zdCB2YWx1ZSA9IChfYiA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy52YWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIgXCI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzLCBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYXJ0YmVhdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsaXplID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaGVhcnRiZWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkYXRhYCBtYXkgYmUgYSBgUHJvbWlzZWAuIElmIGl0IGlzLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIGJlZm9yZSBzZW5kaW5nIGl0LiBUbyBzdXBwb3J0IHRoaXMgZWxlZ2FudGx5IHdlJ2xsIGFsd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIGl0J3MgYSBwcm9taXNlIGFuZCBoYW5kbGUgdGhhdCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBQcm9taXNlLnJlc29sdmUoZGF0YSkudGhlbigocmVzb2x2ZWREYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKCgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KShyZXNvbHZlZERhdGEpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBhc3NGaW5hbGl6ZShmaW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHN0cmVhbSwgZmluYWxpemU6IGF3YWl0IGZpbmFsaXplUCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuY3JlYXRlU3RyZWFtID0gY3JlYXRlU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/strings.js":
/*!*************************************************!*\
  !*** ./node_modules/inngest/helpers/strings.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashSigningKey = exports.hashEventKey = exports.stringifyUnknown = exports.timeStr = exports.slugify = exports.stringify = void 0;\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst json_stringify_safe_1 = __importDefault(__webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\"));\nconst ms_1 = __importDefault(__webpack_require__(/*! ms */ \"(rsc)/./node_modules/inngest/node_modules/ms/index.js\"));\n/**\n * Safely `JSON.stringify()` an `input`, handling circular refernences and\n * removing `BigInt` values.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst stringify = (input) => {\n    return (0, json_stringify_safe_1.default)(input, (key, value) => {\n        if (typeof value !== \"bigint\") {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return value;\n        }\n    });\n};\nexports.stringify = stringify;\n/**\n * Returns a slugified string used to generate consistent IDs.\n *\n * This can be used to generate a consistent ID for a function when migrating\n * from v2 to v3 of the SDK.\n *\n * @public\n */\nconst slugify = (str) => {\n    const join = \"-\";\n    return str\n        .toLowerCase()\n        .replace(/[^a-z0-9-]+/g, join)\n        .replace(/-+/g, join)\n        .split(join)\n        .filter(Boolean)\n        .join(join);\n};\nexports.slugify = slugify;\nconst millisecond = 1;\nconst second = millisecond * 1000;\nconst minute = second * 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\n/**\n * A collection of periods in milliseconds and their suffixes used when creating\n * time strings.\n */\nconst periods = [\n    [\"w\", week],\n    [\"d\", day],\n    [\"h\", hour],\n    [\"m\", minute],\n    [\"s\", second],\n];\n/**\n * Convert a given `Date`, `number`, or `ms`-compatible `string` to a\n * Inngest sleep-compatible time string (e.g. `\"1d\"` or `\"2h3010s\"`).\n *\n * Can optionally provide a `now` date to use as the base for the calculation,\n * otherwise a new date will be created on invocation.\n */\nconst timeStr = (\n/**\n * The future date to use to convert to a time string.\n */\ninput) => {\n    if (input instanceof Date) {\n        return input.toISOString();\n    }\n    const milliseconds = typeof input === \"string\" ? (0, ms_1.default)(input) : input;\n    const [, timeStr] = periods.reduce(([num, str], [suffix, period]) => {\n        const numPeriods = Math.floor(num / period);\n        if (numPeriods > 0) {\n            return [num % period, `${str}${numPeriods}${suffix}`];\n        }\n        return [num, str];\n    }, [milliseconds, \"\"]);\n    return timeStr;\n};\nexports.timeStr = timeStr;\n/**\n * Given an unknown input, stringify it if it's a boolean, a number, or a\n * string, else return `undefined`.\n */\nconst stringifyUnknown = (input) => {\n    if (typeof input === \"boolean\" ||\n        typeof input === \"number\" ||\n        typeof input === \"string\") {\n        return input.toString();\n    }\n};\nexports.stringifyUnknown = stringifyUnknown;\nconst hashEventKey = (eventKey) => {\n    return (0, hash_js_1.sha256)().update(eventKey).digest(\"hex\");\n};\nexports.hashEventKey = hashEventKey;\nconst hashSigningKey = (signingKey) => {\n    var _a;\n    if (!signingKey) {\n        return \"\";\n    }\n    const prefix = ((_a = signingKey.match(/^signkey-[\\w]+-/)) === null || _a === void 0 ? void 0 : _a.shift()) || \"\";\n    const key = signingKey.replace(/^signkey-[\\w]+-/, \"\");\n    // Decode the key from its hex representation into a bytestream\n    return `${prefix}${(0, hash_js_1.sha256)().update(key, \"hex\").digest(\"hex\")}`;\n};\nexports.hashSigningKey = hashSigningKey;\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGlCQUFpQjtBQUNoSSxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBUztBQUNuQyw4Q0FBOEMsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDM0UsNkJBQTZCLG1CQUFPLENBQUMsaUVBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUksRUFBRSxXQUFXLEVBQUUsT0FBTztBQUMvRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTyxFQUFFLHlEQUF5RDtBQUNoRjtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmluZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hTaWduaW5nS2V5ID0gZXhwb3J0cy5oYXNoRXZlbnRLZXkgPSBleHBvcnRzLnN0cmluZ2lmeVVua25vd24gPSBleHBvcnRzLnRpbWVTdHIgPSBleHBvcnRzLnNsdWdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCJoYXNoLmpzXCIpO1xuY29uc3QganNvbl9zdHJpbmdpZnlfc2FmZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqc29uLXN0cmluZ2lmeS1zYWZlXCIpKTtcbmNvbnN0IG1zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1zXCIpKTtcbi8qKlxuICogU2FmZWx5IGBKU09OLnN0cmluZ2lmeSgpYCBhbiBgaW5wdXRgLCBoYW5kbGluZyBjaXJjdWxhciByZWZlcm5lbmNlcyBhbmRcbiAqIHJlbW92aW5nIGBCaWdJbnRgIHZhbHVlcy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IHN0cmluZ2lmeSA9IChpbnB1dCkgPT4ge1xuICAgIHJldHVybiAoMCwganNvbl9zdHJpbmdpZnlfc2FmZV8xLmRlZmF1bHQpKGlucHV0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuLyoqXG4gKiBSZXR1cm5zIGEgc2x1Z2lmaWVkIHN0cmluZyB1c2VkIHRvIGdlbmVyYXRlIGNvbnNpc3RlbnQgSURzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYSBjb25zaXN0ZW50IElEIGZvciBhIGZ1bmN0aW9uIHdoZW4gbWlncmF0aW5nXG4gKiBmcm9tIHYyIHRvIHYzIG9mIHRoZSBTREsuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBzbHVnaWZ5ID0gKHN0cikgPT4ge1xuICAgIGNvbnN0IGpvaW4gPSBcIi1cIjtcbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIC5yZXBsYWNlKC9bXmEtejAtOS1dKy9nLCBqb2luKVxuICAgICAgICAucmVwbGFjZSgvLSsvZywgam9pbilcbiAgICAgICAgLnNwbGl0KGpvaW4pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oam9pbik7XG59O1xuZXhwb3J0cy5zbHVnaWZ5ID0gc2x1Z2lmeTtcbmNvbnN0IG1pbGxpc2Vjb25kID0gMTtcbmNvbnN0IHNlY29uZCA9IG1pbGxpc2Vjb25kICogMTAwMDtcbmNvbnN0IG1pbnV0ZSA9IHNlY29uZCAqIDYwO1xuY29uc3QgaG91ciA9IG1pbnV0ZSAqIDYwO1xuY29uc3QgZGF5ID0gaG91ciAqIDI0O1xuY29uc3Qgd2VlayA9IGRheSAqIDc7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBwZXJpb2RzIGluIG1pbGxpc2Vjb25kcyBhbmQgdGhlaXIgc3VmZml4ZXMgdXNlZCB3aGVuIGNyZWF0aW5nXG4gKiB0aW1lIHN0cmluZ3MuXG4gKi9cbmNvbnN0IHBlcmlvZHMgPSBbXG4gICAgW1wid1wiLCB3ZWVrXSxcbiAgICBbXCJkXCIsIGRheV0sXG4gICAgW1wiaFwiLCBob3VyXSxcbiAgICBbXCJtXCIsIG1pbnV0ZV0sXG4gICAgW1wic1wiLCBzZWNvbmRdLFxuXTtcbi8qKlxuICogQ29udmVydCBhIGdpdmVuIGBEYXRlYCwgYG51bWJlcmAsIG9yIGBtc2AtY29tcGF0aWJsZSBgc3RyaW5nYCB0byBhXG4gKiBJbm5nZXN0IHNsZWVwLWNvbXBhdGlibGUgdGltZSBzdHJpbmcgKGUuZy4gYFwiMWRcImAgb3IgYFwiMmgzMDEwc1wiYCkuXG4gKlxuICogQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhIGBub3dgIGRhdGUgdG8gdXNlIGFzIHRoZSBiYXNlIGZvciB0aGUgY2FsY3VsYXRpb24sXG4gKiBvdGhlcndpc2UgYSBuZXcgZGF0ZSB3aWxsIGJlIGNyZWF0ZWQgb24gaW52b2NhdGlvbi5cbiAqL1xuY29uc3QgdGltZVN0ciA9IChcbi8qKlxuICogVGhlIGZ1dHVyZSBkYXRlIHRvIHVzZSB0byBjb252ZXJ0IHRvIGEgdGltZSBzdHJpbmcuXG4gKi9cbmlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gKDAsIG1zXzEuZGVmYXVsdCkoaW5wdXQpIDogaW5wdXQ7XG4gICAgY29uc3QgWywgdGltZVN0cl0gPSBwZXJpb2RzLnJlZHVjZSgoW251bSwgc3RyXSwgW3N1ZmZpeCwgcGVyaW9kXSkgPT4ge1xuICAgICAgICBjb25zdCBudW1QZXJpb2RzID0gTWF0aC5mbG9vcihudW0gLyBwZXJpb2QpO1xuICAgICAgICBpZiAobnVtUGVyaW9kcyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbbnVtICUgcGVyaW9kLCBgJHtzdHJ9JHtudW1QZXJpb2RzfSR7c3VmZml4fWBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbnVtLCBzdHJdO1xuICAgIH0sIFttaWxsaXNlY29uZHMsIFwiXCJdKTtcbiAgICByZXR1cm4gdGltZVN0cjtcbn07XG5leHBvcnRzLnRpbWVTdHIgPSB0aW1lU3RyO1xuLyoqXG4gKiBHaXZlbiBhbiB1bmtub3duIGlucHV0LCBzdHJpbmdpZnkgaXQgaWYgaXQncyBhIGJvb2xlYW4sIGEgbnVtYmVyLCBvciBhXG4gKiBzdHJpbmcsIGVsc2UgcmV0dXJuIGB1bmRlZmluZWRgLlxuICovXG5jb25zdCBzdHJpbmdpZnlVbmtub3duID0gKGlucHV0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgICAgdHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgIHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zdHJpbmdpZnlVbmtub3duID0gc3RyaW5naWZ5VW5rbm93bjtcbmNvbnN0IGhhc2hFdmVudEtleSA9IChldmVudEtleSkgPT4ge1xuICAgIHJldHVybiAoMCwgaGFzaF9qc18xLnNoYTI1NikoKS51cGRhdGUoZXZlbnRLZXkpLmRpZ2VzdChcImhleFwiKTtcbn07XG5leHBvcnRzLmhhc2hFdmVudEtleSA9IGhhc2hFdmVudEtleTtcbmNvbnN0IGhhc2hTaWduaW5nS2V5ID0gKHNpZ25pbmdLZXkpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFzaWduaW5nS2V5KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSAoKF9hID0gc2lnbmluZ0tleS5tYXRjaCgvXnNpZ25rZXktW1xcd10rLS8pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hpZnQoKSkgfHwgXCJcIjtcbiAgICBjb25zdCBrZXkgPSBzaWduaW5nS2V5LnJlcGxhY2UoL15zaWdua2V5LVtcXHddKy0vLCBcIlwiKTtcbiAgICAvLyBEZWNvZGUgdGhlIGtleSBmcm9tIGl0cyBoZXggcmVwcmVzZW50YXRpb24gaW50byBhIGJ5dGVzdHJlYW1cbiAgICByZXR1cm4gYCR7cHJlZml4fSR7KDAsIGhhc2hfanNfMS5zaGEyNTYpKCkudXBkYXRlKGtleSwgXCJoZXhcIikuZGlnZXN0KFwiaGV4XCIpfWA7XG59O1xuZXhwb3J0cy5oYXNoU2lnbmluZ0tleSA9IGhhc2hTaWduaW5nS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/strings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/temporal.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/helpers/temporal.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getISOString = exports.isTemporalZonedDateTime = exports.isTemporalInstant = exports.isTemporalDuration = void 0;\n/**\n * Asserts that the given `input` is a `Temporal.Duration` object.\n */\nconst isTemporalDuration = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.Duration\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalDuration = isTemporalDuration;\n/**\n * Asserts that the given `input` is a `Temporal.TimeZone` object.\n */\nconst isTemporalInstant = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.Instant\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalInstant = isTemporalInstant;\n/**\n * Asserts that the given `input` is a `Temporal.ZonedDateTime` object.\n */\nconst isTemporalZonedDateTime = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.ZonedDateTime\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalZonedDateTime = isTemporalZonedDateTime;\n/**\n * Converts a given `Date`, `string`, `Temporal.Instant`, or\n * `Temporal.ZonedDateTime` to an ISO 8601 string.\n */\nconst getISOString = (time) => {\n    if (typeof time === \"string\") {\n        return new Date(time).toISOString();\n    }\n    if (time instanceof Date) {\n        return time.toISOString();\n    }\n    if ((0, exports.isTemporalZonedDateTime)(time)) {\n        return time.toInstant().toString();\n    }\n    if ((0, exports.isTemporalInstant)(time)) {\n        return time.toString();\n    }\n    throw new TypeError(\"Invalid date input\");\n};\nexports.getISOString = getISOString;\n//# sourceMappingURL=temporal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3RlbXBvcmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3RlbXBvcmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJU09TdHJpbmcgPSBleHBvcnRzLmlzVGVtcG9yYWxab25lZERhdGVUaW1lID0gZXhwb3J0cy5pc1RlbXBvcmFsSW5zdGFudCA9IGV4cG9ydHMuaXNUZW1wb3JhbER1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGBpbnB1dGAgaXMgYSBgVGVtcG9yYWwuRHVyYXRpb25gIG9iamVjdC5cbiAqL1xuY29uc3QgaXNUZW1wb3JhbER1cmF0aW9uID0gKFxuLyoqXG4gKiBUaGUgaW5wdXQgdG8gY2hlY2suXG4gKi9cbmlucHV0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICByZXR1cm4gaW5wdXRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJUZW1wb3JhbC5EdXJhdGlvblwiO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5leHBvcnRzLmlzVGVtcG9yYWxEdXJhdGlvbiA9IGlzVGVtcG9yYWxEdXJhdGlvbjtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgaW5wdXRgIGlzIGEgYFRlbXBvcmFsLlRpbWVab25lYCBvYmplY3QuXG4gKi9cbmNvbnN0IGlzVGVtcG9yYWxJbnN0YW50ID0gKFxuLyoqXG4gKiBUaGUgaW5wdXQgdG8gY2hlY2suXG4gKi9cbmlucHV0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICByZXR1cm4gaW5wdXRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJUZW1wb3JhbC5JbnN0YW50XCI7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNUZW1wb3JhbEluc3RhbnQgPSBpc1RlbXBvcmFsSW5zdGFudDtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgaW5wdXRgIGlzIGEgYFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVgIG9iamVjdC5cbiAqL1xuY29uc3QgaXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUgPSAoXG4vKipcbiAqIFRoZSBpbnB1dCB0byBjaGVjay5cbiAqL1xuaW5wdXQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIHJldHVybiBpbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIlRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVcIjtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy5pc1RlbXBvcmFsWm9uZWREYXRlVGltZSA9IGlzVGVtcG9yYWxab25lZERhdGVUaW1lO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGdpdmVuIGBEYXRlYCwgYHN0cmluZ2AsIGBUZW1wb3JhbC5JbnN0YW50YCwgb3JcbiAqIGBUZW1wb3JhbC5ab25lZERhdGVUaW1lYCB0byBhbiBJU08gODYwMSBzdHJpbmcuXG4gKi9cbmNvbnN0IGdldElTT1N0cmluZyA9ICh0aW1lKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0aW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lKS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKCgwLCBleHBvcnRzLmlzVGVtcG9yYWxab25lZERhdGVUaW1lKSh0aW1lKSkge1xuICAgICAgICByZXR1cm4gdGltZS50b0luc3RhbnQoKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNUZW1wb3JhbEluc3RhbnQpKHRpbWUpKSB7XG4gICAgICAgIHJldHVybiB0aW1lLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGRhdGUgaW5wdXRcIik7XG59O1xuZXhwb3J0cy5nZXRJU09TdHJpbmcgPSBnZXRJU09TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wb3JhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/temporal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/index.js":
/*!***************************************!*\
  !*** ./node_modules/inngest/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * The primary entrypoint for the Inngest SDK. This provides all the necessary\n * exports to create, run, and trigger Inngest functions.\n *\n * Typical usage involves creating a new Inngest client with `Inngest`, and then\n * using the client to create functions, middleware, and other tools.\n *\n * See {@link https://www.inngest.com/docs} for more information.\n *\n * @example Create an Inngest client\n * ```ts\n * const inngest = new Inngest({\n *   id: \"my-app-id\",\n * });\n * ```\n *\n * @example Create an Inngest function\n * ```ts\n * const myFn = inngest.createFunction({\n *  id: \"my-function\",\n * }, {\n *   event: \"user/created\",\n * }, async ({ event, step }) => {\n *   console.log(\"User created:\", event.data);\n * });\n * ```\n *\n * @example Send an event\n * ```ts\n * await inngest.send({\n *   name: \"user/created\",\n *   data: {\n *     id: \"123\",\n *   },\n * });\n * ```\n *\n * @module\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = exports.ProxyLogger = exports.dependencyInjectionMiddleware = exports.slugify = exports.queryKeys = exports.internalEvents = exports.headerKeys = exports.StepError = exports.RetryAfterError = exports.NonRetriableError = exports.InngestMiddleware = exports.referenceFunction = exports.InngestCommHandler = exports.Inngest = exports.EventSchemas = void 0;\n__exportStar(__webpack_require__(/*! @inngest/ai */ \"(rsc)/./node_modules/@inngest/ai/dist/index.js\"), exports);\nvar EventSchemas_js_1 = __webpack_require__(/*! ./components/EventSchemas.js */ \"(rsc)/./node_modules/inngest/components/EventSchemas.js\");\nObject.defineProperty(exports, \"EventSchemas\", ({ enumerable: true, get: function () { return EventSchemas_js_1.EventSchemas; } }));\nvar Fetch_js_1 = __webpack_require__(/*! ./components/Fetch.js */ \"(rsc)/./node_modules/inngest/components/Fetch.js\");\nObject.defineProperty(exports, \"fetch\", ({ enumerable: true, get: function () { return Fetch_js_1.fetch; } }));\nvar Inngest_js_1 = __webpack_require__(/*! ./components/Inngest.js */ \"(rsc)/./node_modules/inngest/components/Inngest.js\");\nObject.defineProperty(exports, \"Inngest\", ({ enumerable: true, get: function () { return Inngest_js_1.Inngest; } }));\nvar InngestCommHandler_js_1 = __webpack_require__(/*! ./components/InngestCommHandler.js */ \"(rsc)/./node_modules/inngest/components/InngestCommHandler.js\");\nObject.defineProperty(exports, \"InngestCommHandler\", ({ enumerable: true, get: function () { return InngestCommHandler_js_1.InngestCommHandler; } }));\nvar InngestFunctionReference_js_1 = __webpack_require__(/*! ./components/InngestFunctionReference.js */ \"(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\");\nObject.defineProperty(exports, \"referenceFunction\", ({ enumerable: true, get: function () { return InngestFunctionReference_js_1.referenceFunction; } }));\nvar InngestMiddleware_js_1 = __webpack_require__(/*! ./components/InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nObject.defineProperty(exports, \"InngestMiddleware\", ({ enumerable: true, get: function () { return InngestMiddleware_js_1.InngestMiddleware; } }));\nvar NonRetriableError_js_1 = __webpack_require__(/*! ./components/NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nObject.defineProperty(exports, \"NonRetriableError\", ({ enumerable: true, get: function () { return NonRetriableError_js_1.NonRetriableError; } }));\nvar RetryAfterError_js_1 = __webpack_require__(/*! ./components/RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nObject.defineProperty(exports, \"RetryAfterError\", ({ enumerable: true, get: function () { return RetryAfterError_js_1.RetryAfterError; } }));\nvar StepError_js_1 = __webpack_require__(/*! ./components/StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nObject.defineProperty(exports, \"StepError\", ({ enumerable: true, get: function () { return StepError_js_1.StepError; } }));\nvar consts_js_1 = __webpack_require__(/*! ./helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nObject.defineProperty(exports, \"headerKeys\", ({ enumerable: true, get: function () { return consts_js_1.headerKeys; } }));\nObject.defineProperty(exports, \"internalEvents\", ({ enumerable: true, get: function () { return consts_js_1.internalEvents; } }));\nObject.defineProperty(exports, \"queryKeys\", ({ enumerable: true, get: function () { return consts_js_1.queryKeys; } }));\nvar strings_js_1 = __webpack_require__(/*! ./helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nObject.defineProperty(exports, \"slugify\", ({ enumerable: true, get: function () { return strings_js_1.slugify; } }));\nvar dependencyInjection_js_1 = __webpack_require__(/*! ./middleware/dependencyInjection.js */ \"(rsc)/./node_modules/inngest/middleware/dependencyInjection.js\");\nObject.defineProperty(exports, \"dependencyInjectionMiddleware\", ({ enumerable: true, get: function () { return dependencyInjection_js_1.dependencyInjectionMiddleware; } }));\nvar logger_js_1 = __webpack_require__(/*! ./middleware/logger.js */ \"(rsc)/./node_modules/inngest/middleware/logger.js\");\nObject.defineProperty(exports, \"ProxyLogger\", ({ enumerable: true, get: function () { return logger_js_1.ProxyLogger; } }));\nvar version_js_1 = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nObject.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return version_js_1.version; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJLFdBQVcsYUFBYTtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsbUJBQW1CLEdBQUcscUNBQXFDLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxvQkFBb0I7QUFDelcsYUFBYSxtQkFBTyxDQUFDLG1FQUFhO0FBQ2xDLHdCQUF3QixtQkFBTyxDQUFDLDZGQUE4QjtBQUM5RCxnREFBK0MsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDakksaUJBQWlCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2hELHlDQUF3QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM1RyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBeUI7QUFDcEQsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILDhCQUE4QixtQkFBTyxDQUFDLHlHQUFvQztBQUMxRSxzREFBcUQsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDbkosb0NBQW9DLG1CQUFPLENBQUMscUhBQTBDO0FBQ3RGLHFEQUFvRCxFQUFFLHFDQUFxQywyREFBMkQsRUFBQztBQUN2Siw2QkFBNkIsbUJBQU8sQ0FBQyx1R0FBbUM7QUFDeEUscURBQW9ELEVBQUUscUNBQXFDLG9EQUFvRCxFQUFDO0FBQ2hKLDZCQUE2QixtQkFBTyxDQUFDLHVHQUFtQztBQUN4RSxxREFBb0QsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDaEosMkJBQTJCLG1CQUFPLENBQUMsbUdBQWlDO0FBQ3BFLG1EQUFrRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUMxSSxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBMkI7QUFDeEQsNkNBQTRDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3hILGtCQUFrQixtQkFBTyxDQUFDLDJFQUFxQjtBQUMvQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDdkgsa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBc0I7QUFDakQsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILCtCQUErQixtQkFBTyxDQUFDLDJHQUFxQztBQUM1RSxpRUFBZ0UsRUFBRSxxQ0FBcUMsa0VBQWtFLEVBQUM7QUFDMUssa0JBQWtCLG1CQUFPLENBQUMsaUZBQXdCO0FBQ2xELCtDQUE4QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN6SCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBYztBQUN6QywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFRoZSBwcmltYXJ5IGVudHJ5cG9pbnQgZm9yIHRoZSBJbm5nZXN0IFNESy4gVGhpcyBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeVxuICogZXhwb3J0cyB0byBjcmVhdGUsIHJ1biwgYW5kIHRyaWdnZXIgSW5uZ2VzdCBmdW5jdGlvbnMuXG4gKlxuICogVHlwaWNhbCB1c2FnZSBpbnZvbHZlcyBjcmVhdGluZyBhIG5ldyBJbm5nZXN0IGNsaWVudCB3aXRoIGBJbm5nZXN0YCwgYW5kIHRoZW5cbiAqIHVzaW5nIHRoZSBjbGllbnQgdG8gY3JlYXRlIGZ1bmN0aW9ucywgbWlkZGxld2FyZSwgYW5kIG90aGVyIHRvb2xzLlxuICpcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jc30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGV4YW1wbGUgQ3JlYXRlIGFuIElubmdlc3QgY2xpZW50XG4gKiBgYGB0c1xuICogY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAqICAgaWQ6IFwibXktYXBwLWlkXCIsXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIENyZWF0ZSBhbiBJbm5nZXN0IGZ1bmN0aW9uXG4gKiBgYGB0c1xuICogY29uc3QgbXlGbiA9IGlubmdlc3QuY3JlYXRlRnVuY3Rpb24oe1xuICogIGlkOiBcIm15LWZ1bmN0aW9uXCIsXG4gKiB9LCB7XG4gKiAgIGV2ZW50OiBcInVzZXIvY3JlYXRlZFwiLFxuICogfSwgYXN5bmMgKHsgZXZlbnQsIHN0ZXAgfSkgPT4ge1xuICogICBjb25zb2xlLmxvZyhcIlVzZXIgY3JlYXRlZDpcIiwgZXZlbnQuZGF0YSk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIFNlbmQgYW4gZXZlbnRcbiAqIGBgYHRzXG4gKiBhd2FpdCBpbm5nZXN0LnNlbmQoe1xuICogICBuYW1lOiBcInVzZXIvY3JlYXRlZFwiLFxuICogICBkYXRhOiB7XG4gKiAgICAgaWQ6IFwiMTIzXCIsXG4gKiAgIH0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGVcbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLlByb3h5TG9nZ2VyID0gZXhwb3J0cy5kZXBlbmRlbmN5SW5qZWN0aW9uTWlkZGxld2FyZSA9IGV4cG9ydHMuc2x1Z2lmeSA9IGV4cG9ydHMucXVlcnlLZXlzID0gZXhwb3J0cy5pbnRlcm5hbEV2ZW50cyA9IGV4cG9ydHMuaGVhZGVyS2V5cyA9IGV4cG9ydHMuU3RlcEVycm9yID0gZXhwb3J0cy5SZXRyeUFmdGVyRXJyb3IgPSBleHBvcnRzLk5vblJldHJpYWJsZUVycm9yID0gZXhwb3J0cy5Jbm5nZXN0TWlkZGxld2FyZSA9IGV4cG9ydHMucmVmZXJlbmNlRnVuY3Rpb24gPSBleHBvcnRzLklubmdlc3RDb21tSGFuZGxlciA9IGV4cG9ydHMuSW5uZ2VzdCA9IGV4cG9ydHMuRXZlbnRTY2hlbWFzID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAaW5uZ2VzdC9haVwiKSwgZXhwb3J0cyk7XG52YXIgRXZlbnRTY2hlbWFzX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0V2ZW50U2NoZW1hcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50U2NoZW1hc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRXZlbnRTY2hlbWFzX2pzXzEuRXZlbnRTY2hlbWFzOyB9IH0pO1xudmFyIEZldGNoX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0ZldGNoLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmV0Y2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZldGNoX2pzXzEuZmV0Y2g7IH0gfSk7XG52YXIgSW5uZ2VzdF9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Jbm5nZXN0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5uZ2VzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5uZ2VzdF9qc18xLklubmdlc3Q7IH0gfSk7XG52YXIgSW5uZ2VzdENvbW1IYW5kbGVyX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubmdlc3RDb21tSGFuZGxlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5uZ2VzdENvbW1IYW5kbGVyX2pzXzEuSW5uZ2VzdENvbW1IYW5kbGVyOyB9IH0pO1xudmFyIElubmdlc3RGdW5jdGlvblJlZmVyZW5jZV9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWZlcmVuY2VGdW5jdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlX2pzXzEucmVmZXJlbmNlRnVuY3Rpb247IH0gfSk7XG52YXIgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbm5nZXN0TWlkZGxld2FyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5Jbm5nZXN0TWlkZGxld2FyZTsgfSB9KTtcbnZhciBOb25SZXRyaWFibGVFcnJvcl9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Ob25SZXRyaWFibGVFcnJvci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vblJldHJpYWJsZUVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yOyB9IH0pO1xudmFyIFJldHJ5QWZ0ZXJFcnJvcl9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9SZXRyeUFmdGVyRXJyb3IuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXRyeUFmdGVyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJldHJ5QWZ0ZXJFcnJvcl9qc18xLlJldHJ5QWZ0ZXJFcnJvcjsgfSB9KTtcbnZhciBTdGVwRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvU3RlcEVycm9yLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RlcEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTdGVwRXJyb3JfanNfMS5TdGVwRXJyb3I7IH0gfSk7XG52YXIgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhlYWRlcktleXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0c19qc18xLmhlYWRlcktleXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlcm5hbEV2ZW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RzX2pzXzEuaW50ZXJuYWxFdmVudHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJxdWVyeUtleXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0c19qc18xLnF1ZXJ5S2V5czsgfSB9KTtcbnZhciBzdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL3N0cmluZ3MuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzbHVnaWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzX2pzXzEuc2x1Z2lmeTsgfSB9KTtcbnZhciBkZXBlbmRlbmN5SW5qZWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9taWRkbGV3YXJlL2RlcGVuZGVuY3lJbmplY3Rpb24uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXBlbmRlbmN5SW5qZWN0aW9uTWlkZGxld2FyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVwZW5kZW5jeUluamVjdGlvbl9qc18xLmRlcGVuZGVuY3lJbmplY3Rpb25NaWRkbGV3YXJlOyB9IH0pO1xudmFyIGxvZ2dlcl9qc18xID0gcmVxdWlyZShcIi4vbWlkZGxld2FyZS9sb2dnZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm94eUxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2VyX2pzXzEuUHJveHlMb2dnZXI7IH0gfSk7XG52YXIgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlcnNpb25fanNfMS52ZXJzaW9uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/middleware/dependencyInjection.js":
/*!****************************************************************!*\
  !*** ./node_modules/inngest/middleware/dependencyInjection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dependencyInjectionMiddleware = void 0;\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../components/InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/**\n * Adds properties to the function input for every function created using this\n * app.\n */\n// We can use `const` here yet due to TS constraints.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst dependencyInjectionMiddleware = (\n/**\n * The context to inject into the function input.\n */\nctx) => {\n    return new InngestMiddleware_js_1.InngestMiddleware({\n        name: \"Inngest: Dependency Injection\",\n        init() {\n            return {\n                onFunctionRun() {\n                    return {\n                        transformInput() {\n                            return {\n                                ctx,\n                            };\n                        },\n                    };\n                },\n            };\n        },\n    });\n};\nexports.dependencyInjectionMiddleware = dependencyInjectionMiddleware;\n//# sourceMappingURL=dependencyInjection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2RlcGVuZGVuY3lJbmplY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLCtCQUErQixtQkFBTyxDQUFDLHdHQUFvQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EscUNBQXFDO0FBQ3JDIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L21pZGRsZXdhcmUvZGVwZW5kZW5jeUluamVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVwZW5kZW5jeUluamVjdGlvbk1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBJbm5nZXN0TWlkZGxld2FyZV9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG4vKipcbiAqIEFkZHMgcHJvcGVydGllcyB0byB0aGUgZnVuY3Rpb24gaW5wdXQgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNyZWF0ZWQgdXNpbmcgdGhpc1xuICogYXBwLlxuICovXG4vLyBXZSBjYW4gdXNlIGBjb25zdGAgaGVyZSB5ZXQgZHVlIHRvIFRTIGNvbnN0cmFpbnRzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGRlcGVuZGVuY3lJbmplY3Rpb25NaWRkbGV3YXJlID0gKFxuLyoqXG4gKiBUaGUgY29udGV4dCB0byBpbmplY3QgaW50byB0aGUgZnVuY3Rpb24gaW5wdXQuXG4gKi9cbmN0eCkgPT4ge1xuICAgIHJldHVybiBuZXcgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5Jbm5nZXN0TWlkZGxld2FyZSh7XG4gICAgICAgIG5hbWU6IFwiSW5uZ2VzdDogRGVwZW5kZW5jeSBJbmplY3Rpb25cIixcbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb25GdW5jdGlvblJ1bigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5leHBvcnRzLmRlcGVuZGVuY3lJbmplY3Rpb25NaWRkbGV3YXJlID0gZGVwZW5kZW5jeUluamVjdGlvbk1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmN5SW5qZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/middleware/dependencyInjection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/middleware/logger.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/middleware/logger.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProxyLogger = exports.DefaultLogger = void 0;\nclass DefaultLogger {\n    info(...args) {\n        console.info(...args);\n    }\n    warn(...args) {\n        console.warn(...args);\n    }\n    error(...args) {\n        console.error(...args);\n    }\n    debug(...args) {\n        console.debug(...args);\n    }\n}\nexports.DefaultLogger = DefaultLogger;\n/**\n * ProxyLogger aims to provide a thin wrapper on user's provided logger.\n * It's expected to be turned on and off based on the function execution\n * context, so it doesn't result in duplicated logging.\n *\n * And also attempt to allow enough time for the logger to flush all logs.\n *\n * @public\n */\nclass ProxyLogger {\n    constructor(logger) {\n        this.enabled = false;\n        this.logger = logger;\n        // Return a Proxy to forward arbitrary property access to the underlying\n        // logger. For example, if the user provides a logger that has a `foo`\n        // method, they can call `foo` on the ProxyLogger and it will call the\n        // underlying logger's `foo` method.\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                // Handle ProxyLogger's own methods/properties.\n                if (prop in target) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Forward property access to the underlying logger.\n                return Reflect.get(target.logger, prop, receiver);\n            },\n        });\n    }\n    info(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.info(...args);\n    }\n    warn(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.warn(...args);\n    }\n    error(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.error(...args);\n    }\n    debug(...args) {\n        // there are loggers that don't implement \"debug\" by default\n        if (!this.enabled || !(typeof this.logger.debug === \"function\"))\n            return;\n        this.logger.debug(...args);\n    }\n    enable() {\n        this.enabled = true;\n    }\n    disable() {\n        this.enabled = false;\n    }\n    async flush() {\n        // Allow 1s for the provided logger to handle flushing since the ones that do\n        // flushing usually has some kind of timeout of up to 1s.\n        //\n        // TODO:\n        // This should only happen when using a serverless environment because it's very\n        // costly from the compute perspective.\n        // server runtimes should just let the logger do their thing since most of them\n        // should have already figured what to do in those environments, be it threading or\n        // something else.\n        if (this.logger.constructor.name !== DefaultLogger.name) {\n            await new Promise((resolve) => {\n                setTimeout(() => resolve(null), 1000);\n            });\n        }\n    }\n}\nexports.ProxyLogger = ProxyLogger;\n//# sourceMappingURL=logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3QvbWlkZGxld2FyZS9sb2dnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb3h5TG9nZ2VyID0gZXhwb3J0cy5EZWZhdWx0TG9nZ2VyID0gdm9pZCAwO1xuY2xhc3MgRGVmYXVsdExvZ2dlciB7XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyguLi5hcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybiguLi5hcmdzKTtcbiAgICB9XG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoLi4uYXJncyk7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0TG9nZ2VyID0gRGVmYXVsdExvZ2dlcjtcbi8qKlxuICogUHJveHlMb2dnZXIgYWltcyB0byBwcm92aWRlIGEgdGhpbiB3cmFwcGVyIG9uIHVzZXIncyBwcm92aWRlZCBsb2dnZXIuXG4gKiBJdCdzIGV4cGVjdGVkIHRvIGJlIHR1cm5lZCBvbiBhbmQgb2ZmIGJhc2VkIG9uIHRoZSBmdW5jdGlvbiBleGVjdXRpb25cbiAqIGNvbnRleHQsIHNvIGl0IGRvZXNuJ3QgcmVzdWx0IGluIGR1cGxpY2F0ZWQgbG9nZ2luZy5cbiAqXG4gKiBBbmQgYWxzbyBhdHRlbXB0IHRvIGFsbG93IGVub3VnaCB0aW1lIGZvciB0aGUgbG9nZ2VyIHRvIGZsdXNoIGFsbCBsb2dzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUHJveHlMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRvIGZvcndhcmQgYXJiaXRyYXJ5IHByb3BlcnR5IGFjY2VzcyB0byB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBsb2dnZXIuIEZvciBleGFtcGxlLCBpZiB0aGUgdXNlciBwcm92aWRlcyBhIGxvZ2dlciB0aGF0IGhhcyBhIGBmb29gXG4gICAgICAgIC8vIG1ldGhvZCwgdGhleSBjYW4gY2FsbCBgZm9vYCBvbiB0aGUgUHJveHlMb2dnZXIgYW5kIGl0IHdpbGwgY2FsbCB0aGVcbiAgICAgICAgLy8gdW5kZXJseWluZyBsb2dnZXIncyBgZm9vYCBtZXRob2QuXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgUHJveHlMb2dnZXIncyBvd24gbWV0aG9kcy9wcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvcndhcmQgcHJvcGVydHkgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIGxvZ2dlci5cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LmxvZ2dlciwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluZm8oLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyguLi5hcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvciguLi5hcmdzKTtcbiAgICB9XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICAvLyB0aGVyZSBhcmUgbG9nZ2VycyB0aGF0IGRvbid0IGltcGxlbWVudCBcImRlYnVnXCIgYnkgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhKHR5cGVvZiB0aGlzLmxvZ2dlci5kZWJ1ZyA9PT0gXCJmdW5jdGlvblwiKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoLi4uYXJncyk7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgICAvLyBBbGxvdyAxcyBmb3IgdGhlIHByb3ZpZGVkIGxvZ2dlciB0byBoYW5kbGUgZmx1c2hpbmcgc2luY2UgdGhlIG9uZXMgdGhhdCBkb1xuICAgICAgICAvLyBmbHVzaGluZyB1c3VhbGx5IGhhcyBzb21lIGtpbmQgb2YgdGltZW91dCBvZiB1cCB0byAxcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gd2hlbiB1c2luZyBhIHNlcnZlcmxlc3MgZW52aXJvbm1lbnQgYmVjYXVzZSBpdCdzIHZlcnlcbiAgICAgICAgLy8gY29zdGx5IGZyb20gdGhlIGNvbXB1dGUgcGVyc3BlY3RpdmUuXG4gICAgICAgIC8vIHNlcnZlciBydW50aW1lcyBzaG91bGQganVzdCBsZXQgdGhlIGxvZ2dlciBkbyB0aGVpciB0aGluZyBzaW5jZSBtb3N0IG9mIHRoZW1cbiAgICAgICAgLy8gc2hvdWxkIGhhdmUgYWxyZWFkeSBmaWd1cmVkIHdoYXQgdG8gZG8gaW4gdGhvc2UgZW52aXJvbm1lbnRzLCBiZSBpdCB0aHJlYWRpbmcgb3JcbiAgICAgICAgLy8gc29tZXRoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0aGlzLmxvZ2dlci5jb25zdHJ1Y3Rvci5uYW1lICE9PSBEZWZhdWx0TG9nZ2VyLm5hbWUpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKG51bGwpLCAxMDAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Qcm94eUxvZ2dlciA9IFByb3h5TG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/middleware/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/next.js":
/*!**************************************!*\
  !*** ./node_modules/inngest/next.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * An adapter for Next.js to serve and register any declared functions with\n * Inngest, making them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serve = exports.frameworkName = void 0;\nconst InngestCommHandler_js_1 = __webpack_require__(/*! ./components/InngestCommHandler.js */ \"(rsc)/./node_modules/inngest/components/InngestCommHandler.js\");\nconst env_js_1 = __webpack_require__(/*! ./helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/**\n * The name of the framework, used to identify the framework in Inngest\n * dashboards and during testing.\n */\nexports.frameworkName = \"nextjs\";\nconst isRecord = (val) => {\n    return typeof val === \"object\" && val !== null;\n};\nconst isFunction = (val) => {\n    return typeof val === \"function\";\n};\nconst isNext12ApiResponse = (val) => {\n    return (isRecord(val) &&\n        isFunction(val.setHeader) &&\n        isFunction(val.status) &&\n        isFunction(val.send));\n};\n/**\n * In Next.js, serve and register any declared functions with Inngest, making\n * them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @public\n */\n// Has explicit return type to avoid JSR-defined \"slow types\"\nconst serve = (options) => {\n    const handler = new InngestCommHandler_js_1.InngestCommHandler(Object.assign(Object.assign({ frameworkName: exports.frameworkName }, options), { handler: (reqMethod, ...args) => {\n            const [expectedReq, res] = args;\n            const req = expectedReq;\n            const getHeader = (key) => {\n                const header = typeof req.headers.get === \"function\"\n                    ? req.headers.get(key)\n                    : req.headers[key];\n                return Array.isArray(header) ? header[0] : header;\n            };\n            return {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                body: () => (typeof req.json === \"function\" ? req.json() : req.body),\n                headers: getHeader,\n                method: () => {\n                    /**\n                     * `req.method`, though types say otherwise, is not available in Next.js\n                     * 13 {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}.\n                     *\n                     * Therefore, we must try to set the method ourselves where we know it.\n                     */\n                    const method = reqMethod || req.method || \"\";\n                    return method;\n                },\n                isProduction: () => {\n                    /**\n                     * Vercel Edge Functions do not allow dynamic access to environment\n                     * variables, so we'll manage production checks directly here.\n                     *\n                     * We try/catch to avoid situations where Next.js is being used in\n                     * environments where `process.env` is not accessible or polyfilled.\n                     */\n                    try {\n                        // eslint-disable-next-line @inngest/internal/process-warn\n                        const isProd = \"development\" === \"production\";\n                        return isProd;\n                    }\n                    catch (err) {\n                        // no-op\n                    }\n                },\n                queryString: (key, url) => {\n                    var _a;\n                    const qs = ((_a = req.query) === null || _a === void 0 ? void 0 : _a[key]) || url.searchParams.get(key);\n                    return Array.isArray(qs) ? qs[0] : qs;\n                },\n                url: () => {\n                    let absoluteUrl;\n                    try {\n                        absoluteUrl = new URL(req.url);\n                    }\n                    catch (_a) {\n                        // no-op\n                    }\n                    if (absoluteUrl) {\n                        /**\n                         * `req.url` here should may be the full URL, including query string.\n                         * There are some caveats, however, where Next.js will obfuscate\n                         * the host. For example, in the case of `host.docker.internal`,\n                         * Next.js will instead set the host here to `localhost`.\n                         *\n                         * To avoid this, we'll try to parse the URL from `req.url`, but\n                         * also use the `host` header if it's available.\n                         */\n                        const host = options.serveHost || getHeader(\"host\");\n                        if (host) {\n                            const hostWithProtocol = new URL(host.includes(\"://\") ? host : `${absoluteUrl.protocol}//${host}`);\n                            absoluteUrl.protocol = hostWithProtocol.protocol;\n                            absoluteUrl.host = hostWithProtocol.host;\n                            absoluteUrl.port = hostWithProtocol.port;\n                            absoluteUrl.username = hostWithProtocol.username;\n                            absoluteUrl.password = hostWithProtocol.password;\n                        }\n                        return absoluteUrl;\n                    }\n                    let scheme = \"https\";\n                    const host = options.serveHost || getHeader(\"host\") || \"\";\n                    try {\n                        // eslint-disable-next-line @inngest/internal/process-warn\n                        if (true) {\n                            scheme = \"http\";\n                        }\n                    }\n                    catch (err) {\n                        // no-op\n                    }\n                    const url = new URL(req.url, `${scheme}://${host}`);\n                    return url;\n                },\n                transformResponse: ({ body, headers, status }) => {\n                    /**\n                     * Carefully attempt to set headers and data on the response object\n                     * for Next.js 12 support.\n                     *\n                     * This also assumes that we're not using Next.js 15, where the `res`\n                     * object is repopulated as a `RouteContext` object. We expect these\n                     * methods to NOT be defined in Next.js 15.\n                     *\n                     * We could likely use `instanceof ServerResponse` to better check the\n                     * type of this, though Next.js 12 had issues with this due to not\n                     * instantiating the response correctly.\n                     */\n                    if (isNext12ApiResponse(res)) {\n                        for (const [key, value] of Object.entries(headers)) {\n                            res.setHeader(key, value);\n                        }\n                        res.status(status);\n                        res.send(body);\n                        /**\n                         * If we're here, we're in a serverless endpoint (not edge), so\n                         * we've correctly sent the response and can return `undefined`.\n                         *\n                         * Next.js 13 edge requires that the return value is typed as\n                         * `Response`, so we still enforce that as we cannot dynamically\n                         * adjust typing based on the environment.\n                         */\n                        return undefined;\n                    }\n                    /**\n                     * If we're here, we're in an edge environment and need to return a\n                     * `Response` object.\n                     *\n                     * We also don't know if the current environment has a native\n                     * `Response` object, so we'll grab that first.\n                     */\n                    const Res = (0, env_js_1.getResponse)();\n                    return new Res(body, { status, headers });\n                },\n                transformStreamingResponse: ({ body, headers, status }) => {\n                    return new Response(body, { status, headers });\n                },\n            };\n        } }));\n    /**\n     * Next.js 13 uses\n     * {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}\n     * to declare API routes instead of a generic catch-all method that was\n     * available using the `pages/api` directory.\n     *\n     * This means that users must now export a function for each method supported\n     * by the endpoint. For us, this means requiring a user explicitly exports\n     * `GET`, `POST`, and `PUT` functions.\n     *\n     * Because of this, we'll add circular references to those property names of\n     * the returned handler, meaning we can write some succinct code to export\n     * them. Thanks, @goodoldneon.\n     *\n     * @example\n     * ```ts\n     * export const { GET, POST, PUT } = serve(...);\n     * ```\n     *\n     * See {@link https://beta.nextjs.org/docs/routing/route-handlers}\n     */\n    const baseFn = handler.createHandler();\n    const fn = baseFn.bind(null, undefined);\n    /**\n     * Ensure we have a non-variadic length to avoid issues with forced type\n     * checking.\n     */\n    Object.defineProperty(fn, \"length\", { value: 1 });\n    const handlerFn = Object.defineProperties(fn, {\n        GET: { value: baseFn.bind(null, \"GET\") },\n        POST: { value: baseFn.bind(null, \"POST\") },\n        PUT: { value: baseFn.bind(null, \"PUT\") },\n    });\n    return handlerFn;\n};\nexports.serve = serve;\n//# sourceMappingURL=next.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9uZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLHFCQUFxQjtBQUNyQyxnQ0FBZ0MsbUJBQU8sQ0FBQyx5R0FBb0M7QUFDNUUsaUJBQWlCLG1CQUFPLENBQUMscUVBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxzQ0FBc0MsY0FBYztBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUVBQXlFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLHFCQUFxQixJQUFJLEtBQUs7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQXNDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPLEtBQUssS0FBSztBQUNyRTtBQUNBLGlCQUFpQjtBQUNqQixzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQsaUJBQWlCO0FBQ2pCLCtDQUErQyx1QkFBdUI7QUFDdEUsZ0RBQWdELGlCQUFpQjtBQUNqRSxpQkFBaUI7QUFDakI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQsZ0JBQWdCLGtDQUFrQztBQUNsRCxlQUFlLGlDQUFpQztBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9uZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBbiBhZGFwdGVyIGZvciBOZXh0LmpzIHRvIHNlcnZlIGFuZCByZWdpc3RlciBhbnkgZGVjbGFyZWQgZnVuY3Rpb25zIHdpdGhcbiAqIElubmdlc3QsIG1ha2luZyB0aGVtIGF2YWlsYWJsZSB0byBiZSB0cmlnZ2VyZWQgYnkgZXZlbnRzLlxuICpcbiAqIFN1cHBvcnRzIE5leHQuanMgMTIrLCBib3RoIHNlcnZlcmxlc3MgYW5kIGVkZ2UuXG4gKlxuICogQGV4YW1wbGUgTmV4dC5qcyA8PTEyIG9yIHRoZSBwYWdlcyByb3V0ZXIgY2FuIGV4cG9ydCB0aGUgaGFuZGxlciBkaXJlY3RseVxuICogYGBgdHNcbiAqIGV4cG9ydCBkZWZhdWx0IHNlcnZlKHsgY2xpZW50OiBpbm5nZXN0LCBmdW5jdGlvbnM6IFtmbjEsIGZuMl0gfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZSBOZXh0LmpzID49MTMgd2l0aCB0aGUgYGFwcGAgZGlyIG11c3QgZXhwb3J0IGluZGl2aWR1YWwgbWV0aG9kc1xuICogYGBgdHNcbiAqIGV4cG9ydCBjb25zdCB7IEdFVCwgUE9TVCwgUFVUIH0gPSBzZXJ2ZSh7XG4gKiAgICAgICAgICAgIGNsaWVudDogaW5uZ2VzdCxcbiAqICAgICAgICAgICAgZnVuY3Rpb25zOiBbZm4xLCBmbjJdLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VydmUgPSBleHBvcnRzLmZyYW1ld29ya05hbWUgPSB2b2lkIDA7XG5jb25zdCBJbm5nZXN0Q29tbUhhbmRsZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyLmpzXCIpO1xuY29uc3QgZW52X2pzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL2Vudi5qc1wiKTtcbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIGZyYW1ld29yaywgdXNlZCB0byBpZGVudGlmeSB0aGUgZnJhbWV3b3JrIGluIElubmdlc3RcbiAqIGRhc2hib2FyZHMgYW5kIGR1cmluZyB0ZXN0aW5nLlxuICovXG5leHBvcnRzLmZyYW1ld29ya05hbWUgPSBcIm5leHRqc1wiO1xuY29uc3QgaXNSZWNvcmQgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsO1xufTtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbn07XG5jb25zdCBpc05leHQxMkFwaVJlc3BvbnNlID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiAoaXNSZWNvcmQodmFsKSAmJlxuICAgICAgICBpc0Z1bmN0aW9uKHZhbC5zZXRIZWFkZXIpICYmXG4gICAgICAgIGlzRnVuY3Rpb24odmFsLnN0YXR1cykgJiZcbiAgICAgICAgaXNGdW5jdGlvbih2YWwuc2VuZCkpO1xufTtcbi8qKlxuICogSW4gTmV4dC5qcywgc2VydmUgYW5kIHJlZ2lzdGVyIGFueSBkZWNsYXJlZCBmdW5jdGlvbnMgd2l0aCBJbm5nZXN0LCBtYWtpbmdcbiAqIHRoZW0gYXZhaWxhYmxlIHRvIGJlIHRyaWdnZXJlZCBieSBldmVudHMuXG4gKlxuICogU3VwcG9ydHMgTmV4dC5qcyAxMissIGJvdGggc2VydmVybGVzcyBhbmQgZWRnZS5cbiAqXG4gKiBAZXhhbXBsZSBOZXh0LmpzIDw9MTIgb3IgdGhlIHBhZ2VzIHJvdXRlciBjYW4gZXhwb3J0IHRoZSBoYW5kbGVyIGRpcmVjdGx5XG4gKiBgYGB0c1xuICogZXhwb3J0IGRlZmF1bHQgc2VydmUoeyBjbGllbnQ6IGlubmdlc3QsIGZ1bmN0aW9uczogW2ZuMSwgZm4yXSB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIE5leHQuanMgPj0xMyB3aXRoIHRoZSBgYXBwYCBkaXIgbXVzdCBleHBvcnQgaW5kaXZpZHVhbCBtZXRob2RzXG4gKiBgYGB0c1xuICogZXhwb3J0IGNvbnN0IHsgR0VULCBQT1NULCBQVVQgfSA9IHNlcnZlKHtcbiAqICAgICAgICAgICAgY2xpZW50OiBpbm5nZXN0LFxuICogICAgICAgICAgICBmdW5jdGlvbnM6IFtmbjEsIGZuMl0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuLy8gSGFzIGV4cGxpY2l0IHJldHVybiB0eXBlIHRvIGF2b2lkIEpTUi1kZWZpbmVkIFwic2xvdyB0eXBlc1wiXG5jb25zdCBzZXJ2ZSA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBJbm5nZXN0Q29tbUhhbmRsZXJfanNfMS5Jbm5nZXN0Q29tbUhhbmRsZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZnJhbWV3b3JrTmFtZTogZXhwb3J0cy5mcmFtZXdvcmtOYW1lIH0sIG9wdGlvbnMpLCB7IGhhbmRsZXI6IChyZXFNZXRob2QsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtleHBlY3RlZFJlcSwgcmVzXSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBleHBlY3RlZFJlcTtcbiAgICAgICAgICAgIGNvbnN0IGdldEhlYWRlciA9IChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB0eXBlb2YgcmVxLmhlYWRlcnMuZ2V0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXEuaGVhZGVycy5nZXQoa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IHJlcS5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlclswXSA6IGhlYWRlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgIGJvZHk6ICgpID0+ICh0eXBlb2YgcmVxLmpzb24gPT09IFwiZnVuY3Rpb25cIiA/IHJlcS5qc29uKCkgOiByZXEuYm9keSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogYHJlcS5tZXRob2RgLCB0aG91Z2ggdHlwZXMgc2F5IG90aGVyd2lzZSwgaXMgbm90IGF2YWlsYWJsZSBpbiBOZXh0LmpzXG4gICAgICAgICAgICAgICAgICAgICAqIDEzIHtAbGluayBodHRwczovL2JldGEubmV4dGpzLm9yZy9kb2NzL3JvdXRpbmcvcm91dGUtaGFuZGxlcnMgUm91dGUgSGFuZGxlcnN9LlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGVyZWZvcmUsIHdlIG11c3QgdHJ5IHRvIHNldCB0aGUgbWV0aG9kIG91cnNlbHZlcyB3aGVyZSB3ZSBrbm93IGl0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxTWV0aG9kIHx8IHJlcS5tZXRob2QgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzUHJvZHVjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVmVyY2VsIEVkZ2UgRnVuY3Rpb25zIGRvIG5vdCBhbGxvdyBkeW5hbWljIGFjY2VzcyB0byBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgICAgICAgKiB2YXJpYWJsZXMsIHNvIHdlJ2xsIG1hbmFnZSBwcm9kdWN0aW9uIGNoZWNrcyBkaXJlY3RseSBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBXZSB0cnkvY2F0Y2ggdG8gYXZvaWQgc2l0dWF0aW9ucyB3aGVyZSBOZXh0LmpzIGlzIGJlaW5nIHVzZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICogZW52aXJvbm1lbnRzIHdoZXJlIGBwcm9jZXNzLmVudmAgaXMgbm90IGFjY2Vzc2libGUgb3IgcG9seWZpbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGlubmdlc3QvaW50ZXJuYWwvcHJvY2Vzcy13YXJuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Byb2QgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNQcm9kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nOiAoa2V5LCB1cmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBxcyA9ICgoX2EgPSByZXEucXVlcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtrZXldKSB8fCB1cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShxcykgPyBxc1swXSA6IHFzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXJsOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhYnNvbHV0ZVVybDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGByZXEudXJsYCBoZXJlIHNob3VsZCBtYXkgYmUgdGhlIGZ1bGwgVVJMLCBpbmNsdWRpbmcgcXVlcnkgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlcmUgYXJlIHNvbWUgY2F2ZWF0cywgaG93ZXZlciwgd2hlcmUgTmV4dC5qcyB3aWxsIG9iZnVzY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIGhvc3QuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZSBvZiBgaG9zdC5kb2NrZXIuaW50ZXJuYWxgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICogTmV4dC5qcyB3aWxsIGluc3RlYWQgc2V0IHRoZSBob3N0IGhlcmUgdG8gYGxvY2FsaG9zdGAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVG8gYXZvaWQgdGhpcywgd2UnbGwgdHJ5IHRvIHBhcnNlIHRoZSBVUkwgZnJvbSBgcmVxLnVybGAsIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICogYWxzbyB1c2UgdGhlIGBob3N0YCBoZWFkZXIgaWYgaXQncyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3QgPSBvcHRpb25zLnNlcnZlSG9zdCB8fCBnZXRIZWFkZXIoXCJob3N0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0V2l0aFByb3RvY29sID0gbmV3IFVSTChob3N0LmluY2x1ZGVzKFwiOi8vXCIpID8gaG9zdCA6IGAke2Fic29sdXRlVXJsLnByb3RvY29sfS8vJHtob3N0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsLnByb3RvY29sID0gaG9zdFdpdGhQcm90b2NvbC5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVVybC5ob3N0ID0gaG9zdFdpdGhQcm90b2NvbC5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsLnBvcnQgPSBob3N0V2l0aFByb3RvY29sLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVVcmwudXNlcm5hbWUgPSBob3N0V2l0aFByb3RvY29sLnVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsLnBhc3N3b3JkID0gaG9zdFdpdGhQcm90b2NvbC5wYXNzd29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2NoZW1lID0gXCJodHRwc1wiO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0ID0gb3B0aW9ucy5zZXJ2ZUhvc3QgfHwgZ2V0SGVhZGVyKFwiaG9zdFwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBpbm5nZXN0L2ludGVybmFsL3Byb2Nlc3Mtd2FyblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWUgPSBcImh0dHBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCwgYCR7c2NoZW1lfTovLyR7aG9zdH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiAoeyBib2R5LCBoZWFkZXJzLCBzdGF0dXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ2FyZWZ1bGx5IGF0dGVtcHQgdG8gc2V0IGhlYWRlcnMgYW5kIGRhdGEgb24gdGhlIHJlc3BvbnNlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgKiBmb3IgTmV4dC5qcyAxMiBzdXBwb3J0LlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGFsc28gYXNzdW1lcyB0aGF0IHdlJ3JlIG5vdCB1c2luZyBOZXh0LmpzIDE1LCB3aGVyZSB0aGUgYHJlc2BcbiAgICAgICAgICAgICAgICAgICAgICogb2JqZWN0IGlzIHJlcG9wdWxhdGVkIGFzIGEgYFJvdXRlQ29udGV4dGAgb2JqZWN0LiBXZSBleHBlY3QgdGhlc2VcbiAgICAgICAgICAgICAgICAgICAgICogbWV0aG9kcyB0byBOT1QgYmUgZGVmaW5lZCBpbiBOZXh0LmpzIDE1LlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiBXZSBjb3VsZCBsaWtlbHkgdXNlIGBpbnN0YW5jZW9mIFNlcnZlclJlc3BvbnNlYCB0byBiZXR0ZXIgY2hlY2sgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHR5cGUgb2YgdGhpcywgdGhvdWdoIE5leHQuanMgMTIgaGFkIGlzc3VlcyB3aXRoIHRoaXMgZHVlIHRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAgKiBpbnN0YW50aWF0aW5nIHRoZSByZXNwb25zZSBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZXh0MTJBcGlSZXNwb25zZShyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuc2VuZChib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgd2UncmUgaGVyZSwgd2UncmUgaW4gYSBzZXJ2ZXJsZXNzIGVuZHBvaW50IChub3QgZWRnZSksIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3ZSd2ZSBjb3JyZWN0bHkgc2VudCB0aGUgcmVzcG9uc2UgYW5kIGNhbiByZXR1cm4gYHVuZGVmaW5lZGAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogTmV4dC5qcyAxMyBlZGdlIHJlcXVpcmVzIHRoYXQgdGhlIHJldHVybiB2YWx1ZSBpcyB0eXBlZCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogYFJlc3BvbnNlYCwgc28gd2Ugc3RpbGwgZW5mb3JjZSB0aGF0IGFzIHdlIGNhbm5vdCBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgICogYWRqdXN0IHR5cGluZyBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIGhlcmUsIHdlJ3JlIGluIGFuIGVkZ2UgZW52aXJvbm1lbnQgYW5kIG5lZWQgdG8gcmV0dXJuIGFcbiAgICAgICAgICAgICAgICAgICAgICogYFJlc3BvbnNlYCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIGFsc28gZG9uJ3Qga25vdyBpZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICogYFJlc3BvbnNlYCBvYmplY3QsIHNvIHdlJ2xsIGdyYWIgdGhhdCBmaXJzdC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFJlcyA9ICgwLCBlbnZfanNfMS5nZXRSZXNwb25zZSkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXMoYm9keSwgeyBzdGF0dXMsIGhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJlYW1pbmdSZXNwb25zZTogKHsgYm9keSwgaGVhZGVycywgc3RhdHVzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCB7IHN0YXR1cywgaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSB9KSk7XG4gICAgLyoqXG4gICAgICogTmV4dC5qcyAxMyB1c2VzXG4gICAgICoge0BsaW5rIGh0dHBzOi8vYmV0YS5uZXh0anMub3JnL2RvY3Mvcm91dGluZy9yb3V0ZS1oYW5kbGVycyBSb3V0ZSBIYW5kbGVyc31cbiAgICAgKiB0byBkZWNsYXJlIEFQSSByb3V0ZXMgaW5zdGVhZCBvZiBhIGdlbmVyaWMgY2F0Y2gtYWxsIG1ldGhvZCB0aGF0IHdhc1xuICAgICAqIGF2YWlsYWJsZSB1c2luZyB0aGUgYHBhZ2VzL2FwaWAgZGlyZWN0b3J5LlxuICAgICAqXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHVzZXJzIG11c3Qgbm93IGV4cG9ydCBhIGZ1bmN0aW9uIGZvciBlYWNoIG1ldGhvZCBzdXBwb3J0ZWRcbiAgICAgKiBieSB0aGUgZW5kcG9pbnQuIEZvciB1cywgdGhpcyBtZWFucyByZXF1aXJpbmcgYSB1c2VyIGV4cGxpY2l0bHkgZXhwb3J0c1xuICAgICAqIGBHRVRgLCBgUE9TVGAsIGFuZCBgUFVUYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIG9mIHRoaXMsIHdlJ2xsIGFkZCBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHRob3NlIHByb3BlcnR5IG5hbWVzIG9mXG4gICAgICogdGhlIHJldHVybmVkIGhhbmRsZXIsIG1lYW5pbmcgd2UgY2FuIHdyaXRlIHNvbWUgc3VjY2luY3QgY29kZSB0byBleHBvcnRcbiAgICAgKiB0aGVtLiBUaGFua3MsIEBnb29kb2xkbmVvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBleHBvcnQgY29uc3QgeyBHRVQsIFBPU1QsIFBVVCB9ID0gc2VydmUoLi4uKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9iZXRhLm5leHRqcy5vcmcvZG9jcy9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzfVxuICAgICAqL1xuICAgIGNvbnN0IGJhc2VGbiA9IGhhbmRsZXIuY3JlYXRlSGFuZGxlcigpO1xuICAgIGNvbnN0IGZuID0gYmFzZUZuLmJpbmQobnVsbCwgdW5kZWZpbmVkKTtcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgd2UgaGF2ZSBhIG5vbi12YXJpYWRpYyBsZW5ndGggdG8gYXZvaWQgaXNzdWVzIHdpdGggZm9yY2VkIHR5cGVcbiAgICAgKiBjaGVja2luZy5cbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIFwibGVuZ3RoXCIsIHsgdmFsdWU6IDEgfSk7XG4gICAgY29uc3QgaGFuZGxlckZuID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZm4sIHtcbiAgICAgICAgR0VUOiB7IHZhbHVlOiBiYXNlRm4uYmluZChudWxsLCBcIkdFVFwiKSB9LFxuICAgICAgICBQT1NUOiB7IHZhbHVlOiBiYXNlRm4uYmluZChudWxsLCBcIlBPU1RcIikgfSxcbiAgICAgICAgUFVUOiB7IHZhbHVlOiBiYXNlRm4uYmluZChudWxsLCBcIlBVVFwiKSB9LFxuICAgIH0pO1xuICAgIHJldHVybiBoYW5kbGVyRm47XG59O1xuZXhwb3J0cy5zZXJ2ZSA9IHNlcnZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/next.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/debug/src/browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/inngest/node_modules/debug/src/browser.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/inngest/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0Qzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFVOztBQUVuQyxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0bGV0IG07XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJldHVybi1hc3NpZ25cblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgKG0gPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKSB8fCBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnREVCVUcnKSA7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/debug/src/common.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/debug/src/common.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/inngest/node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxpRUFBSTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJylcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9cXHMrL2csICcsJylcblx0XHRcdC5zcGxpdCgnLCcpXG5cdFx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdFx0Zm9yIChjb25zdCBucyBvZiBzcGxpdCkge1xuXHRcdFx0aWYgKG5zWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChucy5zbGljZSgxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5zKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHJpbmcgbWF0Y2hlcyBhIG5hbWVzcGFjZSB0ZW1wbGF0ZSwgaG9ub3Jpbmdcblx0ICogYXN0ZXJpc2tzIGFzIHdpbGRjYXJkcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoZXNUZW1wbGF0ZShzZWFyY2gsIHRlbXBsYXRlKSB7XG5cdFx0bGV0IHNlYXJjaEluZGV4ID0gMDtcblx0XHRsZXQgdGVtcGxhdGVJbmRleCA9IDA7XG5cdFx0bGV0IHN0YXJJbmRleCA9IC0xO1xuXHRcdGxldCBtYXRjaEluZGV4ID0gMDtcblxuXHRcdHdoaWxlIChzZWFyY2hJbmRleCA8IHNlYXJjaC5sZW5ndGgpIHtcblx0XHRcdGlmICh0ZW1wbGF0ZUluZGV4IDwgdGVtcGxhdGUubGVuZ3RoICYmICh0ZW1wbGF0ZVt0ZW1wbGF0ZUluZGV4XSA9PT0gc2VhcmNoW3NlYXJjaEluZGV4XSB8fCB0ZW1wbGF0ZVt0ZW1wbGF0ZUluZGV4XSA9PT0gJyonKSkge1xuXHRcdFx0XHQvLyBNYXRjaCBjaGFyYWN0ZXIgb3IgcHJvY2VlZCB3aXRoIHdpbGRjYXJkXG5cdFx0XHRcdGlmICh0ZW1wbGF0ZVt0ZW1wbGF0ZUluZGV4XSA9PT0gJyonKSB7XG5cdFx0XHRcdFx0c3RhckluZGV4ID0gdGVtcGxhdGVJbmRleDtcblx0XHRcdFx0XHRtYXRjaEluZGV4ID0gc2VhcmNoSW5kZXg7XG5cdFx0XHRcdFx0dGVtcGxhdGVJbmRleCsrOyAvLyBTa2lwIHRoZSAnKidcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWFyY2hJbmRleCsrO1xuXHRcdFx0XHRcdHRlbXBsYXRlSW5kZXgrKztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChzdGFySW5kZXggIT09IC0xKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVnYXRlZC1jb25kaXRpb25cblx0XHRcdFx0Ly8gQmFja3RyYWNrIHRvIHRoZSBsYXN0ICcqJyBhbmQgdHJ5IHRvIG1hdGNoIG1vcmUgY2hhcmFjdGVyc1xuXHRcdFx0XHR0ZW1wbGF0ZUluZGV4ID0gc3RhckluZGV4ICsgMTtcblx0XHRcdFx0bWF0Y2hJbmRleCsrO1xuXHRcdFx0XHRzZWFyY2hJbmRleCA9IG1hdGNoSW5kZXg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIE5vIG1hdGNoXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIHRyYWlsaW5nICcqJyBpbiB0ZW1wbGF0ZVxuXHRcdHdoaWxlICh0ZW1wbGF0ZUluZGV4IDwgdGVtcGxhdGUubGVuZ3RoICYmIHRlbXBsYXRlW3RlbXBsYXRlSW5kZXhdID09PSAnKicpIHtcblx0XHRcdHRlbXBsYXRlSW5kZXgrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGVtcGxhdGVJbmRleCA9PT0gdGVtcGxhdGUubGVuZ3RoO1xuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcyxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0Zm9yIChjb25zdCBza2lwIG9mIGNyZWF0ZURlYnVnLnNraXBzKSB7XG5cdFx0XHRpZiAobWF0Y2hlc1RlbXBsYXRlKG5hbWUsIHNraXApKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IG5zIG9mIGNyZWF0ZURlYnVnLm5hbWVzKSB7XG5cdFx0XHRpZiAobWF0Y2hlc1RlbXBsYXRlKG5hbWUsIG5zKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/debug/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/node_modules/debug/src/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || false === true || process.__nwjs) {\n\tmodule.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/inngest/node_modules/debug/src/browser.js\");\n} else {\n\tmodule.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/inngest/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRSxLQUFlO0FBQ3BGLENBQUMsMEhBQXdDO0FBQ3pDLEVBQUU7QUFDRixDQUFDLG9IQUFxQztBQUN0QyIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/debug/src/node.js":
/*!*************************************************************!*\
  !*** ./node_modules/inngest/node_modules/debug/src/node.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/inngest/node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1osV0FBVztBQUNYLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsb0VBQWdCOztBQUUvQztBQUNBLEVBQUUsY0FBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDRCQUE0Qjs7QUFFcEM7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25ELHNCQUFzQixXQUFXLElBQUksTUFBTTs7QUFFM0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBVTs7QUFFbkMsT0FBTyxZQUFZOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYWhhcnBlci9pbm5nZXN0L2lubmdlc3Qtc2FuZGJveC90cy1uZXh0L25vZGVfbW9kdWxlcy9pbm5nZXN0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXRXaXRoT3B0aW9ucygpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdFdpdGhPcHRpb25zKGV4cG9ydHMuaW5zcGVjdE9wdHMsIC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/ms/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/inngest/node_modules/ms/index.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9haGFycGVyL2lubmdlc3QvaW5uZ2VzdC1zYW5kYm94L3RzLW5leHQvbm9kZV9tb2R1bGVzL2lubmdlc3Qvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/ms/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/types.js":
/*!***************************************!*\
  !*** ./node_modules/inngest/types.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Internal types and schemas used throughout the Inngest SDK.\n *\n * Note that types intended to be imported and utilized in userland code will be\n * exported from the main entrypoint of the SDK, `inngest`; importing types\n * directly from this file may result in breaking changes in non-major bumps as\n * only those exported from `inngest` are considered stable.\n *\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.inBandSyncRequestBodySchema = exports.err = exports.ok = exports.functionConfigSchema = exports.logLevels = exports.sendEventResponseSchema = exports.incomingOpSchema = exports.StepOpCode = exports.jsonErrorSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst baseJsonErrorSchema = zod_1.z.object({\n    name: zod_1.z.string().trim().optional(),\n    error: zod_1.z.string().trim().optional(),\n    message: zod_1.z.string().trim().optional(),\n    stack: zod_1.z.string().trim().optional(),\n});\nconst maybeJsonErrorSchema = zod_1.z.lazy(() => zod_1.z.object({\n    name: zod_1.z.string().trim(),\n    message: zod_1.z.string().trim(),\n    stack: zod_1.z.string().trim().optional(),\n    cause: zod_1.z.union([maybeJsonErrorSchema, zod_1.z.unknown()]).optional(),\n}));\nexports.jsonErrorSchema = baseJsonErrorSchema\n    .extend({\n    cause: zod_1.z.union([maybeJsonErrorSchema, zod_1.z.unknown()]).optional(),\n})\n    .passthrough()\n    .catch({})\n    .transform((val) => {\n    return Object.assign(Object.assign({}, val), { name: val.name || \"Error\", message: val.message || val.error || \"Unknown error\", stack: val.stack });\n});\n/**\n * Unique codes for the different types of operation that can be sent to Inngest\n * from SDK step functions.\n */\nvar StepOpCode;\n(function (StepOpCode) {\n    StepOpCode[\"WaitForSignal\"] = \"WaitForSignal\";\n    StepOpCode[\"WaitForEvent\"] = \"WaitForEvent\";\n    /**\n     * Legacy equivalent to `\"StepRun\"`. Has mixed data wrapping (e.g. `data` or\n     * `data.data` depending on SDK version), so this is phased out in favour of\n     * `\"StepRun\"`, which never wraps.\n     *\n     * Note that it is still used for v0 executions for backwards compatibility.\n     *\n     * @deprecated Only used for v0 executions; use `\"StepRun\"` instead.\n     */\n    StepOpCode[\"Step\"] = \"Step\";\n    StepOpCode[\"StepRun\"] = \"StepRun\";\n    StepOpCode[\"StepError\"] = \"StepError\";\n    StepOpCode[\"StepPlanned\"] = \"StepPlanned\";\n    StepOpCode[\"Sleep\"] = \"Sleep\";\n    /**\n     * Used to signify that the executor has requested that a step run, but we\n     * could not find that step.\n     *\n     * This is likely indicative that a step was renamed or removed from the\n     * function.\n     */\n    StepOpCode[\"StepNotFound\"] = \"StepNotFound\";\n    StepOpCode[\"InvokeFunction\"] = \"InvokeFunction\";\n    StepOpCode[\"AiGateway\"] = \"AIGateway\";\n    StepOpCode[\"Gateway\"] = \"Gateway\";\n})(StepOpCode || (exports.StepOpCode = StepOpCode = {}));\nexports.incomingOpSchema = zod_1.z.object({\n    id: zod_1.z.string().min(1),\n    data: zod_1.z.any().optional(),\n    error: zod_1.z.any().optional(),\n    input: zod_1.z.any().optional(),\n});\nexports.sendEventResponseSchema = zod_1.z.object({\n    /**\n     * Event IDs\n     */\n    ids: zod_1.z.array(zod_1.z.string()).default([]),\n    /**\n     * HTTP Status Code. Will be undefined if no request was sent.\n     */\n    status: zod_1.z.number().default(0),\n    /**\n     * Error message. Will be undefined if no error occurred.\n     */\n    error: zod_1.z.string().optional(),\n});\n/**\n * A set of log levels that can be used to control the amount of logging output\n * from various parts of the Inngest library.\n *\n * @public\n */\nexports.logLevels = [\n    \"fatal\",\n    \"error\",\n    \"warn\",\n    \"info\",\n    \"debug\",\n    \"silent\",\n];\n/**\n * This schema is used internally to share the shape of a concurrency option\n * when validating config. We cannot add comments to Zod fields, so we just use\n * an extra type check to ensure it matches our exported expectations.\n */\nconst concurrencyOptionSchema = zod_1.z.strictObject({\n    limit: zod_1.z.number(),\n    key: zod_1.z.string().optional(),\n    scope: zod_1.z.enum([\"fn\", \"env\", \"account\"]).optional(),\n});\nconst _checkConcurrencySchemaAligns = true;\n/**\n * The schema used to represent an individual function being synced with\n * Inngest.\n *\n * Note that this should only be used to validate the shape of a config object\n * and not used for feature compatibility, such as feature X being exclusive\n * with feature Y; these should be handled on the Inngest side.\n */\nexports.functionConfigSchema = zod_1.z.strictObject({\n    name: zod_1.z.string().optional(),\n    id: zod_1.z.string(),\n    triggers: zod_1.z.array(zod_1.z.union([\n        zod_1.z.strictObject({\n            event: zod_1.z.string(),\n            expression: zod_1.z.string().optional(),\n        }),\n        zod_1.z.strictObject({\n            cron: zod_1.z.string(),\n        }),\n    ])),\n    steps: zod_1.z.record(zod_1.z.strictObject({\n        id: zod_1.z.string(),\n        name: zod_1.z.string(),\n        runtime: zod_1.z.strictObject({\n            type: zod_1.z.union([zod_1.z.literal(\"http\"), zod_1.z.literal(\"ws\")]),\n            url: zod_1.z.string(),\n        }),\n        retries: zod_1.z\n            .strictObject({\n            attempts: zod_1.z.number().optional(),\n        })\n            .optional(),\n    })),\n    idempotency: zod_1.z.string().optional(),\n    batchEvents: zod_1.z\n        .strictObject({\n        maxSize: zod_1.z.number(),\n        timeout: zod_1.z.string(),\n        key: zod_1.z.string().optional(),\n    })\n        .optional(),\n    rateLimit: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        limit: zod_1.z.number(),\n        period: zod_1.z.string().transform((x) => x),\n    })\n        .optional(),\n    throttle: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        limit: zod_1.z.number(),\n        period: zod_1.z.string().transform((x) => x),\n        burst: zod_1.z.number().optional(),\n    })\n        .optional(),\n    singleton: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        mode: zod_1.z.enum([\"skip\", \"cancel\"]),\n    })\n        .optional(),\n    cancel: zod_1.z\n        .array(zod_1.z.strictObject({\n        event: zod_1.z.string(),\n        if: zod_1.z.string().optional(),\n        timeout: zod_1.z.string().optional(),\n    }))\n        .optional(),\n    debounce: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        period: zod_1.z.string().transform((x) => x),\n        timeout: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n    })\n        .optional(),\n    timeouts: zod_1.z\n        .strictObject({\n        start: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n        finish: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n    })\n        .optional(),\n    priority: zod_1.z\n        .strictObject({\n        run: zod_1.z.string().optional(),\n    })\n        .optional(),\n    concurrency: zod_1.z\n        .union([\n        zod_1.z.number(),\n        concurrencyOptionSchema.transform((x) => x),\n        zod_1.z\n            .array(concurrencyOptionSchema.transform((x) => x))\n            .min(1)\n            .max(2),\n    ])\n        .optional(),\n});\nconst ok = (data) => {\n    return { ok: true, value: data };\n};\nexports.ok = ok;\nconst err = (error) => {\n    return { ok: false, error };\n};\nexports.err = err;\nexports.inBandSyncRequestBodySchema = zod_1.z.strictObject({\n    url: zod_1.z.string(),\n});\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsV0FBVyxHQUFHLFVBQVUsR0FBRyw0QkFBNEIsR0FBRyxpQkFBaUIsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDN04sY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYjtBQUNBLHlDQUF5QyxVQUFVLG1HQUFtRztBQUN0SixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3RELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLG1DQUFtQztBQUNuQztBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogSW50ZXJuYWwgdHlwZXMgYW5kIHNjaGVtYXMgdXNlZCB0aHJvdWdob3V0IHRoZSBJbm5nZXN0IFNESy5cbiAqXG4gKiBOb3RlIHRoYXQgdHlwZXMgaW50ZW5kZWQgdG8gYmUgaW1wb3J0ZWQgYW5kIHV0aWxpemVkIGluIHVzZXJsYW5kIGNvZGUgd2lsbCBiZVxuICogZXhwb3J0ZWQgZnJvbSB0aGUgbWFpbiBlbnRyeXBvaW50IG9mIHRoZSBTREssIGBpbm5nZXN0YDsgaW1wb3J0aW5nIHR5cGVzXG4gKiBkaXJlY3RseSBmcm9tIHRoaXMgZmlsZSBtYXkgcmVzdWx0IGluIGJyZWFraW5nIGNoYW5nZXMgaW4gbm9uLW1ham9yIGJ1bXBzIGFzXG4gKiBvbmx5IHRob3NlIGV4cG9ydGVkIGZyb20gYGlubmdlc3RgIGFyZSBjb25zaWRlcmVkIHN0YWJsZS5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5CYW5kU3luY1JlcXVlc3RCb2R5U2NoZW1hID0gZXhwb3J0cy5lcnIgPSBleHBvcnRzLm9rID0gZXhwb3J0cy5mdW5jdGlvbkNvbmZpZ1NjaGVtYSA9IGV4cG9ydHMubG9nTGV2ZWxzID0gZXhwb3J0cy5zZW5kRXZlbnRSZXNwb25zZVNjaGVtYSA9IGV4cG9ydHMuaW5jb21pbmdPcFNjaGVtYSA9IGV4cG9ydHMuU3RlcE9wQ29kZSA9IGV4cG9ydHMuanNvbkVycm9yU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgYmFzZUpzb25FcnJvclNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBuYW1lOiB6b2RfMS56LnN0cmluZygpLnRyaW0oKS5vcHRpb25hbCgpLFxuICAgIGVycm9yOiB6b2RfMS56LnN0cmluZygpLnRyaW0oKS5vcHRpb25hbCgpLFxuICAgIG1lc3NhZ2U6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLm9wdGlvbmFsKCksXG4gICAgc3RhY2s6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IG1heWJlSnNvbkVycm9yU2NoZW1hID0gem9kXzEuei5sYXp5KCgpID0+IHpvZF8xLnoub2JqZWN0KHtcbiAgICBuYW1lOiB6b2RfMS56LnN0cmluZygpLnRyaW0oKSxcbiAgICBtZXNzYWdlOiB6b2RfMS56LnN0cmluZygpLnRyaW0oKSxcbiAgICBzdGFjazogem9kXzEuei5zdHJpbmcoKS50cmltKCkub3B0aW9uYWwoKSxcbiAgICBjYXVzZTogem9kXzEuei51bmlvbihbbWF5YmVKc29uRXJyb3JTY2hlbWEsIHpvZF8xLnoudW5rbm93bigpXSkub3B0aW9uYWwoKSxcbn0pKTtcbmV4cG9ydHMuanNvbkVycm9yU2NoZW1hID0gYmFzZUpzb25FcnJvclNjaGVtYVxuICAgIC5leHRlbmQoe1xuICAgIGNhdXNlOiB6b2RfMS56LnVuaW9uKFttYXliZUpzb25FcnJvclNjaGVtYSwgem9kXzEuei51bmtub3duKCldKS5vcHRpb25hbCgpLFxufSlcbiAgICAucGFzc3Rocm91Z2goKVxuICAgIC5jYXRjaCh7fSlcbiAgICAudHJhbnNmb3JtKCh2YWwpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWwpLCB7IG5hbWU6IHZhbC5uYW1lIHx8IFwiRXJyb3JcIiwgbWVzc2FnZTogdmFsLm1lc3NhZ2UgfHwgdmFsLmVycm9yIHx8IFwiVW5rbm93biBlcnJvclwiLCBzdGFjazogdmFsLnN0YWNrIH0pO1xufSk7XG4vKipcbiAqIFVuaXF1ZSBjb2RlcyBmb3IgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBvcGVyYXRpb24gdGhhdCBjYW4gYmUgc2VudCB0byBJbm5nZXN0XG4gKiBmcm9tIFNESyBzdGVwIGZ1bmN0aW9ucy5cbiAqL1xudmFyIFN0ZXBPcENvZGU7XG4oZnVuY3Rpb24gKFN0ZXBPcENvZGUpIHtcbiAgICBTdGVwT3BDb2RlW1wiV2FpdEZvclNpZ25hbFwiXSA9IFwiV2FpdEZvclNpZ25hbFwiO1xuICAgIFN0ZXBPcENvZGVbXCJXYWl0Rm9yRXZlbnRcIl0gPSBcIldhaXRGb3JFdmVudFwiO1xuICAgIC8qKlxuICAgICAqIExlZ2FjeSBlcXVpdmFsZW50IHRvIGBcIlN0ZXBSdW5cImAuIEhhcyBtaXhlZCBkYXRhIHdyYXBwaW5nIChlLmcuIGBkYXRhYCBvclxuICAgICAqIGBkYXRhLmRhdGFgIGRlcGVuZGluZyBvbiBTREsgdmVyc2lvbiksIHNvIHRoaXMgaXMgcGhhc2VkIG91dCBpbiBmYXZvdXIgb2ZcbiAgICAgKiBgXCJTdGVwUnVuXCJgLCB3aGljaCBuZXZlciB3cmFwcy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBpdCBpcyBzdGlsbCB1c2VkIGZvciB2MCBleGVjdXRpb25zIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIE9ubHkgdXNlZCBmb3IgdjAgZXhlY3V0aW9uczsgdXNlIGBcIlN0ZXBSdW5cImAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBTdGVwT3BDb2RlW1wiU3RlcFwiXSA9IFwiU3RlcFwiO1xuICAgIFN0ZXBPcENvZGVbXCJTdGVwUnVuXCJdID0gXCJTdGVwUnVuXCI7XG4gICAgU3RlcE9wQ29kZVtcIlN0ZXBFcnJvclwiXSA9IFwiU3RlcEVycm9yXCI7XG4gICAgU3RlcE9wQ29kZVtcIlN0ZXBQbGFubmVkXCJdID0gXCJTdGVwUGxhbm5lZFwiO1xuICAgIFN0ZXBPcENvZGVbXCJTbGVlcFwiXSA9IFwiU2xlZXBcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHNpZ25pZnkgdGhhdCB0aGUgZXhlY3V0b3IgaGFzIHJlcXVlc3RlZCB0aGF0IGEgc3RlcCBydW4sIGJ1dCB3ZVxuICAgICAqIGNvdWxkIG5vdCBmaW5kIHRoYXQgc3RlcC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbGlrZWx5IGluZGljYXRpdmUgdGhhdCBhIHN0ZXAgd2FzIHJlbmFtZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZVxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIFN0ZXBPcENvZGVbXCJTdGVwTm90Rm91bmRcIl0gPSBcIlN0ZXBOb3RGb3VuZFwiO1xuICAgIFN0ZXBPcENvZGVbXCJJbnZva2VGdW5jdGlvblwiXSA9IFwiSW52b2tlRnVuY3Rpb25cIjtcbiAgICBTdGVwT3BDb2RlW1wiQWlHYXRld2F5XCJdID0gXCJBSUdhdGV3YXlcIjtcbiAgICBTdGVwT3BDb2RlW1wiR2F0ZXdheVwiXSA9IFwiR2F0ZXdheVwiO1xufSkoU3RlcE9wQ29kZSB8fCAoZXhwb3J0cy5TdGVwT3BDb2RlID0gU3RlcE9wQ29kZSA9IHt9KSk7XG5leHBvcnRzLmluY29taW5nT3BTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgaWQ6IHpvZF8xLnouc3RyaW5nKCkubWluKDEpLFxuICAgIGRhdGE6IHpvZF8xLnouYW55KCkub3B0aW9uYWwoKSxcbiAgICBlcnJvcjogem9kXzEuei5hbnkoKS5vcHRpb25hbCgpLFxuICAgIGlucHV0OiB6b2RfMS56LmFueSgpLm9wdGlvbmFsKCksXG59KTtcbmV4cG9ydHMuc2VuZEV2ZW50UmVzcG9uc2VTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgLyoqXG4gICAgICogRXZlbnQgSURzXG4gICAgICovXG4gICAgaWRzOiB6b2RfMS56LmFycmF5KHpvZF8xLnouc3RyaW5nKCkpLmRlZmF1bHQoW10pLFxuICAgIC8qKlxuICAgICAqIEhUVFAgU3RhdHVzIENvZGUuIFdpbGwgYmUgdW5kZWZpbmVkIGlmIG5vIHJlcXVlc3Qgd2FzIHNlbnQuXG4gICAgICovXG4gICAgc3RhdHVzOiB6b2RfMS56Lm51bWJlcigpLmRlZmF1bHQoMCksXG4gICAgLyoqXG4gICAgICogRXJyb3IgbWVzc2FnZS4gV2lsbCBiZSB1bmRlZmluZWQgaWYgbm8gZXJyb3Igb2NjdXJyZWQuXG4gICAgICovXG4gICAgZXJyb3I6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuLyoqXG4gKiBBIHNldCBvZiBsb2cgbGV2ZWxzIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29udHJvbCB0aGUgYW1vdW50IG9mIGxvZ2dpbmcgb3V0cHV0XG4gKiBmcm9tIHZhcmlvdXMgcGFydHMgb2YgdGhlIElubmdlc3QgbGlicmFyeS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMubG9nTGV2ZWxzID0gW1xuICAgIFwiZmF0YWxcIixcbiAgICBcImVycm9yXCIsXG4gICAgXCJ3YXJuXCIsXG4gICAgXCJpbmZvXCIsXG4gICAgXCJkZWJ1Z1wiLFxuICAgIFwic2lsZW50XCIsXG5dO1xuLyoqXG4gKiBUaGlzIHNjaGVtYSBpcyB1c2VkIGludGVybmFsbHkgdG8gc2hhcmUgdGhlIHNoYXBlIG9mIGEgY29uY3VycmVuY3kgb3B0aW9uXG4gKiB3aGVuIHZhbGlkYXRpbmcgY29uZmlnLiBXZSBjYW5ub3QgYWRkIGNvbW1lbnRzIHRvIFpvZCBmaWVsZHMsIHNvIHdlIGp1c3QgdXNlXG4gKiBhbiBleHRyYSB0eXBlIGNoZWNrIHRvIGVuc3VyZSBpdCBtYXRjaGVzIG91ciBleHBvcnRlZCBleHBlY3RhdGlvbnMuXG4gKi9cbmNvbnN0IGNvbmN1cnJlbmN5T3B0aW9uU2NoZW1hID0gem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgIGxpbWl0OiB6b2RfMS56Lm51bWJlcigpLFxuICAgIGtleTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHNjb3BlOiB6b2RfMS56LmVudW0oW1wiZm5cIiwgXCJlbnZcIiwgXCJhY2NvdW50XCJdKS5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBfY2hlY2tDb25jdXJyZW5jeVNjaGVtYUFsaWducyA9IHRydWU7XG4vKipcbiAqIFRoZSBzY2hlbWEgdXNlZCB0byByZXByZXNlbnQgYW4gaW5kaXZpZHVhbCBmdW5jdGlvbiBiZWluZyBzeW5jZWQgd2l0aFxuICogSW5uZ2VzdC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBzaGFwZSBvZiBhIGNvbmZpZyBvYmplY3RcbiAqIGFuZCBub3QgdXNlZCBmb3IgZmVhdHVyZSBjb21wYXRpYmlsaXR5LCBzdWNoIGFzIGZlYXR1cmUgWCBiZWluZyBleGNsdXNpdmVcbiAqIHdpdGggZmVhdHVyZSBZOyB0aGVzZSBzaG91bGQgYmUgaGFuZGxlZCBvbiB0aGUgSW5uZ2VzdCBzaWRlLlxuICovXG5leHBvcnRzLmZ1bmN0aW9uQ29uZmlnU2NoZW1hID0gem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBpZDogem9kXzEuei5zdHJpbmcoKSxcbiAgICB0cmlnZ2Vyczogem9kXzEuei5hcnJheSh6b2RfMS56LnVuaW9uKFtcbiAgICAgICAgem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgICAgICAgICAgZXZlbnQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICBleHByZXNzaW9uOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIH0pLFxuICAgICAgICB6b2RfMS56LnN0cmljdE9iamVjdCh7XG4gICAgICAgICAgICBjcm9uOiB6b2RfMS56LnN0cmluZygpLFxuICAgICAgICB9KSxcbiAgICBdKSksXG4gICAgc3RlcHM6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgaWQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIHJ1bnRpbWU6IHpvZF8xLnouc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHpvZF8xLnoudW5pb24oW3pvZF8xLnoubGl0ZXJhbChcImh0dHBcIiksIHpvZF8xLnoubGl0ZXJhbChcIndzXCIpXSksXG4gICAgICAgICAgICB1cmw6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIH0pLFxuICAgICAgICByZXRyaWVzOiB6b2RfMS56XG4gICAgICAgICAgICAuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgICAgIGF0dGVtcHRzOiB6b2RfMS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3B0aW9uYWwoKSxcbiAgICB9KSksXG4gICAgaWRlbXBvdGVuY3k6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBiYXRjaEV2ZW50czogem9kXzEuelxuICAgICAgICAuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgbWF4U2l6ZTogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgdGltZW91dDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAga2V5OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgfSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgcmF0ZUxpbWl0OiB6b2RfMS56XG4gICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBrZXk6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgbGltaXQ6IHpvZF8xLnoubnVtYmVyKCksXG4gICAgICAgIHBlcmlvZDogem9kXzEuei5zdHJpbmcoKS50cmFuc2Zvcm0oKHgpID0+IHgpLFxuICAgIH0pXG4gICAgICAgIC5vcHRpb25hbCgpLFxuICAgIHRocm90dGxlOiB6b2RfMS56XG4gICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBrZXk6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgbGltaXQ6IHpvZF8xLnoubnVtYmVyKCksXG4gICAgICAgIHBlcmlvZDogem9kXzEuei5zdHJpbmcoKS50cmFuc2Zvcm0oKHgpID0+IHgpLFxuICAgICAgICBidXJzdDogem9kXzEuei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIH0pXG4gICAgICAgIC5vcHRpb25hbCgpLFxuICAgIHNpbmdsZXRvbjogem9kXzEuelxuICAgICAgICAuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAga2V5OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIG1vZGU6IHpvZF8xLnouZW51bShbXCJza2lwXCIsIFwiY2FuY2VsXCJdKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICBjYW5jZWw6IHpvZF8xLnpcbiAgICAgICAgLmFycmF5KHpvZF8xLnouc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgZXZlbnQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIGlmOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIHRpbWVvdXQ6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgZGVib3VuY2U6IHpvZF8xLnpcbiAgICAgICAgLnN0cmljdE9iamVjdCh7XG4gICAgICAgIGtleTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBwZXJpb2Q6IHpvZF8xLnouc3RyaW5nKCkudHJhbnNmb3JtKCh4KSA9PiB4KSxcbiAgICAgICAgdGltZW91dDogem9kXzEuelxuICAgICAgICAgICAgLnN0cmluZygpXG4gICAgICAgICAgICAudHJhbnNmb3JtKCh4KSA9PiB4KVxuICAgICAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgfSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgdGltZW91dHM6IHpvZF8xLnpcbiAgICAgICAgLnN0cmljdE9iamVjdCh7XG4gICAgICAgIHN0YXJ0OiB6b2RfMS56XG4gICAgICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgICAgIC50cmFuc2Zvcm0oKHgpID0+IHgpXG4gICAgICAgICAgICAub3B0aW9uYWwoKSxcbiAgICAgICAgZmluaXNoOiB6b2RfMS56XG4gICAgICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgICAgIC50cmFuc2Zvcm0oKHgpID0+IHgpXG4gICAgICAgICAgICAub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICBwcmlvcml0eTogem9kXzEuelxuICAgICAgICAuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgcnVuOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgfSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgY29uY3VycmVuY3k6IHpvZF8xLnpcbiAgICAgICAgLnVuaW9uKFtcbiAgICAgICAgem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgY29uY3VycmVuY3lPcHRpb25TY2hlbWEudHJhbnNmb3JtKCh4KSA9PiB4KSxcbiAgICAgICAgem9kXzEuelxuICAgICAgICAgICAgLmFycmF5KGNvbmN1cnJlbmN5T3B0aW9uU2NoZW1hLnRyYW5zZm9ybSgoeCkgPT4geCkpXG4gICAgICAgICAgICAubWluKDEpXG4gICAgICAgICAgICAubWF4KDIpLFxuICAgIF0pXG4gICAgICAgIC5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBvayA9IChkYXRhKSA9PiB7XG4gICAgcmV0dXJuIHsgb2s6IHRydWUsIHZhbHVlOiBkYXRhIH07XG59O1xuZXhwb3J0cy5vayA9IG9rO1xuY29uc3QgZXJyID0gKGVycm9yKSA9PiB7XG4gICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvciB9O1xufTtcbmV4cG9ydHMuZXJyID0gZXJyO1xuZXhwb3J0cy5pbkJhbmRTeW5jUmVxdWVzdEJvZHlTY2hlbWEgPSB6b2RfMS56LnN0cmljdE9iamVjdCh7XG4gICAgdXJsOiB6b2RfMS56LnN0cmluZygpLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/version.js":
/*!*****************************************!*\
  !*** ./node_modules/inngest/version.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\n// Generated by genversion.\nexports.version = \"3.40.0\";\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL2FoYXJwZXIvaW5uZ2VzdC9pbm5nZXN0LXNhbmRib3gvdHMtbmV4dC9ub2RlX21vZHVsZXMvaW5uZ2VzdC92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuLy8gR2VuZXJhdGVkIGJ5IGdlbnZlcnNpb24uXG5leHBvcnRzLnZlcnNpb24gPSBcIjMuNDAuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/version.js\n");

/***/ })

};
;